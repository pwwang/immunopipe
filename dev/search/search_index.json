{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Integrative analysis for single-cell RNA sequencing and single-cell TCR sequencing data immunopipe is a pipeline based on pipen framework. It includes a set of processes for scTCR- and scRNA-seq data analysis in R , python and bash . The pipeline is designed to be flexible and configurable. See a more detailed flowchart here . Documentaion \u00b6 https://pwwang.github.io/immunopipe Proposing more analyses \u00b6 If you have any suggestions for more analyses, please feel free to open an issue here Example \u00b6 https://github.com/pwwang/immunopipe-example Gallery \u00b6 There are some datasets with both scRNA-seq and scTCR-seq data available in the publications. The data were reanalyzed using immunopipe with the configurations provided in each repository, where the results are also available. Check out the gallery for more details.","title":"Home"},{"location":"#documentaion","text":"https://pwwang.github.io/immunopipe","title":"Documentaion"},{"location":"#proposing-more-analyses","text":"If you have any suggestions for more analyses, please feel free to open an issue here","title":"Proposing more analyses"},{"location":"#example","text":"https://github.com/pwwang/immunopipe-example","title":"Example"},{"location":"#gallery","text":"There are some datasets with both scRNA-seq and scTCR-seq data available in the publications. The data were reanalyzed using immunopipe with the configurations provided in each repository, where the results are also available. Check out the gallery for more details.","title":"Gallery"},{"location":"CHANGELOG/","text":"Change Log \u00b6 1.4.3 \u00b6 deps: update pipen-runinfo dependency to version 0.8.0 (pipen to 0.15.2) deps: update biopipen dependency to version 0.31.4 fix(scrna.SeuratMap2Ref): fix refnorm not detected for NormlizeData'ed reference 1.4.2 \u00b6 deps: add bioconductor-destiny dependency in docker environment files for ModuleScoreCalculator 1.4.1 \u00b6 docs: update tutorial dataset information and links 1.4.0 \u00b6 docs: update Singularity and Apptainer commands to include --writable-tmpfs flag docs: allow collapsing ns/choice items in the docs for processes docker: update Dockerfile to include npm cache configuration to allow the pipeline to run on read-only file system tests: update SeuratPreparing config to use DoubletFinder for doublet detection ci: use latest actions deps: add r-clustree as a dependency in docker environment files deps: update dependencies in docker environment files (python3.10, R4.3) deps: bump biopipen to 0.29.0 fix(tcr.TCRClusterStats): fix envs.shared_clusters.heatmap_meta being broken by envs.shared_clusters.sample_order (@ li.ying@mayo.edu ) choir(scrna.SeuratMap2Ref): present better error message when envs.use or values of envs.MapQuery.refdata not in reference (@ li.ying@mayo.edu ) fix(scrna.MarkersFinder): run PrepSCTFindMarkers when needed choir(scrna.SeuratClustering): use FindClusters to run for multiple resolutions choir(scrna.SeuratSubClustering): use FindClusters to run for multiple resolutions feat(scrna.SeuratClustering): add clustree plot (@ li.ying@mayo.edu ) feat(scrna.SeuratSubClustering): add clustree plot tests(scrna.SeuratClusterStats): add assertion for clustree plot generation deps: bump biopipen to 0.29.1 fix(delim.SampleInfo): fix numbers not split up when each is specified. enh(delim.SampleInfo): make sizes of pie charts proportional to number of samples when each is specified enh(scrna.MarkersFinder): run PrepSCTFindMarkers when necessary before calling FindMarkers feat(scrna.SeuratPreparing): add option to cache Seurat object at different steps feat(scrna.SeuratPreparing): allow doubletfinder to run with a different number of cores chore(scrna.SeuratClustering): record PrepSCTFindMarkers command in sobj@commands tests(scrna.SeuratClusterStats): use less stringent p-value cutoff for DEG/MarkersFinder tests(scrna.SeuratPreparing): add doubletfinder in tests deps: bump biopipen to 0.29.2 chore(scrna.SeuratClusterStats): use ident label length to adjust default height for feature plots fix(scrna.MetaMarkers): fix seurat object not updated when expanding cases and run PrepSCTFindMarkers when necessary before calling meta-markers fix(scrna.MarkersFinder): fix fetching command when composing the PrepSCTFindMarkers command fix(scrna_metabolic_landscape): handle null values in for loop in MetabolicFeatures and MetabolicFeaturesIntraSubset for report generation deps: bump biopipen to 0.30.0 BREAKING(scrna): move clustree plots from SeuratClustering/SeuratSubClustering to SeuratClusterStats feat(scrna.CellTypeAnnotation): allow to merge/not to merge (envs.merge) the clusters with the same labels predicted feat(scrna.SeuratPreparing): add scDblFinder to detect doublets feat(scrna.SeuratMap2Ref): add envs.skip_if_normalized option to skip normalization if query is already normalized using the same - method as the reference refactor(tcr.Immunarch): source the files for Immunarch scripts for better debugging refactor(scnra.SeuratClustering): refactor the script for better debugging refactor(scnra.SeuratPreparing): refactor the script for better debugging fix(scrna): fix resolution expansion for SeuratClustering and SeuratSubClustering fix(scrna): Fix generating PrepSCTFindMarkers command when no previous commands present tests(scrna.ScFGSEA): fix unavailable urls to GMT files chore(scrna.SeuratMap2Ref): optimize memory usage chore(scrna.MetaMarkers): remove plugin_opts.poplog_max chore(tcr.CloneResidency): improve logging when handling subjects deps: bump biopipen to 0.31.3 enh(scrna.SeuratMap2Ref): check if reference has SCTModel if SCTransform'ed (likely prepared by old Seurat) fix(tcr.CDR3AAPhyschem): use sequence from TRB chain only fix(tcr.CDR3AAPhyschem): fix when chain is not available fix(tcr.TCRClustering): fix for multi-chain TCRs, use TRB only if on_multi is false fix(tcr.TCRClustering): fix when chain is not available 1.3.9 \u00b6 docs: update docs for TCellSelection to avoid confusion deps: bump biopipen to 0.27.9 feat(tcr.TCRClusterStats): add sample_order to set sample order on heatmap and cluster_rows to switch row clustering on/off 1.3.8 \u00b6 docs: remove -w option for apptainer/singularity as no writing is necessary since pipen-board 0.15.1 deps: update biopipen to version 0.27.8 fix(scrna.SeuratClusterStats): fix selected columns not unique for stats feat(scrna.SeuratMap2Ref): allow non-SCTransform'ed reference feat(scrna.SeuratMap2Ref): allow splitting query object for mapping (pwwang/immunopipe#61) deps: update pipen-board to version 0.15.1 (allow configuration file path in the URL box on Web UI) 1.3.7 \u00b6 ci: fix docker images building when no essential changes made 1.3.6 \u00b6 ci: fix deploy workflow (#59) ci: add README.md to tests-output branch ci: fix test/test workflow tests: add make test tests: init test data preparation tests: add test for ImmunarchLoading tests: add tests for SeuratPreparing tests: Update configs for SeuratPreparing test to subset cells so tests can run on CI tests: update SeuratPreparing test to disable export tests: add tests for SeuratClusteringOfAllCells/SeuratClustering docs: update installation instructions (@ stein.mariam@mayo.edu ) deps: bump biopipen to version 0.27.7 (0.27.5-0.27.7) fix(scrna.SeuratClusterStats): fix color palette for ridge plots (@ stein.mariam@mayo.edu ) feat(scrna.SeuratPreparing): add envs.cell_qc_per_sample to filter cells before merging instead after fix(scrna_metabolic_landscape.MetabolicFeatures): fix return value of groups with less than 5 cells in do_one_group fix(scrna_metabolic_landscape): fix mutaters not working. fix(scrna_metabolic_landscape.MetabolicFeatures/MetabolicFeaturesIntraSubset): skip groups with less than 5 cells in do_one_group and save a warning file under the case chore: fix typo in class name ExprImpution to ExprImputation 1.3.5 \u00b6 ci/test: add tests in CI and deploy output in a different branch deps: bump biopipen to 0.27.4 choir(delim.SampleInfo): add alpha to the colors of the plots using biopipen color pallete docs(tcr/scrna/scrna_metabolic_landscape): update links of images in docs 1.3.4-post \u00b6 ci/test: init ci for tests docs: introduce versioning for docs 1.3.4 \u00b6 deps: bump biopipen to 0.27.3 deps: bump pipen-poplog to 0.1.2 (quick fix for populating logs when job fails) deps: temporary fix copier breaks with pyyaml-include v2 (copier-org/copier#1568) choir(scrna.ScFGSEA): Skip cases when no cells found (#50) choir(scrna.MarkersFinder): Skip cases when no cells found (#50) choir(scrna.MetaMarkers): Skip cases when no cells found (#50) feat(scrna.SeuratPreparing): support DoubletFinder (#52) 1.3.3 \u00b6 deps: temporary fix copier breaks with pyyaml-include v2 (copier-org/copier#1568) docs: update FAQ.md with instructions for running pipeline on a cluster deps: bump biopipen to 0.27.2 fix(scrna.RadarPlots): fix mutaters not working feat(tcr.CloneResidency): support envs.upset_ymax to set the max value of y axis in upset bar plot. 1.3.2 \u00b6 deps: bump pipen to 0.14.5 deps: add r-complexupset package to environment.yml and environment_full.yml for CloneResidency deps: pin tensorflow to 2.15 for TESSA deps: bump biopipen to 0.27.1 depr(scrna.MarkersFinder): remove envs.use_presto as it's used by Seurat v5 by default enh(tcr.CloneResidency): support log scale for y axis of upset bar plots enh(scrna.SeuratClusterStats): allow to rotate labels in circos plot (pwwang/immunopipe#48) @ li.ying@mayo.edu enh(scrna.SeuratClusterStats): use pal_biopipen for ident colors in circos plot fix(scrna.CellsDistribution): fix the row order of the heatmaps fix(scrna.SeuratClusterStats): fix when envs.split-by is specified feat(scrna.CellsDistribution): support envs.prefix_each feat(scrna.MarkersFinder): allow to set max number of genes to plot in dotplots feat(scrna.MarkersFinder): support setting detailed arguments for overlapping plots feat(scrna.MarkersFinder): support envs.prefix_group feat(scrna.ScFGSEA): support envs.prefix_each feat(scrna.RadarPlots): support envs.prefix_each and envs.subset choir(scrna.SeuratClusterStats): use logger instead of print for log messages choir(tcr.TCRClustering): print session info for clustcr script choir(scrna.MarkersFinder): flatten toc when no section and no ident-1 specified docs: add more detailed docs for envs.section for multiple processes BREAKING(scrna.SeuratMap2Ref): rename envs.name to envs.ident so envs.MapQuery.refdata is not - required anymore. It will be inferred from envs.ident and envs.use. @ li.ying@mayo.edu 1.3.1 \u00b6 deps: bump pipen to 0.14.3 deps: pin ggplot2 to 3.4 for docker due to breaking changes of 3.5 deps: bump biopipen to 0.26.2 deps: bump datar-pandas to 0.5.5 to dismiss deprecated warnings fix(utils.misc.R): replace latin and greek characters with closest ascii chars for slugify() feat(scrna.TopExpressingGenes): support subset fix(scrna.CellsDistribution): fix the row order of the heatmaps. enh(tcr.CloneResidency): add legend for multiplets in upset plots. feat(scrna.SeuratClusterStats): add circos plot for cell composition stats (#46). 1.3.0 \u00b6 deps: bump pipen to 0.14.1 deps: bump pipen-report to 0.18.2 deps: bump biopipen to 0.26.0 fix(scrna.CellTypeAnnotation): keep factor meta data when input and output are RDS for celltypist deps: bump datar to 0.15.4 (support pandas 2.2) fix(utils.single_cell.R): fix immdata_from_expanded missing other data columns fix(tcr.Immunarch): fix mutaters not working when no subset is set fix(scrna.CellsDistribution): fix hm_devpars not working fix(scrna.CellsDistribution): fix multiple cells_by columns and speed up plotting choir(tcr.CloneResidency): mark singletons in Venn diagrams more clear fix(scrna.RadarPlots): fix the order of groups on radar plots choir(scrna.RadarPlots): transpose the count/percentage table to save to files fix(scrna.MarkersFinder): fix generating report json file when no significant genes found choir(scrna.MarkersFinder): Plot maximum 20 genes in dotplots choir(scrna.MarkersFinder): Do not convert dashes in case names to dots see more at https://github.com/pwwang/biopipen/releases/tag/0.26.0 1.2.0 \u00b6 docs: update FAQs to align with Seurat v5 docs: add image from manuscript to README.md docs: center the flowchart image in README.md docs: mention celltypist model prep in preparing input data deps: bump pipen to 0.13.2 deps: bump biopipen to 0.25.2: scrna.MarkersFinder: allow to cache FindAllMarkers results scrna.CellTypeAnnotation: support celltypist (pwwang/biopipen#111) scrna.SeuratSubClustering: add envs_depth = 1 to replace whole envs.cases when new case assigned scrna_metabolic_landscape.MetabolicPathwayHeterogeneit): fix output directory path is not slugified tcr.Immunarch: change case filling log to debug level 1.1.1 \u00b6 deps: Bump biopipen to 0.24.2 chore: use internal slugify instead of slugify library tcr.Immunarch: fix spectratyping output file extension is not png scrna.SeuratPreparing: fix displaying filters in report scrna.SeuratPreparing: fix logging Seurat procedure arguments 1.1.0 \u00b6 docs: update table in gallery deps: use pipen-poplog to populate job logs to pipeline running log deps: bump biopipen to 0.24. Hights: scrna.ScFGSEA: add subset to filter cells (pwwang/biopipen#112) @yuey11 scrna.SeuratClustering/SeuratSubClustering: cache Seurat procedures step by step (#40) @xyfqwlzoe tcr.Immunarch: add plot_type to support boxplots for diversity metrics see more at https://github.com/pwwang/biopipen/releases/tag/0.24.0 1.0.5 \u00b6 change: do not rescale gene expression in TCellSelection any more fix: fix column names of indicators not aligned with indicator_genes feat: add feature plots in TCellSelection deps: bump biopipen to 0.23.8 scrna.SeuratPreparing: log Seurat procedure arguments scrna.ScFGSEA: add subset to filter cells (pwwang/biopipen#112) 1.0.4 \u00b6 deps: bump biopipen to 0.23.7 scrna.SeuratPreparing: update log message for transformation/scaling step scrna_metabolic_landscape.MetabolicPathwayHeterogeneity: add utils.gsea script source to support localizeGmtfile 1.0.3 \u00b6 deps: add r-seuratdisk dependency to conda env files. @yuey11 deps: pin r-matrixstats to 1.1.0 in conda env files to fix useNames = NA error. @yuey11 refactor: optimize configuration file validation deps: bump biopipen to 0.23.6 feat: support url for gmtfile wherever GSEA is performed (pwwang/biopipen#113) tcr.Immunarch: add error message for empty filtered/subset data in diversity scrna.SeuratPreparing: correct description of default assay in docstr scrna.SeuratPreparing: run also the normal normalization procedures when SCTransform is used (useful for visualization purposes on RNA assay) scrna.ModuleScoreCalculator: document the names added by cell cycle score (#34) scrna.SeuratPreparing: support sample names as reference for IntegrateLayers 1.0.2 \u00b6 deps: add bioconductor-glmgampoi to conda env files (#33) docs: correct the Seurat object assay description deps: bump biopipen to 0.23.5 fix: fix when no enriched items found for scrna.MarkersFinder , scrna.MetaMarkers and scrna.TopExpressingGenes scrna.SeuratClusterStats: fix when frac or frac_ofall is true and no group-by nor split-by is specified for stats utils.gsea.R: fix when no enriched items found for runEnrichr scrna_metabolic_landscript: fix adding report when ncores > 1 1.0.1 \u00b6 docs: add gallery section to README.md change: set default nstart of kmeans to 25 in TCellSelection deps: add r-hdf5r in conda env files to support Read_10x_h5 from Seurat. @yuey11 deps: bump biopipen to 0.23.4 scrna.TopExpressingGenes: fix colnames while pulling average expression scrna.CellsDistribution: fix when cells_by has multiple column names scrna.CellTypeAnnotation: fix the order of the clusters for direct method scrna.SeuratClusterStats: add position options for bar plots for stats scrna.RadarPlots: add colors to set the colors of the loops in radar and bar plots tcr.Immunarch: add split_by and split_order to put subplots together in one single plots 1.0.0 \u00b6 Highlights \u00b6 feat: support Seurat v5 (integration is now down by Seurat::IntegrateLayers ) feat: support supervised clustering (mapping cells to reference by Seurat ) feat: support dataset with scRNA-seq data only (no scTCR-seq data) feat: support diffusion map calculation (by ModuleScoreCalculator ) feat: support subclassing to cluster subsets of cells (by SeuratSubClustering ) feat: allow to ignore TCR data in TCellSelection and pass kmeans arguments feat: allow to set multiple resolutions ( envs.FindClusters.resolution ) in SeuratClustering / SeuratClusteringOfTCells change: change unsuperved cluster labels to c1 , c2 , ... in SeuratClustering by default docs: add gallery, which contains real-world examples of datasets from publications Breaking changes \u00b6 change: rename SeuratMetadataMutater to IntegratingTCR change: rename SeuratClusteringOfTCells to SeuratClustering change: rename TCRClusters2Seurat to IntegratingTCRClusters refactor: make SeuratClustering (instead of SeuratClusteringOfAllCells ) work for all cells when all are T cells change: move data preparation and integration from SeuratClustering to SeuratPreparing change: default mode of ImmunarchLoading to paired (instead of single ), which requires both alpha and beta chains (instead of beta chain only) to define a clonotype change: default dbs for enrichment analysis wherever applies to KEGG_2021_Human and MSigDB_Hallmark_2020 Changes \u00b6 feat: make TopExpressingGenes optional feat: add validate_config to validate configuration schematically Features \u00b6 feat(SeuratPreparing): allow to filter genes directly (by specifying envs.gene_qc.excludes ) feat(SeuratClusterStats): add ngenes to plot the number of genes expressed in each cluster feat(SeuratClusterStats): add barplot for features and allow aggregation of features feat(SeuratClusterStats): add envs.mutaters to mutate meta data feat(SeuratClusterStats): add histograms to plot number of cells against another variable feat(SeuratClusterStats): Add frac_ofall and transpose for stats to calculate fraction within group or against all cells, and transpose ident and group, respectively Dependencies \u00b6 deps: add r-presto to conda environment files to support using presto to fastly find markers deps: add bioconductor-destiny to conda environment file to support add diffusion map components in ModuleScoreCalculator deps: add r-harmony to support harmony integration by Seurat v5 in conda env file deps: add r-sf to conda env file deps: remove vdjtools from conda env files deps: bump pipen-report to 0.16.3 deps: bump biopipen to 0.23.3 . Hightlight changes: scrna.MarkersFinder: Add envs.use_presto to use presto to speed up finding markers scrna.SeuratPreparing: Set envs.gene_qc.min_cells to 0 by default (instead of 3) scrna.ScFGSEA: Allow to ignore small group when fgsea fails due to all NAs for pre-ranks scrna.CellsDistribution: Allow to order clusters by envs.cluster_orderby scrna.CellsDistribution: Add heatmaps tcr.CloneResidency: Make section works in report tcr.Immunarch: Support paired chain data for VJ conjuction plots tcr.TESSA: Change envs.assay to None to use default assay of Seurat object scrna.SeuratClusterStats: Add avgheatmap to plot more elegant heatmap for average gene expressions scrna.SeuratClusterStats: Fix ident not working for dimplots scrna.SeuratClusterStats: Add cluster_orderby to order clusters for features scrna.SeuratClusterStats: Add na_group to keep NA values in group-by utils.mutate_helpers: Change arguments id_col and compare_col of paired to id and compare , respectively utils.mutate_helpers: Fix that subset can't be an expression for expanded family utils.mutate_helpers: Add top to select top entities (e.g clones) scrna.RadarPlots: Add breakdown and test to break down the cell distribution and run statistic test on the fractions 0.11.2 \u00b6 docs: move Immunarch to the later position in process list docs: Use master tag in getting-started 0.11.1 \u00b6 chore: change line length to 88 for flake8 chore: dismissing warning about wasting columns for SeuratClusteringOfTCells docs: update CHANGELOG.md with missing changes of last version docs: add version of renaming envs.tcell_indicator to envs.tcell_selector docs: remove unused doc files docs: add metadata illustration deps: bump biopipen to 0.22.8. Highlights: deps: bump pipen-board to 0.13.10 (pipen-report to 0.16.2) CellsDistribution: Don't add rownames to the output table file MarkersFinder (ClusterMarkers/ClusterMarkersOfAllCells): Optimize to use FindAllMarkers if ident.1 is not specified SeuratClusterStats: Fix path of expression table file CellTypeAnnotation: Allow using NA to exclude clusters from output Seurat object utils.mutate_helpers: Return ids only when subset is true and group is not NA for uniq = TRUE in expanded , collapsed , emerged and vanished 0.11.0 \u00b6 deps: update biopipen to 0.22.1, highlights: add V-J junction circos plots to Immunarch process add cache option to cache the clustering results if nothing changed except ncores, to SeuratClustering process add dot plots to MarkersFinder ( ClusterMarkersOfAllCells , ClusterMarkers ) process save exported table with only necessary columns for CellsDistribution process add descr to describe cases cases in report for CellsDistribution process add subset for dimplots in SeuratClusterStats process use a new palette ( biopipen ) for related processes optimize report rendering (using render_job() filter from pipen-report ) change metacols to extracols so essential columns get exported for ImmunarchLoading process add cache option to cache the clustering results if nothing changed except ncores for SeuratClustering ( SeuratClusteringOfAllCells ) process see more at https://github.com/pwwang/biopipen/releases/tag/0.22.0 and https://github.com/pwwang/biopipen/releases/tag/0.22.1 deps: update pipen-report to 0.16, highlights: scroll anchor into view on the page build report page when each process is done, instead of the whole pipeline see more at https://github.com/pwwang/pipen-report/releases/tag/0.16.0 change: remove Immunarch2VDJtools and VJUsage processes (vj usage analysis can be done in Immunarch process) change: change tcell_indicator to tcell_selector in TCellSelection process enhance: provide better error message when none barcode matches from RNA and TCR data for TCRClustering process docs: add memory usage reduction tips in FAQ chore: dismiss warnings of wasted input columns for multiple processes 0.10.1 \u00b6 chore: update pipeline description to include version in the logs fix: add fc-cache command to Dockerfile to solve Fontconfig error docker: optimize building full image based off the base image 0.10.0 \u00b6 docker: lock r-matrix version to 1.6_1 for compatibility docs: adopt mkdocs-rtd 0.0.10 (add scrollbar to the table of contents) deps: bump biopipen to 0.21.1 use r-logger for logging in R scripts docs: fix internal references in API docs deps: bump pipen-board to 0.13.6 SampleInfo: refactor data subset logic using subset instead of distinct Immunarch: add in.metafile to allow other meta info (i.e. seurat clusters) for future subsetting (#22) Immunarch: fix empty groups in diversity plot after subsetting Immunarch: allow subset to subset cells for analyses Immunarch: allow separate_by also works on other diversity plots Immunarch: add ymin and ymax to align diversity plots by separate_by Immunarch: add ncol to specify # columns in the combined plots RadarPlots: fix envs.order not working MarkersFinder: add overlap to find overlapping markers between cases (#24) MarkersFinder: allow subset to subset cells for analyses MarkersFinder: add dot plots for significant markers CellsDistribution: allow multiple columns for cells_by CellsDistribution: allow subset to subset cells for analyses utils.mutate_helpers.R: add include_emerged for expanded() and include_vanished for collapsed() 0.9.3 \u00b6 deps: Bump biopipen to 0.20.7 deps: Bump pipen-board to 0.13.4 ClusterMarkers/ClusterMarkersOfAllCells: Choose avg_log2FC > 0 markers by default MarkersFinder: Allow to set assay and set assay to RNA by default CellsDistribution: Add venn/upset plot for overlapping cell groups in different cases SampleInfo: Add distinct to case to perform stats on distinct records 0.9.2 \u00b6 \u2795 Add r-ggnewscale as dependency for CDR3AAPhyschem in docker image \u2b06\ufe0f Bump biopipen to 0.20.5 \ud83e\uddf1 CloneResidency: Integrate RNA data to allow more flexible analysis (i.e. within specific seurat clusters) \ud83c\udfd7\ufe0f CloneResidency: Rename envs.sample_groups to envs.section to be consistent with other processes \ud83d\udcdd ScFGSEA: Remove the link in the summary of the docstring (since they are not transformed in the report) \ud83c\udfa8 CDR3AAPhyschem: Give better error message when wrong group items are given \u2b06\ufe0f Bump pipen-board to 0.13.3 Add items automatically when blurred for list options Add other sections to description on the UI for processes 0.9.1 \u00b6 \ud83d\udc1b Fix docstring for RadarPlots \u2795 Add pipen-diagram as dependency \u2795 Set pipen-runinfo as optional \u2b06\ufe0f Bump biopipen to 0.20.4 \ud83d\udcdd Update version in docs 0.9.0 \u00b6 Housekeeping and docs \u00b6 Bump biopipen to 0.20.3 (pipen to 0.12) Use pipen-cli-ref to generate API for processes (it uses docstring of the process class so that we don't need to maintain two copies of docs) Fixed/Enhanced \u00b6 Make /data directory in container, so it can be mounted Fix a bug when a single gene provided to indicator_genes in TCellSelection Move ModuleScoreCalculator before clustering so that the scores can be used in vars.to.regress of SCTransform while clustering Set default assay to RNA in case module scores only caculated using integrated features in ModuleScoreCalculator Improve QC plots in SeuratPreparing by marking the cells that are removed in the plots instead of doing before/after plots Fix type annotation for envs.features_defaults.ncol in docstring for SeuratPreparing (causing pipen-board not converting to int) Fix the cluster order in pie charts for CellsDistribution Fix the cluster order in pie charts for SeuratClusterStats Fix order in pie charts for SampleInfo Fix docstring for envs.div.args of Immunarch (more clear description of method) Allow mutiple columns in the file for envs.features_defaults.features in SeuratClusterStats Allow order to be optional for CloneResidency (errored when not provided) Add number of clusters at the end of log for SeuratClusteringOfAllCells / SeuratClusteringOfTCells Add stricter checker for input file (#13) Indicate the case name in logs when pie is enabled for group-by in SeuratClusterStats Allow to skip overlap and gene usage analyses by setting method to none for Immunoarch (#11, #12) Don't cluster on heatmap when there are only 2 samples for TCRClusterStats (#11) Import Seurat explictly to avoid satijalab/seurat#2853 in MetabolicFeatures Fix when NA values in data for heatmap in MetabolicPathwayActivity Fix error when no significant pathways selected in MetabolicPathwayHeterogeneity Give better error message in CellsDistribution if group value not found for CellsDistribution (#16) Try including more genes (even though insignificant) in volcano plot for MarkersFinder / ClusterMarkers / ClusterMarkersOfAllCells (#17) Add margins to volcano plot for MarkersFinder / ClusterMarkers / ClusterMarkersOfAllCells Fix when envs.cell_qc is None (not provided) for SeuratPreparing Fix ident in cases of envs.dimplots not working for SeuratClusterStats Added \u00b6 Add ClusterMarkersOfAllCells and TopExpressingGenesOfAllCells and set them as optional Add dim plots in SeuratClusterStats to overlay TCR presence/absence of cells (#14) Breaking changes \u00b6 Rename TCRClusteringStats to TCRClusterStats (#15) 0.8.3 \u00b6 \ud83d\udcdd Fix typos in docs \ud83d\udcdd Add links to some optional input files (#9, 5) \ud83d\udd28 Add apptainer to docker entry.sh (#9, 6) \ud83d\udc84 Adjust process order in reports (#9, 1) \u2b06\ufe0f Bump pipen-report to 0.13.1 (#9, 2) 0.8.2 \u00b6 Bump biopipen to 0.18.3 to fix when either ident is empty for MarkersFinder 0.8.1 \u00b6 Bump biopipen to 0.18.2 to fix a bug when the min length of CDR3 seqs > 12 for CDR3AAphyschem 0.8.0 \u00b6 Housekeeping and docs updates \u00b6 Bump biopipen to 0.18.1 Mention function changes with versions in docs Add apptainer in board.toml so the command can be generated in pipen-board Make logo shorter in docs Add docker image with -full tags to include all dependencies Print command help message if run test failed in CI Add singularity/apptainer in FAQ for \"no space left\" question Add -w fro apptainer in docs (as we need to save pipen-board file in home directory) Added \u00b6 Add TESSA process for tessa analysis Add volcano plot for MarkersFinder and ClusterMarkers Fixed \u00b6 Fix when Sample is the only column in meta for ImmunarchLoading Add clear message when k.weight is too large for IntegrateData in SeuratClustering Allow unique: prefix for on in SampleInfo Fix sample order in plots for SampleInfo Remove tidyseurat:: prefix for filter in scripts of MetaMarkers , ScFGSEA and SeuratClusterStats in case tidyseurat::filter is not exported when installed from conda (but it will make dplyr::filter work anyway on seurat object) Breaking changes \u00b6 Redesign envs for SeuratClusteringStats to allow setting defaults for cases and switch identities for plots 0.7.0 \u00b6 Housekeeping and docs updates \u00b6 Fix typos in docs/configurations TCRClustering should be TCRClusteringStats in Multi-case variable design section infile of [SampleInfo.in] should be samples.txt rather than sample.txt Remove unused scripts by deprecated processes Bump pipen-report to 0.12.8 Add master branch and master tag as stable tag for docker image Add pdf version of the flowchart (#4) Add warning for the results in getting started tutorial Bump pipen-board to 0.11.5 Add apptainer to the docs Added \u00b6 Add ModuleScoreCalculator to calculate module scores or cell cycle scores See: https://pwwang.github.io/immunopipe/processes/ModuleScoreCalculator/ Allow SampleInfo to perform statistics on the sample information See: https://pwwang.github.io/immunopipe/processes/SampleInfo/ Add TCR_Cluster_Size and TCR_Cluster_Size1 from TCRClustering to metadata for further integrative analysis See: https://pwwang.github.io/immunopipe/processes/TCRClusters2Seurat/ Fixed \u00b6 Fix default height and width for plots in SeuratClusterStats Fix cluster order not kept after annotation using hitype in CellTypeAnnotation Breaking changes \u00b6 Change seurat_clusters_old to seurat_clusters_id to save old seurat_clusters in CellTypeAnnotation Remove MarkersForClustersOfAllCells and TopExpressingGenesOfAllCells processes Rename MarkersForClustersOfTCells to ClusterMarkers Rename TopExpressingGenesOfTCells to TopExpressingGenes Rename envs.exprs to envs.features for SeuratClusterStats envs.exprs.genes is also renamed to envs.features.features 0.6.0 \u00b6 \u2b06\ufe0f Bump biopipen to 0.16 \ud83d\udcdd Add documentation \ud83d\udc9a Fix docs building in CI \ud83d\udcdd Update README with flowchart 0.5.1 \u00b6 \u2728 Add TopExpressingGenes \ud83c\udfa8 Move RadarPlots to biopipen \u2b06\ufe0f Bump biopipen to 0.15.2 0.5.0 \u00b6 \u2b06\ufe0f Upgrade biopipen to 0.15.0 \ud83d\udc9a Use better strategy docker image building 0.4.0 \u00b6 \u2b06\ufe0f Bump biopipen to 0.6 \u2b06\ufe0f Upgrade other dependencies \ud83d\udc9a Use micromamba for docker image building \u2b06\ufe0f Add procps-ng for vdjtools for docker building 0.3.0 \u00b6 \ud83d\udc9a Use build 2 for genomeinfodbdata from bioconda (0.2.4) \ud83d\udc7d\ufe0f Use config from pipen_args \u2b06\ufe0f Pump biopipen to 0.5.3, pipen-args to 0.3.2 \u2b06\ufe0f Upgrade deps for docker \ud83d\udcdd Add flowchart in README.md \ud83d\udc1b Fix error when --config not passed 0.2.4 \u00b6 \ud83d\udc9a Use lastest miniconda3 for docker build \ud83d\udc9a Use conda channel pwwang for bioconductor-genomeinfodbdata for fix (bioconda/bioconda-recipes#31349) \u2b06\ufe0f Upgrade biopipen to 0.4.9 \ud83d\udcdd Add URL to example in README 0.2.3 \u00b6 \u2b06\ufe0f Upgrade biopipen to 0.4.8 0.2.2 \u00b6 \u2b06\ufe0f Upgrade biopipen to 0.4.7 to fix SeuratPreparing 0.2.1 \u00b6 \ud83d\udd25 Fix the bug of the wrong arguments in help page \u2b06\ufe0f Upgrade clustcr to 1.0.2 \ud83d\udcdd Fix docs for metabolic analysis 0.2.0 \u00b6 \u267b\ufe0f Move in-house processes out of processes.py \u267b\ufe0f Split up MARKERS_FINDER \u267b\ufe0f Refactor RadarPlots \u2728 Add an example config file \u26a1\ufe0f Add filter for RadarPlots \ud83d\udcdd Update docs \u2b06\ufe0f Upgrade deps \ud83d\udd27 Update docker/environment.yml \ud83d\udc1b Fix CloneHeterogeneity when only 1 row in continency table 0.1.1 \u00b6 \ud83d\udc9a Try fix pip in environment.yml \ud83d\udcdd Update readme for requirement checking \ud83d\udcdd Update docs to fix #1 \ud83d\udcdd Update CHANGELOG \u2b06\ufe0f Adopt biopipen 0.4.0 0.1.0 \u00b6 \ud83e\ude79 Disable force-caching for some procs \u2b06\ufe0f Upgrade datar to 0.8.* \u2728 Add dockerfile \u2b06\ufe0f Upgrade pipen to 0.3 \ud83d\udca5 Remove gene lists from start processes \u2b06\ufe0f Upgrade biopipen to 0.3 \u2b06\ufe0f Upgrade pipen to 0.3.5 0.0.7 \u00b6 Add CloneHeterogeneity Allow setting indicator_gene for TCellSelection Adopt latest datar and biopipen 0.0.6 \u00b6 \u2728 Allow dimplots with clonal information 0.0.5 \u00b6 \u2728 Allow more flexible dim plots 0.0.4 \u00b6 \u2728 Refactor markers finder module and add meta-marker analysis 0.0.3 \u00b6 -\u2728 Add metabolic pathway analysis 0.0.2 \u00b6 Adopt biopipen 0.1.3 0.0.1 \u00b6 First release","title":"Change log"},{"location":"CHANGELOG/#change-log","text":"","title":"Change Log"},{"location":"CHANGELOG/#143","text":"deps: update pipen-runinfo dependency to version 0.8.0 (pipen to 0.15.2) deps: update biopipen dependency to version 0.31.4 fix(scrna.SeuratMap2Ref): fix refnorm not detected for NormlizeData'ed reference","title":"1.4.3"},{"location":"CHANGELOG/#142","text":"deps: add bioconductor-destiny dependency in docker environment files for ModuleScoreCalculator","title":"1.4.2"},{"location":"CHANGELOG/#141","text":"docs: update tutorial dataset information and links","title":"1.4.1"},{"location":"CHANGELOG/#140","text":"docs: update Singularity and Apptainer commands to include --writable-tmpfs flag docs: allow collapsing ns/choice items in the docs for processes docker: update Dockerfile to include npm cache configuration to allow the pipeline to run on read-only file system tests: update SeuratPreparing config to use DoubletFinder for doublet detection ci: use latest actions deps: add r-clustree as a dependency in docker environment files deps: update dependencies in docker environment files (python3.10, R4.3) deps: bump biopipen to 0.29.0 fix(tcr.TCRClusterStats): fix envs.shared_clusters.heatmap_meta being broken by envs.shared_clusters.sample_order (@ li.ying@mayo.edu ) choir(scrna.SeuratMap2Ref): present better error message when envs.use or values of envs.MapQuery.refdata not in reference (@ li.ying@mayo.edu ) fix(scrna.MarkersFinder): run PrepSCTFindMarkers when needed choir(scrna.SeuratClustering): use FindClusters to run for multiple resolutions choir(scrna.SeuratSubClustering): use FindClusters to run for multiple resolutions feat(scrna.SeuratClustering): add clustree plot (@ li.ying@mayo.edu ) feat(scrna.SeuratSubClustering): add clustree plot tests(scrna.SeuratClusterStats): add assertion for clustree plot generation deps: bump biopipen to 0.29.1 fix(delim.SampleInfo): fix numbers not split up when each is specified. enh(delim.SampleInfo): make sizes of pie charts proportional to number of samples when each is specified enh(scrna.MarkersFinder): run PrepSCTFindMarkers when necessary before calling FindMarkers feat(scrna.SeuratPreparing): add option to cache Seurat object at different steps feat(scrna.SeuratPreparing): allow doubletfinder to run with a different number of cores chore(scrna.SeuratClustering): record PrepSCTFindMarkers command in sobj@commands tests(scrna.SeuratClusterStats): use less stringent p-value cutoff for DEG/MarkersFinder tests(scrna.SeuratPreparing): add doubletfinder in tests deps: bump biopipen to 0.29.2 chore(scrna.SeuratClusterStats): use ident label length to adjust default height for feature plots fix(scrna.MetaMarkers): fix seurat object not updated when expanding cases and run PrepSCTFindMarkers when necessary before calling meta-markers fix(scrna.MarkersFinder): fix fetching command when composing the PrepSCTFindMarkers command fix(scrna_metabolic_landscape): handle null values in for loop in MetabolicFeatures and MetabolicFeaturesIntraSubset for report generation deps: bump biopipen to 0.30.0 BREAKING(scrna): move clustree plots from SeuratClustering/SeuratSubClustering to SeuratClusterStats feat(scrna.CellTypeAnnotation): allow to merge/not to merge (envs.merge) the clusters with the same labels predicted feat(scrna.SeuratPreparing): add scDblFinder to detect doublets feat(scrna.SeuratMap2Ref): add envs.skip_if_normalized option to skip normalization if query is already normalized using the same - method as the reference refactor(tcr.Immunarch): source the files for Immunarch scripts for better debugging refactor(scnra.SeuratClustering): refactor the script for better debugging refactor(scnra.SeuratPreparing): refactor the script for better debugging fix(scrna): fix resolution expansion for SeuratClustering and SeuratSubClustering fix(scrna): Fix generating PrepSCTFindMarkers command when no previous commands present tests(scrna.ScFGSEA): fix unavailable urls to GMT files chore(scrna.SeuratMap2Ref): optimize memory usage chore(scrna.MetaMarkers): remove plugin_opts.poplog_max chore(tcr.CloneResidency): improve logging when handling subjects deps: bump biopipen to 0.31.3 enh(scrna.SeuratMap2Ref): check if reference has SCTModel if SCTransform'ed (likely prepared by old Seurat) fix(tcr.CDR3AAPhyschem): use sequence from TRB chain only fix(tcr.CDR3AAPhyschem): fix when chain is not available fix(tcr.TCRClustering): fix for multi-chain TCRs, use TRB only if on_multi is false fix(tcr.TCRClustering): fix when chain is not available","title":"1.4.0"},{"location":"CHANGELOG/#139","text":"docs: update docs for TCellSelection to avoid confusion deps: bump biopipen to 0.27.9 feat(tcr.TCRClusterStats): add sample_order to set sample order on heatmap and cluster_rows to switch row clustering on/off","title":"1.3.9"},{"location":"CHANGELOG/#138","text":"docs: remove -w option for apptainer/singularity as no writing is necessary since pipen-board 0.15.1 deps: update biopipen to version 0.27.8 fix(scrna.SeuratClusterStats): fix selected columns not unique for stats feat(scrna.SeuratMap2Ref): allow non-SCTransform'ed reference feat(scrna.SeuratMap2Ref): allow splitting query object for mapping (pwwang/immunopipe#61) deps: update pipen-board to version 0.15.1 (allow configuration file path in the URL box on Web UI)","title":"1.3.8"},{"location":"CHANGELOG/#137","text":"ci: fix docker images building when no essential changes made","title":"1.3.7"},{"location":"CHANGELOG/#136","text":"ci: fix deploy workflow (#59) ci: add README.md to tests-output branch ci: fix test/test workflow tests: add make test tests: init test data preparation tests: add test for ImmunarchLoading tests: add tests for SeuratPreparing tests: Update configs for SeuratPreparing test to subset cells so tests can run on CI tests: update SeuratPreparing test to disable export tests: add tests for SeuratClusteringOfAllCells/SeuratClustering docs: update installation instructions (@ stein.mariam@mayo.edu ) deps: bump biopipen to version 0.27.7 (0.27.5-0.27.7) fix(scrna.SeuratClusterStats): fix color palette for ridge plots (@ stein.mariam@mayo.edu ) feat(scrna.SeuratPreparing): add envs.cell_qc_per_sample to filter cells before merging instead after fix(scrna_metabolic_landscape.MetabolicFeatures): fix return value of groups with less than 5 cells in do_one_group fix(scrna_metabolic_landscape): fix mutaters not working. fix(scrna_metabolic_landscape.MetabolicFeatures/MetabolicFeaturesIntraSubset): skip groups with less than 5 cells in do_one_group and save a warning file under the case chore: fix typo in class name ExprImpution to ExprImputation","title":"1.3.6"},{"location":"CHANGELOG/#135","text":"ci/test: add tests in CI and deploy output in a different branch deps: bump biopipen to 0.27.4 choir(delim.SampleInfo): add alpha to the colors of the plots using biopipen color pallete docs(tcr/scrna/scrna_metabolic_landscape): update links of images in docs","title":"1.3.5"},{"location":"CHANGELOG/#134-post","text":"ci/test: init ci for tests docs: introduce versioning for docs","title":"1.3.4-post"},{"location":"CHANGELOG/#134","text":"deps: bump biopipen to 0.27.3 deps: bump pipen-poplog to 0.1.2 (quick fix for populating logs when job fails) deps: temporary fix copier breaks with pyyaml-include v2 (copier-org/copier#1568) choir(scrna.ScFGSEA): Skip cases when no cells found (#50) choir(scrna.MarkersFinder): Skip cases when no cells found (#50) choir(scrna.MetaMarkers): Skip cases when no cells found (#50) feat(scrna.SeuratPreparing): support DoubletFinder (#52)","title":"1.3.4"},{"location":"CHANGELOG/#133","text":"deps: temporary fix copier breaks with pyyaml-include v2 (copier-org/copier#1568) docs: update FAQ.md with instructions for running pipeline on a cluster deps: bump biopipen to 0.27.2 fix(scrna.RadarPlots): fix mutaters not working feat(tcr.CloneResidency): support envs.upset_ymax to set the max value of y axis in upset bar plot.","title":"1.3.3"},{"location":"CHANGELOG/#132","text":"deps: bump pipen to 0.14.5 deps: add r-complexupset package to environment.yml and environment_full.yml for CloneResidency deps: pin tensorflow to 2.15 for TESSA deps: bump biopipen to 0.27.1 depr(scrna.MarkersFinder): remove envs.use_presto as it's used by Seurat v5 by default enh(tcr.CloneResidency): support log scale for y axis of upset bar plots enh(scrna.SeuratClusterStats): allow to rotate labels in circos plot (pwwang/immunopipe#48) @ li.ying@mayo.edu enh(scrna.SeuratClusterStats): use pal_biopipen for ident colors in circos plot fix(scrna.CellsDistribution): fix the row order of the heatmaps fix(scrna.SeuratClusterStats): fix when envs.split-by is specified feat(scrna.CellsDistribution): support envs.prefix_each feat(scrna.MarkersFinder): allow to set max number of genes to plot in dotplots feat(scrna.MarkersFinder): support setting detailed arguments for overlapping plots feat(scrna.MarkersFinder): support envs.prefix_group feat(scrna.ScFGSEA): support envs.prefix_each feat(scrna.RadarPlots): support envs.prefix_each and envs.subset choir(scrna.SeuratClusterStats): use logger instead of print for log messages choir(tcr.TCRClustering): print session info for clustcr script choir(scrna.MarkersFinder): flatten toc when no section and no ident-1 specified docs: add more detailed docs for envs.section for multiple processes BREAKING(scrna.SeuratMap2Ref): rename envs.name to envs.ident so envs.MapQuery.refdata is not - required anymore. It will be inferred from envs.ident and envs.use. @ li.ying@mayo.edu","title":"1.3.2"},{"location":"CHANGELOG/#131","text":"deps: bump pipen to 0.14.3 deps: pin ggplot2 to 3.4 for docker due to breaking changes of 3.5 deps: bump biopipen to 0.26.2 deps: bump datar-pandas to 0.5.5 to dismiss deprecated warnings fix(utils.misc.R): replace latin and greek characters with closest ascii chars for slugify() feat(scrna.TopExpressingGenes): support subset fix(scrna.CellsDistribution): fix the row order of the heatmaps. enh(tcr.CloneResidency): add legend for multiplets in upset plots. feat(scrna.SeuratClusterStats): add circos plot for cell composition stats (#46).","title":"1.3.1"},{"location":"CHANGELOG/#130","text":"deps: bump pipen to 0.14.1 deps: bump pipen-report to 0.18.2 deps: bump biopipen to 0.26.0 fix(scrna.CellTypeAnnotation): keep factor meta data when input and output are RDS for celltypist deps: bump datar to 0.15.4 (support pandas 2.2) fix(utils.single_cell.R): fix immdata_from_expanded missing other data columns fix(tcr.Immunarch): fix mutaters not working when no subset is set fix(scrna.CellsDistribution): fix hm_devpars not working fix(scrna.CellsDistribution): fix multiple cells_by columns and speed up plotting choir(tcr.CloneResidency): mark singletons in Venn diagrams more clear fix(scrna.RadarPlots): fix the order of groups on radar plots choir(scrna.RadarPlots): transpose the count/percentage table to save to files fix(scrna.MarkersFinder): fix generating report json file when no significant genes found choir(scrna.MarkersFinder): Plot maximum 20 genes in dotplots choir(scrna.MarkersFinder): Do not convert dashes in case names to dots see more at https://github.com/pwwang/biopipen/releases/tag/0.26.0","title":"1.3.0"},{"location":"CHANGELOG/#120","text":"docs: update FAQs to align with Seurat v5 docs: add image from manuscript to README.md docs: center the flowchart image in README.md docs: mention celltypist model prep in preparing input data deps: bump pipen to 0.13.2 deps: bump biopipen to 0.25.2: scrna.MarkersFinder: allow to cache FindAllMarkers results scrna.CellTypeAnnotation: support celltypist (pwwang/biopipen#111) scrna.SeuratSubClustering: add envs_depth = 1 to replace whole envs.cases when new case assigned scrna_metabolic_landscape.MetabolicPathwayHeterogeneit): fix output directory path is not slugified tcr.Immunarch: change case filling log to debug level","title":"1.2.0"},{"location":"CHANGELOG/#111","text":"deps: Bump biopipen to 0.24.2 chore: use internal slugify instead of slugify library tcr.Immunarch: fix spectratyping output file extension is not png scrna.SeuratPreparing: fix displaying filters in report scrna.SeuratPreparing: fix logging Seurat procedure arguments","title":"1.1.1"},{"location":"CHANGELOG/#110","text":"docs: update table in gallery deps: use pipen-poplog to populate job logs to pipeline running log deps: bump biopipen to 0.24. Hights: scrna.ScFGSEA: add subset to filter cells (pwwang/biopipen#112) @yuey11 scrna.SeuratClustering/SeuratSubClustering: cache Seurat procedures step by step (#40) @xyfqwlzoe tcr.Immunarch: add plot_type to support boxplots for diversity metrics see more at https://github.com/pwwang/biopipen/releases/tag/0.24.0","title":"1.1.0"},{"location":"CHANGELOG/#105","text":"change: do not rescale gene expression in TCellSelection any more fix: fix column names of indicators not aligned with indicator_genes feat: add feature plots in TCellSelection deps: bump biopipen to 0.23.8 scrna.SeuratPreparing: log Seurat procedure arguments scrna.ScFGSEA: add subset to filter cells (pwwang/biopipen#112)","title":"1.0.5"},{"location":"CHANGELOG/#104","text":"deps: bump biopipen to 0.23.7 scrna.SeuratPreparing: update log message for transformation/scaling step scrna_metabolic_landscape.MetabolicPathwayHeterogeneity: add utils.gsea script source to support localizeGmtfile","title":"1.0.4"},{"location":"CHANGELOG/#103","text":"deps: add r-seuratdisk dependency to conda env files. @yuey11 deps: pin r-matrixstats to 1.1.0 in conda env files to fix useNames = NA error. @yuey11 refactor: optimize configuration file validation deps: bump biopipen to 0.23.6 feat: support url for gmtfile wherever GSEA is performed (pwwang/biopipen#113) tcr.Immunarch: add error message for empty filtered/subset data in diversity scrna.SeuratPreparing: correct description of default assay in docstr scrna.SeuratPreparing: run also the normal normalization procedures when SCTransform is used (useful for visualization purposes on RNA assay) scrna.ModuleScoreCalculator: document the names added by cell cycle score (#34) scrna.SeuratPreparing: support sample names as reference for IntegrateLayers","title":"1.0.3"},{"location":"CHANGELOG/#102","text":"deps: add bioconductor-glmgampoi to conda env files (#33) docs: correct the Seurat object assay description deps: bump biopipen to 0.23.5 fix: fix when no enriched items found for scrna.MarkersFinder , scrna.MetaMarkers and scrna.TopExpressingGenes scrna.SeuratClusterStats: fix when frac or frac_ofall is true and no group-by nor split-by is specified for stats utils.gsea.R: fix when no enriched items found for runEnrichr scrna_metabolic_landscript: fix adding report when ncores > 1","title":"1.0.2"},{"location":"CHANGELOG/#101","text":"docs: add gallery section to README.md change: set default nstart of kmeans to 25 in TCellSelection deps: add r-hdf5r in conda env files to support Read_10x_h5 from Seurat. @yuey11 deps: bump biopipen to 0.23.4 scrna.TopExpressingGenes: fix colnames while pulling average expression scrna.CellsDistribution: fix when cells_by has multiple column names scrna.CellTypeAnnotation: fix the order of the clusters for direct method scrna.SeuratClusterStats: add position options for bar plots for stats scrna.RadarPlots: add colors to set the colors of the loops in radar and bar plots tcr.Immunarch: add split_by and split_order to put subplots together in one single plots","title":"1.0.1"},{"location":"CHANGELOG/#100","text":"","title":"1.0.0"},{"location":"CHANGELOG/#highlights","text":"feat: support Seurat v5 (integration is now down by Seurat::IntegrateLayers ) feat: support supervised clustering (mapping cells to reference by Seurat ) feat: support dataset with scRNA-seq data only (no scTCR-seq data) feat: support diffusion map calculation (by ModuleScoreCalculator ) feat: support subclassing to cluster subsets of cells (by SeuratSubClustering ) feat: allow to ignore TCR data in TCellSelection and pass kmeans arguments feat: allow to set multiple resolutions ( envs.FindClusters.resolution ) in SeuratClustering / SeuratClusteringOfTCells change: change unsuperved cluster labels to c1 , c2 , ... in SeuratClustering by default docs: add gallery, which contains real-world examples of datasets from publications","title":"Highlights"},{"location":"CHANGELOG/#breaking-changes","text":"change: rename SeuratMetadataMutater to IntegratingTCR change: rename SeuratClusteringOfTCells to SeuratClustering change: rename TCRClusters2Seurat to IntegratingTCRClusters refactor: make SeuratClustering (instead of SeuratClusteringOfAllCells ) work for all cells when all are T cells change: move data preparation and integration from SeuratClustering to SeuratPreparing change: default mode of ImmunarchLoading to paired (instead of single ), which requires both alpha and beta chains (instead of beta chain only) to define a clonotype change: default dbs for enrichment analysis wherever applies to KEGG_2021_Human and MSigDB_Hallmark_2020","title":"Breaking changes"},{"location":"CHANGELOG/#changes","text":"feat: make TopExpressingGenes optional feat: add validate_config to validate configuration schematically","title":"Changes"},{"location":"CHANGELOG/#features","text":"feat(SeuratPreparing): allow to filter genes directly (by specifying envs.gene_qc.excludes ) feat(SeuratClusterStats): add ngenes to plot the number of genes expressed in each cluster feat(SeuratClusterStats): add barplot for features and allow aggregation of features feat(SeuratClusterStats): add envs.mutaters to mutate meta data feat(SeuratClusterStats): add histograms to plot number of cells against another variable feat(SeuratClusterStats): Add frac_ofall and transpose for stats to calculate fraction within group or against all cells, and transpose ident and group, respectively","title":"Features"},{"location":"CHANGELOG/#dependencies","text":"deps: add r-presto to conda environment files to support using presto to fastly find markers deps: add bioconductor-destiny to conda environment file to support add diffusion map components in ModuleScoreCalculator deps: add r-harmony to support harmony integration by Seurat v5 in conda env file deps: add r-sf to conda env file deps: remove vdjtools from conda env files deps: bump pipen-report to 0.16.3 deps: bump biopipen to 0.23.3 . Hightlight changes: scrna.MarkersFinder: Add envs.use_presto to use presto to speed up finding markers scrna.SeuratPreparing: Set envs.gene_qc.min_cells to 0 by default (instead of 3) scrna.ScFGSEA: Allow to ignore small group when fgsea fails due to all NAs for pre-ranks scrna.CellsDistribution: Allow to order clusters by envs.cluster_orderby scrna.CellsDistribution: Add heatmaps tcr.CloneResidency: Make section works in report tcr.Immunarch: Support paired chain data for VJ conjuction plots tcr.TESSA: Change envs.assay to None to use default assay of Seurat object scrna.SeuratClusterStats: Add avgheatmap to plot more elegant heatmap for average gene expressions scrna.SeuratClusterStats: Fix ident not working for dimplots scrna.SeuratClusterStats: Add cluster_orderby to order clusters for features scrna.SeuratClusterStats: Add na_group to keep NA values in group-by utils.mutate_helpers: Change arguments id_col and compare_col of paired to id and compare , respectively utils.mutate_helpers: Fix that subset can't be an expression for expanded family utils.mutate_helpers: Add top to select top entities (e.g clones) scrna.RadarPlots: Add breakdown and test to break down the cell distribution and run statistic test on the fractions","title":"Dependencies"},{"location":"CHANGELOG/#0112","text":"docs: move Immunarch to the later position in process list docs: Use master tag in getting-started","title":"0.11.2"},{"location":"CHANGELOG/#0111","text":"chore: change line length to 88 for flake8 chore: dismissing warning about wasting columns for SeuratClusteringOfTCells docs: update CHANGELOG.md with missing changes of last version docs: add version of renaming envs.tcell_indicator to envs.tcell_selector docs: remove unused doc files docs: add metadata illustration deps: bump biopipen to 0.22.8. Highlights: deps: bump pipen-board to 0.13.10 (pipen-report to 0.16.2) CellsDistribution: Don't add rownames to the output table file MarkersFinder (ClusterMarkers/ClusterMarkersOfAllCells): Optimize to use FindAllMarkers if ident.1 is not specified SeuratClusterStats: Fix path of expression table file CellTypeAnnotation: Allow using NA to exclude clusters from output Seurat object utils.mutate_helpers: Return ids only when subset is true and group is not NA for uniq = TRUE in expanded , collapsed , emerged and vanished","title":"0.11.1"},{"location":"CHANGELOG/#0110","text":"deps: update biopipen to 0.22.1, highlights: add V-J junction circos plots to Immunarch process add cache option to cache the clustering results if nothing changed except ncores, to SeuratClustering process add dot plots to MarkersFinder ( ClusterMarkersOfAllCells , ClusterMarkers ) process save exported table with only necessary columns for CellsDistribution process add descr to describe cases cases in report for CellsDistribution process add subset for dimplots in SeuratClusterStats process use a new palette ( biopipen ) for related processes optimize report rendering (using render_job() filter from pipen-report ) change metacols to extracols so essential columns get exported for ImmunarchLoading process add cache option to cache the clustering results if nothing changed except ncores for SeuratClustering ( SeuratClusteringOfAllCells ) process see more at https://github.com/pwwang/biopipen/releases/tag/0.22.0 and https://github.com/pwwang/biopipen/releases/tag/0.22.1 deps: update pipen-report to 0.16, highlights: scroll anchor into view on the page build report page when each process is done, instead of the whole pipeline see more at https://github.com/pwwang/pipen-report/releases/tag/0.16.0 change: remove Immunarch2VDJtools and VJUsage processes (vj usage analysis can be done in Immunarch process) change: change tcell_indicator to tcell_selector in TCellSelection process enhance: provide better error message when none barcode matches from RNA and TCR data for TCRClustering process docs: add memory usage reduction tips in FAQ chore: dismiss warnings of wasted input columns for multiple processes","title":"0.11.0"},{"location":"CHANGELOG/#0101","text":"chore: update pipeline description to include version in the logs fix: add fc-cache command to Dockerfile to solve Fontconfig error docker: optimize building full image based off the base image","title":"0.10.1"},{"location":"CHANGELOG/#0100","text":"docker: lock r-matrix version to 1.6_1 for compatibility docs: adopt mkdocs-rtd 0.0.10 (add scrollbar to the table of contents) deps: bump biopipen to 0.21.1 use r-logger for logging in R scripts docs: fix internal references in API docs deps: bump pipen-board to 0.13.6 SampleInfo: refactor data subset logic using subset instead of distinct Immunarch: add in.metafile to allow other meta info (i.e. seurat clusters) for future subsetting (#22) Immunarch: fix empty groups in diversity plot after subsetting Immunarch: allow subset to subset cells for analyses Immunarch: allow separate_by also works on other diversity plots Immunarch: add ymin and ymax to align diversity plots by separate_by Immunarch: add ncol to specify # columns in the combined plots RadarPlots: fix envs.order not working MarkersFinder: add overlap to find overlapping markers between cases (#24) MarkersFinder: allow subset to subset cells for analyses MarkersFinder: add dot plots for significant markers CellsDistribution: allow multiple columns for cells_by CellsDistribution: allow subset to subset cells for analyses utils.mutate_helpers.R: add include_emerged for expanded() and include_vanished for collapsed()","title":"0.10.0"},{"location":"CHANGELOG/#093","text":"deps: Bump biopipen to 0.20.7 deps: Bump pipen-board to 0.13.4 ClusterMarkers/ClusterMarkersOfAllCells: Choose avg_log2FC > 0 markers by default MarkersFinder: Allow to set assay and set assay to RNA by default CellsDistribution: Add venn/upset plot for overlapping cell groups in different cases SampleInfo: Add distinct to case to perform stats on distinct records","title":"0.9.3"},{"location":"CHANGELOG/#092","text":"\u2795 Add r-ggnewscale as dependency for CDR3AAPhyschem in docker image \u2b06\ufe0f Bump biopipen to 0.20.5 \ud83e\uddf1 CloneResidency: Integrate RNA data to allow more flexible analysis (i.e. within specific seurat clusters) \ud83c\udfd7\ufe0f CloneResidency: Rename envs.sample_groups to envs.section to be consistent with other processes \ud83d\udcdd ScFGSEA: Remove the link in the summary of the docstring (since they are not transformed in the report) \ud83c\udfa8 CDR3AAPhyschem: Give better error message when wrong group items are given \u2b06\ufe0f Bump pipen-board to 0.13.3 Add items automatically when blurred for list options Add other sections to description on the UI for processes","title":"0.9.2"},{"location":"CHANGELOG/#091","text":"\ud83d\udc1b Fix docstring for RadarPlots \u2795 Add pipen-diagram as dependency \u2795 Set pipen-runinfo as optional \u2b06\ufe0f Bump biopipen to 0.20.4 \ud83d\udcdd Update version in docs","title":"0.9.1"},{"location":"CHANGELOG/#090","text":"","title":"0.9.0"},{"location":"CHANGELOG/#housekeeping-and-docs","text":"Bump biopipen to 0.20.3 (pipen to 0.12) Use pipen-cli-ref to generate API for processes (it uses docstring of the process class so that we don't need to maintain two copies of docs)","title":"Housekeeping and docs"},{"location":"CHANGELOG/#fixedenhanced","text":"Make /data directory in container, so it can be mounted Fix a bug when a single gene provided to indicator_genes in TCellSelection Move ModuleScoreCalculator before clustering so that the scores can be used in vars.to.regress of SCTransform while clustering Set default assay to RNA in case module scores only caculated using integrated features in ModuleScoreCalculator Improve QC plots in SeuratPreparing by marking the cells that are removed in the plots instead of doing before/after plots Fix type annotation for envs.features_defaults.ncol in docstring for SeuratPreparing (causing pipen-board not converting to int) Fix the cluster order in pie charts for CellsDistribution Fix the cluster order in pie charts for SeuratClusterStats Fix order in pie charts for SampleInfo Fix docstring for envs.div.args of Immunarch (more clear description of method) Allow mutiple columns in the file for envs.features_defaults.features in SeuratClusterStats Allow order to be optional for CloneResidency (errored when not provided) Add number of clusters at the end of log for SeuratClusteringOfAllCells / SeuratClusteringOfTCells Add stricter checker for input file (#13) Indicate the case name in logs when pie is enabled for group-by in SeuratClusterStats Allow to skip overlap and gene usage analyses by setting method to none for Immunoarch (#11, #12) Don't cluster on heatmap when there are only 2 samples for TCRClusterStats (#11) Import Seurat explictly to avoid satijalab/seurat#2853 in MetabolicFeatures Fix when NA values in data for heatmap in MetabolicPathwayActivity Fix error when no significant pathways selected in MetabolicPathwayHeterogeneity Give better error message in CellsDistribution if group value not found for CellsDistribution (#16) Try including more genes (even though insignificant) in volcano plot for MarkersFinder / ClusterMarkers / ClusterMarkersOfAllCells (#17) Add margins to volcano plot for MarkersFinder / ClusterMarkers / ClusterMarkersOfAllCells Fix when envs.cell_qc is None (not provided) for SeuratPreparing Fix ident in cases of envs.dimplots not working for SeuratClusterStats","title":"Fixed/Enhanced"},{"location":"CHANGELOG/#added","text":"Add ClusterMarkersOfAllCells and TopExpressingGenesOfAllCells and set them as optional Add dim plots in SeuratClusterStats to overlay TCR presence/absence of cells (#14)","title":"Added"},{"location":"CHANGELOG/#breaking-changes_1","text":"Rename TCRClusteringStats to TCRClusterStats (#15)","title":"Breaking changes"},{"location":"CHANGELOG/#083","text":"\ud83d\udcdd Fix typos in docs \ud83d\udcdd Add links to some optional input files (#9, 5) \ud83d\udd28 Add apptainer to docker entry.sh (#9, 6) \ud83d\udc84 Adjust process order in reports (#9, 1) \u2b06\ufe0f Bump pipen-report to 0.13.1 (#9, 2)","title":"0.8.3"},{"location":"CHANGELOG/#082","text":"Bump biopipen to 0.18.3 to fix when either ident is empty for MarkersFinder","title":"0.8.2"},{"location":"CHANGELOG/#081","text":"Bump biopipen to 0.18.2 to fix a bug when the min length of CDR3 seqs > 12 for CDR3AAphyschem","title":"0.8.1"},{"location":"CHANGELOG/#080","text":"","title":"0.8.0"},{"location":"CHANGELOG/#housekeeping-and-docs-updates","text":"Bump biopipen to 0.18.1 Mention function changes with versions in docs Add apptainer in board.toml so the command can be generated in pipen-board Make logo shorter in docs Add docker image with -full tags to include all dependencies Print command help message if run test failed in CI Add singularity/apptainer in FAQ for \"no space left\" question Add -w fro apptainer in docs (as we need to save pipen-board file in home directory)","title":"Housekeeping and docs updates"},{"location":"CHANGELOG/#added_1","text":"Add TESSA process for tessa analysis Add volcano plot for MarkersFinder and ClusterMarkers","title":"Added"},{"location":"CHANGELOG/#fixed","text":"Fix when Sample is the only column in meta for ImmunarchLoading Add clear message when k.weight is too large for IntegrateData in SeuratClustering Allow unique: prefix for on in SampleInfo Fix sample order in plots for SampleInfo Remove tidyseurat:: prefix for filter in scripts of MetaMarkers , ScFGSEA and SeuratClusterStats in case tidyseurat::filter is not exported when installed from conda (but it will make dplyr::filter work anyway on seurat object)","title":"Fixed"},{"location":"CHANGELOG/#breaking-changes_2","text":"Redesign envs for SeuratClusteringStats to allow setting defaults for cases and switch identities for plots","title":"Breaking changes"},{"location":"CHANGELOG/#070","text":"","title":"0.7.0"},{"location":"CHANGELOG/#housekeeping-and-docs-updates_1","text":"Fix typos in docs/configurations TCRClustering should be TCRClusteringStats in Multi-case variable design section infile of [SampleInfo.in] should be samples.txt rather than sample.txt Remove unused scripts by deprecated processes Bump pipen-report to 0.12.8 Add master branch and master tag as stable tag for docker image Add pdf version of the flowchart (#4) Add warning for the results in getting started tutorial Bump pipen-board to 0.11.5 Add apptainer to the docs","title":"Housekeeping and docs updates"},{"location":"CHANGELOG/#added_2","text":"Add ModuleScoreCalculator to calculate module scores or cell cycle scores See: https://pwwang.github.io/immunopipe/processes/ModuleScoreCalculator/ Allow SampleInfo to perform statistics on the sample information See: https://pwwang.github.io/immunopipe/processes/SampleInfo/ Add TCR_Cluster_Size and TCR_Cluster_Size1 from TCRClustering to metadata for further integrative analysis See: https://pwwang.github.io/immunopipe/processes/TCRClusters2Seurat/","title":"Added"},{"location":"CHANGELOG/#fixed_1","text":"Fix default height and width for plots in SeuratClusterStats Fix cluster order not kept after annotation using hitype in CellTypeAnnotation","title":"Fixed"},{"location":"CHANGELOG/#breaking-changes_3","text":"Change seurat_clusters_old to seurat_clusters_id to save old seurat_clusters in CellTypeAnnotation Remove MarkersForClustersOfAllCells and TopExpressingGenesOfAllCells processes Rename MarkersForClustersOfTCells to ClusterMarkers Rename TopExpressingGenesOfTCells to TopExpressingGenes Rename envs.exprs to envs.features for SeuratClusterStats envs.exprs.genes is also renamed to envs.features.features","title":"Breaking changes"},{"location":"CHANGELOG/#060","text":"\u2b06\ufe0f Bump biopipen to 0.16 \ud83d\udcdd Add documentation \ud83d\udc9a Fix docs building in CI \ud83d\udcdd Update README with flowchart","title":"0.6.0"},{"location":"CHANGELOG/#051","text":"\u2728 Add TopExpressingGenes \ud83c\udfa8 Move RadarPlots to biopipen \u2b06\ufe0f Bump biopipen to 0.15.2","title":"0.5.1"},{"location":"CHANGELOG/#050","text":"\u2b06\ufe0f Upgrade biopipen to 0.15.0 \ud83d\udc9a Use better strategy docker image building","title":"0.5.0"},{"location":"CHANGELOG/#040","text":"\u2b06\ufe0f Bump biopipen to 0.6 \u2b06\ufe0f Upgrade other dependencies \ud83d\udc9a Use micromamba for docker image building \u2b06\ufe0f Add procps-ng for vdjtools for docker building","title":"0.4.0"},{"location":"CHANGELOG/#030","text":"\ud83d\udc9a Use build 2 for genomeinfodbdata from bioconda (0.2.4) \ud83d\udc7d\ufe0f Use config from pipen_args \u2b06\ufe0f Pump biopipen to 0.5.3, pipen-args to 0.3.2 \u2b06\ufe0f Upgrade deps for docker \ud83d\udcdd Add flowchart in README.md \ud83d\udc1b Fix error when --config not passed","title":"0.3.0"},{"location":"CHANGELOG/#024","text":"\ud83d\udc9a Use lastest miniconda3 for docker build \ud83d\udc9a Use conda channel pwwang for bioconductor-genomeinfodbdata for fix (bioconda/bioconda-recipes#31349) \u2b06\ufe0f Upgrade biopipen to 0.4.9 \ud83d\udcdd Add URL to example in README","title":"0.2.4"},{"location":"CHANGELOG/#023","text":"\u2b06\ufe0f Upgrade biopipen to 0.4.8","title":"0.2.3"},{"location":"CHANGELOG/#022","text":"\u2b06\ufe0f Upgrade biopipen to 0.4.7 to fix SeuratPreparing","title":"0.2.2"},{"location":"CHANGELOG/#021","text":"\ud83d\udd25 Fix the bug of the wrong arguments in help page \u2b06\ufe0f Upgrade clustcr to 1.0.2 \ud83d\udcdd Fix docs for metabolic analysis","title":"0.2.1"},{"location":"CHANGELOG/#020","text":"\u267b\ufe0f Move in-house processes out of processes.py \u267b\ufe0f Split up MARKERS_FINDER \u267b\ufe0f Refactor RadarPlots \u2728 Add an example config file \u26a1\ufe0f Add filter for RadarPlots \ud83d\udcdd Update docs \u2b06\ufe0f Upgrade deps \ud83d\udd27 Update docker/environment.yml \ud83d\udc1b Fix CloneHeterogeneity when only 1 row in continency table","title":"0.2.0"},{"location":"CHANGELOG/#011","text":"\ud83d\udc9a Try fix pip in environment.yml \ud83d\udcdd Update readme for requirement checking \ud83d\udcdd Update docs to fix #1 \ud83d\udcdd Update CHANGELOG \u2b06\ufe0f Adopt biopipen 0.4.0","title":"0.1.1"},{"location":"CHANGELOG/#010","text":"\ud83e\ude79 Disable force-caching for some procs \u2b06\ufe0f Upgrade datar to 0.8.* \u2728 Add dockerfile \u2b06\ufe0f Upgrade pipen to 0.3 \ud83d\udca5 Remove gene lists from start processes \u2b06\ufe0f Upgrade biopipen to 0.3 \u2b06\ufe0f Upgrade pipen to 0.3.5","title":"0.1.0"},{"location":"CHANGELOG/#007","text":"Add CloneHeterogeneity Allow setting indicator_gene for TCellSelection Adopt latest datar and biopipen","title":"0.0.7"},{"location":"CHANGELOG/#006","text":"\u2728 Allow dimplots with clonal information","title":"0.0.6"},{"location":"CHANGELOG/#005","text":"\u2728 Allow more flexible dim plots","title":"0.0.5"},{"location":"CHANGELOG/#004","text":"\u2728 Refactor markers finder module and add meta-marker analysis","title":"0.0.4"},{"location":"CHANGELOG/#003","text":"-\u2728 Add metabolic pathway analysis","title":"0.0.3"},{"location":"CHANGELOG/#002","text":"Adopt biopipen 0.1.3","title":"0.0.2"},{"location":"CHANGELOG/#001","text":"First release","title":"0.0.1"},{"location":"configurations/","text":"Configurations \u00b6 In this section, we are discussing how to configure the pipeline itself and some common issues we may encounter or need to be aware of to configure individual processes. For the configurations of each process in details, please refer to the individual process pages. As mentioned in pipen 's docs , the configurations to control the pipeline can be ~/.pipen.toml and/or ./.pipen.toml . You can set the default values in those files. Additionally, you can also pass a configuration file from command line, as described in Running the pipeline section. You can override the default values in the configuration files by passing arguments from command line. The configuration file is in toml format. A schematic example is shown below: forks = 4 # Other pipeline configurations # process configurations [TCellSelection] forks = 2 # override the default value # envs of the process # e.g [TCellSelection.envs] indicator_genes = [ \"CD3D\" , \"CD3E\" , \"CD3G\" ] # other processes # [ProcessName] # ... Tip In the individual process pages, we will list the envs of the process. For example, indicator_genes (list) : The genes to be used to select T cells. This means that the environment variable indicator_genes should be set as follows: [TCellSelection.envs] indicator_genes = [ \"CD3D\" , \"CD3E\" , \"CD3G\" ] Pipeline configurations \u00b6 There are pipeline level configurations and process level configurations. The pipeline level configurations are used to control the pipeline itself. The process level configurations set here are the default values for all the processes. You can override the default values for each process in the process level configurations. You can check all available configuration items and more details here . Here we only list some of the most important ones. The rest ones are not recommended to change unless you know what you are doing. Pipeline level configurations \u00b6 name : The name of the pipeline (Default: \"Immunopipe\" ) It will change the working directory to ./.pipen/<name> , where the pipeline information and intermediate files will be stored. It will also change the default output directory to ./<name>-output . outdir : The output directory (Default: \"./<name>-output\" ) See also Output directory and working directory . loglevel : The logging level for the logger (Default: \"info\" ) plugin_opts : The options for the plugins. Following pipen plugins are installed with immunopipe . You may check the links for more details. pipen-board : Visualizing configuration and running of pipen pipelines on the web. pipen-verbose : Adding verbosal information in logs for pipen. pipen-runinfo : Generating running information for jobs in pipen pipelines. pipen-filters : Adding a set of useful filters for pipen templates. pipen-args : Command line argument parser for pipen pipen-annotate : Using docstring to annotate pipen processes. pipen-report : Generating reports for pipen pipelines. pipen-log2file : Logging to files for pipen pipelines. pipen-cli-run : Running pipen processes/process groups from command line. scheduler : The scheduler to use (Default: \"local\" ) scheduler_opts : The options for the scheduler. immunopipe is implemented using pipen , which is backended by xqute . Supported schedulers and options are listed here . See also How to run the pipeline on a cluster? for more details. Output and working directory \u00b6 The output directory is the directory where the final results are stored. The working directory is the directory where the pipeline information and intermediate files are stored. By default, the output directory is ./<name>-output and the working directory is ./.pipen/<name> . The output of processes with final results will be stored in the output directory in sub-directories named after the processes. For example, the output of SeuratClusteringOfAllCells will be stored in ./<outdir>/SeuratClusteringOfAllCells . This is also a special subdirectory named REPORTS that contains the reports of the pipeline. By visiting the <outdir>/REPORTS/index.html with a web browser, you can check the reports of the pipeline. You can change the output directory by setting outdir or name in the configuration file. For example, if you want to change the output directory to ./output , you can set the configurations as follows: outdir = \"./output\" If you change the pipeline name: name = \"my-pipeline\" Then the output directory will be changed to ./my-pipeline-output . Note If both outdir and name are set, outdir will be used. You can do the similar thing to change the working directory. However, you are NOT recommended to change the working directory, especially if you are using pipen-board . This is because that the plugin scans ./.pipen/<name> to get the information for the previous run of the pipeline. If you change the working directory, the plugin will not be able to find the information for the previous run. Tip What if you want to change the working directory anyway? The recommended way is to create a symbolic link to the working directory. For example, if you want to change the working directory to /path/to/the/real/working/directory , you can do: ln -s /path/to/the/real/working/directory ./.pipen Tip You can also then debug the pipeline by inspecting the real scripts in the working directory that run for the jobs of each process at ./.pipen/<name>/<process-name>/<job-index>/job.script . You can also find the other information for the jobs at ./.pipen/<name>/<process-name>/<job-index>/ , including the stdout ( job.stdout ) and stderr ( job.stderr ) of the jobs, the exit code of the jobs ( job.rc ), etc. Process level configurations \u00b6 cache : Should we detect whether the jobs are cached. If true , the jobs will be skipped if the output files exist and newer than the input files. (Default: true ) error_strategy : The strategy to handle the errors. halt : Any failure will just halt the entire pipeline (default) ignore : Ignore the error and keep running (assuming the job runs successfully anyway) retry : Retry to job running. After num_retries times of retrying, if the job is still failing, halt the pipeline. num_retries : The number of retries for the jobs. (Default: 3 ) forks : How many jobs to run simultaneously? (Default: 1 ) scheduler : The scheduler to use. If not specified, the scheduler specified in the pipeline level configurations will be used. scheduler_opts : The options for the scheduler. If not specified, the scheduler options specified in the pipeline level configurations will be used. See also How to run the pipeline on a cluster? for more details. To know more about the configuration items for the pipeline, you can also read the pipen docs . Enabling/disabling processes \u00b6 By default, only the essential processes are enabled. If scTCR-seq data is avaiable, these processes include: SampleInfo ImmunarchLoading Immunarch SeuratPreparing SeuratClustering IntegratingTCR ClusterMarkers SeuratClusterStats If only scRNA-seq data is available, these processes include: SampleInfo SeuratPreparing SeuratClustering ClusterMarkers SeuratClusterStats See also Routes of the pipeline for more details. To enable optional processes, you just need to add the corresponding sections for the processes in the configuration file. As long as the process name appears in the configuration file, the process will be enabled. For example, if you want to add module scores (e.g. cell activation score) to the Seurat object, you can add the following lines to the configuration file: [ModuleScoreCalulator.envs.modules.TCell_Terminal_Differentiation] features = [ \"TIGIT\" , \"PDCD1\" , \"CD274\" , \"CTLA4\" , \"LAG3\" , \"HAVCR2\" , \"CD244\" , \"CD160\" ] If TCRClustering or TCRClusterStats is enabled, TCRClustering , IntegratingTCRClusters , and TCRClusterStats will be enabled automatically. Tip You may find out that for some processes, the default configurations are good enough for you to run. For example, TCRClustering is not enabled by default. If you don't change any configurations (by not putting in the configuration file nor changing any items on the web interface of pipen-board ) for the process, it will not be triggered. However, the default configurations are good enough for you to run the process. To enable it, you can either add this process manually in the configuration file: # ... other configurations [TCRClustering] or if you are using pipen-board , you can change a configuration item that does not actually affect the process. For example, you can change the forks of the process to 2 , instead of the default 1 , since the process is a single-job process. Then the process will be put in the configuration file and will be enabled. [TCRClustering] forks = 2 Minimal configurations \u00b6 The minimal configurations are just the configurations with the input file: [SampleInfo.in] infile = [ \"samples.txt\" ] The input file is the metadata file mentioned in Preparing the input . With the minimal configurations, the pipeline will have the essential processes enabled, depending on whether scTCR-seq data is available or not. You can also check the example report here to see what you will get with the minimal configurations, with scTCR-seq data available. Environment variable types \u00b6 The types of environment variables are annotated in the brackets next the name of the environment variables. For example, the type of envs.indicator_genes of TCellSelection is list , and it's annotated as: - indicator_genes (list): The genes to be used to select T cells. By default, the type of environment variables is string . The annotated types are helpful for the environment variables to be passed from the command line. It defines the argument and helps parse the argument from the command line. It is also useful to define the input elements from the pipen-board web interface and parse the values passed from the web interface as desired types. The following types are supported: string : The default type, the values will be used as strings. int : The values will be parsed as integers. float : The values will be parsed as floats. flag : The values will be parsed as boolean values. list / array : The values will be parsed as lists. You can also see the itype of some environment variables, that specifies the type of the elements in the list. It must be atomatic types, such as int , float , string , and flag . json : The values will be reciived as JSON strings and parsed as dictionaries (in python). choice / choices : The value should be chosen from one of the choices listed as sub-items. mchoice / mchoices : The value should be chosen from one or more of the choices listed as sub-items. ns / namespace : There are sub-items for the value. The sub-items will be parsed as key-value pairs. Understanding the data \u00b6 Understanding how the data is presented in the pipeline is helpful for the configuration, especially for the processes, such as RadarPlots and CellsDistribution . The configurations of this kind of processes are relying on the metadata. You can refer to the individual process pages for more details. Here we just give an introduction of how it works to set the configurations. The assay of the Seurat object \u00b6 The Seurat object is the main object used in the pipeline. You can have multiple assays in the Seurat object. While preparing the Seurat object at SeuratPreparing process, the default assay is determined. If envs.use_sct is true, meaning SCTransform is used, the default assay will be SCT . If you are using cca or rpca integration, integrated will be used as the default assay. Otherwise, the default assay will be RNA . For downstream processes using the expression values, we provide an option to specify the assay to use. However, the default assay is used. Unless you know what you are doing, you are not recommended to change the default assay. Using existing columns in the metadata \u00b6 In most cases, you can use the existing columns in the metadata to set the configurations. For example, if you want to plot the clone residency for each patient/subject, you need to specify the column name of the sample ID, as well as the column with the paired sample information (i.e. tumor vs blood ). Suppose the metadata (sitting in immdata$meta in R for example) is as follows: Sample Source MM003-Eariler BM MM003-Eariler PB MM005-Eariler BM MM005-Eariler PB Then you can set the configurations as follows: [RadarPlots.envs] subject = \"Sample\" group = \"Source\" And you will get the following plots: Mutating the metadata \u00b6 Sometimes, you may want to mutate the metadata to get the desired information. Of course, you can have them prepared in the input file, as those extra columns with meta information will be attached to the object (either immunarch$meta or srtobj@meta.data ) automatically. See Preparing the input for more details. However, sometimes the metadata is specific to some processes, you may not want to have them prepared in the input file to get all processes contaminated. Moreover, those derived columns are usually based on the existing columns, so that is also helpful to create them on the fly to keep the input file clean. In such case, for example, if you want to plot the clone residency for two groups (e.g. BM-Pre vs. BM-Post ) of samples for the same group (e.g. A ). However, the Source and Timepoint information are not in a single column of metadata. Here is when mutaters come in place. Suppose the metadata (sitting in immdata$meta in R for example) is as follows: Sample Group Source Timepoint MM003 A BM Pre MM003 A BM Pre MM005 A BM Post MM005 A BM Post ... ... ... ... Then you can set the configurations as follows: [CloneResidency.envs.mutaters] SampleGroup = \"paste0(Sample, '-', Timepoint)\" [CloneResidency.envs] subject = \"Group\" group = \"SampleGroup\" order = [ \"BM-Pre\" , \"BM-Post\" ] Then you will get a clone residency plot for group A with BM-Pre as x-axis and BM-Post as y-axis. The key-value pairs of mutaters are passed to dplyr::mutate() function. The actual code to mutate the metadata is as follows: df %>% mutate ( SampleGroup = paste0 ( Sample , '-' , Timepoint )) So, for this kind of advanced configurations, you need to have some knowledge of dplyr in R . You also need to pay attention to the keys of mutaters . Basically, the keys are the column names you want to create. So you need to make sure that the column names are not in the metadata already. Otherwise, the existing columns will be overwritten. For scRNA-seq data, the existing column names of the metadata are: orig.ident nCount_RNA nFeature_RNA and the meta columns in the input file. See also Preparing the input for more details. There could also be some other columns, depending on the previous processes. For example, if you have the cells clustered, there will be a column named seurat_clusters in the metadata. For scTCR-seq data, Sample is the only existing column in the metadata after loaded. Then the meta columns from the input file will be attached to the metadata. The best practice is to use a prefix for the column names you want to create. For example, if you want to create a column named Sample , you can use my_Sample instead. Then you can make sure that the column names are not in the metadata already. The other thing you need to pay attention to is that you should try to avoid . or - in the column names. For example, if you want to create a column named Sample-Source , you can use Sample_Source instead. This is because that the column names will be used as the keys of the environment variables, and some processes will translate - into . . See also Namespace environment variables for more details. Mutater helpers \u00b6 Other than the direct expressions that are parsed by rlang::parse_expr() , for processes with envs.mutaters , we also provide some helper functions to make it easier to create the columns, especially for identifying the clones that are expanded, collapsed, vanished and emerged between two groups. The helper functions are: expanded() : Identify the expanded clones between two groups. collapsed() : Identify the collapsed clones between two groups. vanished() : Identify the vanished clones between two groups. emerged() : Identify the emerged clones between two groups. The helper functions take the following arguments: df : The cell-level data. When used in dplyr::mutate() , you can use . to refer to the dataframe. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group-by column). If only the first group is given, the rest of the cells (with non-NA in group-by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column. id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . The returned values of the functions depend on the debug and uniq arguments. If debug is TRUE , the intermediate data frame will be returned. Otherwise, the ids will be returned. If uniq is TRUE , the ids will be unique. Otherwise, the ids will be the same length as the number of rows in input data frame, which is useful for mutating the metadata. Let's say we have the following data frame: CDR3.aa Group Clone1 A Clone1 A Clone2 A Clone3 A Clone3 A Clone3 A Clone4 A Clone4 A Clone2 B Clone2 B Clone3 B Clone3 B Clone4 B Clone4 B Clone4 B To identify the expanded clones between groups A and B , the intermediate data frame will be like: expanded ( df , Group , \"A\" , debug = TRUE ) # A tibble: 4 \u00d7 6 CDR3.aa ident_1 ident_2 .predicate .sum .diff < chr > < int > < int > < lgl > < int > < int > 1 Clone3 3 2 TRUE 5 1 2 Clone4 2 3 FALSE 5 -1 3 Clone2 1 2 FALSE 3 -1 4 Clone1 2 0 FALSE 2 2 So the expanded clones are Clone3 , and if you want to include the emerged clones, the result will be Clone3 and Clone1 . expanded ( df , Group , \"A\" ) [ 1 ] \"Clone3\" expanded ( df , Group , \"A\" , include_emerged = TRUE ) [ 1 ] \"Clone3\" \"Clone1\" # Change the order based on the difference expanded ( df , Group , \"A\" , include_emerged = TRUE , order = desc ( .diff )) [ 1 ] \"Clone1\" \"Clone3\" If you want to add a column named Expanded to the metadata to save the clone ids: df %>% mutate ( Expanded = expanded ( df , Group , \"A\" , uniq = FALSE )) # A tibble: 15 \u00d7 3 CDR3.aa Group Expanded < chr > < chr > < chr > 1 Clone1 A NA 2 Clone1 A NA 3 Clone2 A NA 4 Clone3 A Clone3 5 Clone3 A Clone3 6 Clone3 A Clone3 7 Clone4 A NA 8 Clone4 A NA 9 Clone2 B NA 10 Clone2 B NA 11 Clone3 B Clone3 12 Clone3 B Clone3 13 Clone4 B NA 14 Clone4 B NA 15 Clone4 B NA Filtering/Subsetting the data \u00b6 In most processes where we need to filter the data, we don't provide an option for you to set the expression for dplyr::filter() . Instead, you can make use of the mutaters to create a column for filtering. For example, if you only want to plot clone residency for only one patient/subject (e.g. MM003-Eariler ) in CloneResidency , you can set the configurations as follows (suppose we have Sample and Source columns in the metadata): [RadarPlots.envs.mutaters] SingleSample = \"if_else(Sample == 'MM003-Eariler', Sample, NA)\" [RadarPlots.envs] subject = \"SingleSample\" group = \"Source\" Then you will get only one plot for MM003-Eariler , but not for MM005-Eariler . The NA s will be filtered out automatically. Namespace environment variables \u00b6 There are some enviroment variables marked as namespace , which means that you can have sub-keys for them. For example, the envs.SCTransform of SeuratClusteringOfAllCells process is a namespace environment variable. It takes the arguments of Seurat::SCTransform() function. The names of arguments have dot ( . ) in them, such as do.scale , do.center , seed.use , etc. In the configuration file, we need to use dash ( - ) instead of dot ( . ) to set the values for these arguments. For example, if we want to set do.scale to TRUE , we need to set do-scale to true in the configuration file. [SeuratClusteringOfAllCells.envs.SCTransform] do-scale = true This is because that we use pipen-args plugin backended by argx to parse the command line arguments, including the configuration file. If we use . directly in the configuration file: [SeuratClusteringOfAllCells.envs.SCTransform] do . scale = true Then the pipen-args will parse it as do is the key and scale is the sub-key, and the above configuration will be parsed as: [SeuratClusteringOfAllCells.envs.SCTransform] do = { scale = true } which is not what we want. The reason why . is parsed as sub-key is that we want the argument to be able to be passed from command line. For example, if we want to set do.scale to TRUE from command line, we can do: $ immunopipe --SeuratClusteringOfAllCells.envs.SCTransform.do-scale true If we use . instead of - : $ immunopipe --SeuratClusteringOfAllCells.envs.SCTransform.do.scale true Then the pipen-args will parse it as [SeuratClusteringOfAllCells.envs.SCTransform] do = { scale = true } again. Tip You don't need to worry about which environment variables are namespace ones. We will mention it in the individual process pages and the description of the environment variables in pipen-board configuration descriptions. Multi-case variable design \u00b6 Some environment variables are designed to support multiple cases. However, in most cases, we only need to set the values for the default case. In such cases, the environment variable is usually a namespace environment variable with the sub-keys needed for the default case. In order to support multiple cases, a sub-key cases is added to the namespace environment variable. The cases is a dictionary (key-value pairs), where the keys are the names of the cases, and the values are the sub-keys for the corresponding cases. For example, the envs.cluster_size of TCRClusterStats process: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = {} If cases is empty, the default case will be added automatically. The name of the default case is DEFAULT . So the above configuration is equivalent to: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = {} } If you want to add more cases, you can add them to the cases dictionary. For example, if you want to add a case named CASE1 , you can do: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = {}, CASE1 = {} } Then you can set the values for the default case and CASE1 case. For example, if you want to set the by column to Sample for the default case and Sample1 for CASE1 , you can do: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = { }, CASE1 = { by = \"Sample1\" } } If a key in a case is not specified, the value in the default case will be used. In the above example, \"Sample\" will be used for by of the DEFAULT case, and { width = 1000, height = 1000, res = 100 } will be used for devpars of the CASE1 case. Security alert \u00b6 Danger Note that some configuration items will be evaluated in the scripts directly. For example, the mutaters will be passed to R scripts, parsed and evaluated so that they can be used in dplyr::mutate() . Even though some were evaluated by rlang , not all of them are safe. Some of them are evaluated directly. For example, one could inject malicious code in the expressions passed by dplyr::filter() . For example, in the script: df %>% filter ({{ expression }}) The expected expression is something like Sample == \"Sample001\" . However, one could pass Sample == \"Sample001\"); system(\"cat /etc/passwd\") to the expression , which will be evaluated as: df %>% filter ( Sample == \"Sample001\" ); system ( \"cat /etc/passwd\" ) This will cause the pipeline to run the command cat /etc/passwd in the shell. This is just an example. One could do more harm by injecting malicious code. When you give acess of composing the configuration file to others or the public (not recommended), either via the command line or the web interface by pipen-board , you need to be careful about the security issues.","title":"Configurations"},{"location":"configurations/#configurations","text":"In this section, we are discussing how to configure the pipeline itself and some common issues we may encounter or need to be aware of to configure individual processes. For the configurations of each process in details, please refer to the individual process pages. As mentioned in pipen 's docs , the configurations to control the pipeline can be ~/.pipen.toml and/or ./.pipen.toml . You can set the default values in those files. Additionally, you can also pass a configuration file from command line, as described in Running the pipeline section. You can override the default values in the configuration files by passing arguments from command line. The configuration file is in toml format. A schematic example is shown below: forks = 4 # Other pipeline configurations # process configurations [TCellSelection] forks = 2 # override the default value # envs of the process # e.g [TCellSelection.envs] indicator_genes = [ \"CD3D\" , \"CD3E\" , \"CD3G\" ] # other processes # [ProcessName] # ... Tip In the individual process pages, we will list the envs of the process. For example, indicator_genes (list) : The genes to be used to select T cells. This means that the environment variable indicator_genes should be set as follows: [TCellSelection.envs] indicator_genes = [ \"CD3D\" , \"CD3E\" , \"CD3G\" ]","title":"Configurations"},{"location":"configurations/#pipeline-configurations","text":"There are pipeline level configurations and process level configurations. The pipeline level configurations are used to control the pipeline itself. The process level configurations set here are the default values for all the processes. You can override the default values for each process in the process level configurations. You can check all available configuration items and more details here . Here we only list some of the most important ones. The rest ones are not recommended to change unless you know what you are doing.","title":"Pipeline configurations"},{"location":"configurations/#pipeline-level-configurations","text":"name : The name of the pipeline (Default: \"Immunopipe\" ) It will change the working directory to ./.pipen/<name> , where the pipeline information and intermediate files will be stored. It will also change the default output directory to ./<name>-output . outdir : The output directory (Default: \"./<name>-output\" ) See also Output directory and working directory . loglevel : The logging level for the logger (Default: \"info\" ) plugin_opts : The options for the plugins. Following pipen plugins are installed with immunopipe . You may check the links for more details. pipen-board : Visualizing configuration and running of pipen pipelines on the web. pipen-verbose : Adding verbosal information in logs for pipen. pipen-runinfo : Generating running information for jobs in pipen pipelines. pipen-filters : Adding a set of useful filters for pipen templates. pipen-args : Command line argument parser for pipen pipen-annotate : Using docstring to annotate pipen processes. pipen-report : Generating reports for pipen pipelines. pipen-log2file : Logging to files for pipen pipelines. pipen-cli-run : Running pipen processes/process groups from command line. scheduler : The scheduler to use (Default: \"local\" ) scheduler_opts : The options for the scheduler. immunopipe is implemented using pipen , which is backended by xqute . Supported schedulers and options are listed here . See also How to run the pipeline on a cluster? for more details.","title":"Pipeline level configurations"},{"location":"configurations/#output-and-working-directory","text":"The output directory is the directory where the final results are stored. The working directory is the directory where the pipeline information and intermediate files are stored. By default, the output directory is ./<name>-output and the working directory is ./.pipen/<name> . The output of processes with final results will be stored in the output directory in sub-directories named after the processes. For example, the output of SeuratClusteringOfAllCells will be stored in ./<outdir>/SeuratClusteringOfAllCells . This is also a special subdirectory named REPORTS that contains the reports of the pipeline. By visiting the <outdir>/REPORTS/index.html with a web browser, you can check the reports of the pipeline. You can change the output directory by setting outdir or name in the configuration file. For example, if you want to change the output directory to ./output , you can set the configurations as follows: outdir = \"./output\" If you change the pipeline name: name = \"my-pipeline\" Then the output directory will be changed to ./my-pipeline-output . Note If both outdir and name are set, outdir will be used. You can do the similar thing to change the working directory. However, you are NOT recommended to change the working directory, especially if you are using pipen-board . This is because that the plugin scans ./.pipen/<name> to get the information for the previous run of the pipeline. If you change the working directory, the plugin will not be able to find the information for the previous run. Tip What if you want to change the working directory anyway? The recommended way is to create a symbolic link to the working directory. For example, if you want to change the working directory to /path/to/the/real/working/directory , you can do: ln -s /path/to/the/real/working/directory ./.pipen Tip You can also then debug the pipeline by inspecting the real scripts in the working directory that run for the jobs of each process at ./.pipen/<name>/<process-name>/<job-index>/job.script . You can also find the other information for the jobs at ./.pipen/<name>/<process-name>/<job-index>/ , including the stdout ( job.stdout ) and stderr ( job.stderr ) of the jobs, the exit code of the jobs ( job.rc ), etc.","title":"Output and working directory"},{"location":"configurations/#process-level-configurations","text":"cache : Should we detect whether the jobs are cached. If true , the jobs will be skipped if the output files exist and newer than the input files. (Default: true ) error_strategy : The strategy to handle the errors. halt : Any failure will just halt the entire pipeline (default) ignore : Ignore the error and keep running (assuming the job runs successfully anyway) retry : Retry to job running. After num_retries times of retrying, if the job is still failing, halt the pipeline. num_retries : The number of retries for the jobs. (Default: 3 ) forks : How many jobs to run simultaneously? (Default: 1 ) scheduler : The scheduler to use. If not specified, the scheduler specified in the pipeline level configurations will be used. scheduler_opts : The options for the scheduler. If not specified, the scheduler options specified in the pipeline level configurations will be used. See also How to run the pipeline on a cluster? for more details. To know more about the configuration items for the pipeline, you can also read the pipen docs .","title":"Process level configurations"},{"location":"configurations/#enablingdisabling-processes","text":"By default, only the essential processes are enabled. If scTCR-seq data is avaiable, these processes include: SampleInfo ImmunarchLoading Immunarch SeuratPreparing SeuratClustering IntegratingTCR ClusterMarkers SeuratClusterStats If only scRNA-seq data is available, these processes include: SampleInfo SeuratPreparing SeuratClustering ClusterMarkers SeuratClusterStats See also Routes of the pipeline for more details. To enable optional processes, you just need to add the corresponding sections for the processes in the configuration file. As long as the process name appears in the configuration file, the process will be enabled. For example, if you want to add module scores (e.g. cell activation score) to the Seurat object, you can add the following lines to the configuration file: [ModuleScoreCalulator.envs.modules.TCell_Terminal_Differentiation] features = [ \"TIGIT\" , \"PDCD1\" , \"CD274\" , \"CTLA4\" , \"LAG3\" , \"HAVCR2\" , \"CD244\" , \"CD160\" ] If TCRClustering or TCRClusterStats is enabled, TCRClustering , IntegratingTCRClusters , and TCRClusterStats will be enabled automatically. Tip You may find out that for some processes, the default configurations are good enough for you to run. For example, TCRClustering is not enabled by default. If you don't change any configurations (by not putting in the configuration file nor changing any items on the web interface of pipen-board ) for the process, it will not be triggered. However, the default configurations are good enough for you to run the process. To enable it, you can either add this process manually in the configuration file: # ... other configurations [TCRClustering] or if you are using pipen-board , you can change a configuration item that does not actually affect the process. For example, you can change the forks of the process to 2 , instead of the default 1 , since the process is a single-job process. Then the process will be put in the configuration file and will be enabled. [TCRClustering] forks = 2","title":"Enabling/disabling processes"},{"location":"configurations/#minimal-configurations","text":"The minimal configurations are just the configurations with the input file: [SampleInfo.in] infile = [ \"samples.txt\" ] The input file is the metadata file mentioned in Preparing the input . With the minimal configurations, the pipeline will have the essential processes enabled, depending on whether scTCR-seq data is available or not. You can also check the example report here to see what you will get with the minimal configurations, with scTCR-seq data available.","title":"Minimal configurations"},{"location":"configurations/#environment-variable-types","text":"The types of environment variables are annotated in the brackets next the name of the environment variables. For example, the type of envs.indicator_genes of TCellSelection is list , and it's annotated as: - indicator_genes (list): The genes to be used to select T cells. By default, the type of environment variables is string . The annotated types are helpful for the environment variables to be passed from the command line. It defines the argument and helps parse the argument from the command line. It is also useful to define the input elements from the pipen-board web interface and parse the values passed from the web interface as desired types. The following types are supported: string : The default type, the values will be used as strings. int : The values will be parsed as integers. float : The values will be parsed as floats. flag : The values will be parsed as boolean values. list / array : The values will be parsed as lists. You can also see the itype of some environment variables, that specifies the type of the elements in the list. It must be atomatic types, such as int , float , string , and flag . json : The values will be reciived as JSON strings and parsed as dictionaries (in python). choice / choices : The value should be chosen from one of the choices listed as sub-items. mchoice / mchoices : The value should be chosen from one or more of the choices listed as sub-items. ns / namespace : There are sub-items for the value. The sub-items will be parsed as key-value pairs.","title":"Environment variable types"},{"location":"configurations/#understanding-the-data","text":"Understanding how the data is presented in the pipeline is helpful for the configuration, especially for the processes, such as RadarPlots and CellsDistribution . The configurations of this kind of processes are relying on the metadata. You can refer to the individual process pages for more details. Here we just give an introduction of how it works to set the configurations.","title":"Understanding the data"},{"location":"configurations/#the-assay-of-the-seurat-object","text":"The Seurat object is the main object used in the pipeline. You can have multiple assays in the Seurat object. While preparing the Seurat object at SeuratPreparing process, the default assay is determined. If envs.use_sct is true, meaning SCTransform is used, the default assay will be SCT . If you are using cca or rpca integration, integrated will be used as the default assay. Otherwise, the default assay will be RNA . For downstream processes using the expression values, we provide an option to specify the assay to use. However, the default assay is used. Unless you know what you are doing, you are not recommended to change the default assay.","title":"The assay of the Seurat object"},{"location":"configurations/#using-existing-columns-in-the-metadata","text":"In most cases, you can use the existing columns in the metadata to set the configurations. For example, if you want to plot the clone residency for each patient/subject, you need to specify the column name of the sample ID, as well as the column with the paired sample information (i.e. tumor vs blood ). Suppose the metadata (sitting in immdata$meta in R for example) is as follows: Sample Source MM003-Eariler BM MM003-Eariler PB MM005-Eariler BM MM005-Eariler PB Then you can set the configurations as follows: [RadarPlots.envs] subject = \"Sample\" group = \"Source\" And you will get the following plots:","title":"Using existing columns in the metadata"},{"location":"configurations/#mutating-the-metadata","text":"Sometimes, you may want to mutate the metadata to get the desired information. Of course, you can have them prepared in the input file, as those extra columns with meta information will be attached to the object (either immunarch$meta or srtobj@meta.data ) automatically. See Preparing the input for more details. However, sometimes the metadata is specific to some processes, you may not want to have them prepared in the input file to get all processes contaminated. Moreover, those derived columns are usually based on the existing columns, so that is also helpful to create them on the fly to keep the input file clean. In such case, for example, if you want to plot the clone residency for two groups (e.g. BM-Pre vs. BM-Post ) of samples for the same group (e.g. A ). However, the Source and Timepoint information are not in a single column of metadata. Here is when mutaters come in place. Suppose the metadata (sitting in immdata$meta in R for example) is as follows: Sample Group Source Timepoint MM003 A BM Pre MM003 A BM Pre MM005 A BM Post MM005 A BM Post ... ... ... ... Then you can set the configurations as follows: [CloneResidency.envs.mutaters] SampleGroup = \"paste0(Sample, '-', Timepoint)\" [CloneResidency.envs] subject = \"Group\" group = \"SampleGroup\" order = [ \"BM-Pre\" , \"BM-Post\" ] Then you will get a clone residency plot for group A with BM-Pre as x-axis and BM-Post as y-axis. The key-value pairs of mutaters are passed to dplyr::mutate() function. The actual code to mutate the metadata is as follows: df %>% mutate ( SampleGroup = paste0 ( Sample , '-' , Timepoint )) So, for this kind of advanced configurations, you need to have some knowledge of dplyr in R . You also need to pay attention to the keys of mutaters . Basically, the keys are the column names you want to create. So you need to make sure that the column names are not in the metadata already. Otherwise, the existing columns will be overwritten. For scRNA-seq data, the existing column names of the metadata are: orig.ident nCount_RNA nFeature_RNA and the meta columns in the input file. See also Preparing the input for more details. There could also be some other columns, depending on the previous processes. For example, if you have the cells clustered, there will be a column named seurat_clusters in the metadata. For scTCR-seq data, Sample is the only existing column in the metadata after loaded. Then the meta columns from the input file will be attached to the metadata. The best practice is to use a prefix for the column names you want to create. For example, if you want to create a column named Sample , you can use my_Sample instead. Then you can make sure that the column names are not in the metadata already. The other thing you need to pay attention to is that you should try to avoid . or - in the column names. For example, if you want to create a column named Sample-Source , you can use Sample_Source instead. This is because that the column names will be used as the keys of the environment variables, and some processes will translate - into . . See also Namespace environment variables for more details.","title":"Mutating the metadata"},{"location":"configurations/#mutater-helpers","text":"Other than the direct expressions that are parsed by rlang::parse_expr() , for processes with envs.mutaters , we also provide some helper functions to make it easier to create the columns, especially for identifying the clones that are expanded, collapsed, vanished and emerged between two groups. The helper functions are: expanded() : Identify the expanded clones between two groups. collapsed() : Identify the collapsed clones between two groups. vanished() : Identify the vanished clones between two groups. emerged() : Identify the emerged clones between two groups. The helper functions take the following arguments: df : The cell-level data. When used in dplyr::mutate() , you can use . to refer to the dataframe. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group-by column). If only the first group is given, the rest of the cells (with non-NA in group-by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column. id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . The returned values of the functions depend on the debug and uniq arguments. If debug is TRUE , the intermediate data frame will be returned. Otherwise, the ids will be returned. If uniq is TRUE , the ids will be unique. Otherwise, the ids will be the same length as the number of rows in input data frame, which is useful for mutating the metadata. Let's say we have the following data frame: CDR3.aa Group Clone1 A Clone1 A Clone2 A Clone3 A Clone3 A Clone3 A Clone4 A Clone4 A Clone2 B Clone2 B Clone3 B Clone3 B Clone4 B Clone4 B Clone4 B To identify the expanded clones between groups A and B , the intermediate data frame will be like: expanded ( df , Group , \"A\" , debug = TRUE ) # A tibble: 4 \u00d7 6 CDR3.aa ident_1 ident_2 .predicate .sum .diff < chr > < int > < int > < lgl > < int > < int > 1 Clone3 3 2 TRUE 5 1 2 Clone4 2 3 FALSE 5 -1 3 Clone2 1 2 FALSE 3 -1 4 Clone1 2 0 FALSE 2 2 So the expanded clones are Clone3 , and if you want to include the emerged clones, the result will be Clone3 and Clone1 . expanded ( df , Group , \"A\" ) [ 1 ] \"Clone3\" expanded ( df , Group , \"A\" , include_emerged = TRUE ) [ 1 ] \"Clone3\" \"Clone1\" # Change the order based on the difference expanded ( df , Group , \"A\" , include_emerged = TRUE , order = desc ( .diff )) [ 1 ] \"Clone1\" \"Clone3\" If you want to add a column named Expanded to the metadata to save the clone ids: df %>% mutate ( Expanded = expanded ( df , Group , \"A\" , uniq = FALSE )) # A tibble: 15 \u00d7 3 CDR3.aa Group Expanded < chr > < chr > < chr > 1 Clone1 A NA 2 Clone1 A NA 3 Clone2 A NA 4 Clone3 A Clone3 5 Clone3 A Clone3 6 Clone3 A Clone3 7 Clone4 A NA 8 Clone4 A NA 9 Clone2 B NA 10 Clone2 B NA 11 Clone3 B Clone3 12 Clone3 B Clone3 13 Clone4 B NA 14 Clone4 B NA 15 Clone4 B NA","title":"Mutater helpers"},{"location":"configurations/#filteringsubsetting-the-data","text":"In most processes where we need to filter the data, we don't provide an option for you to set the expression for dplyr::filter() . Instead, you can make use of the mutaters to create a column for filtering. For example, if you only want to plot clone residency for only one patient/subject (e.g. MM003-Eariler ) in CloneResidency , you can set the configurations as follows (suppose we have Sample and Source columns in the metadata): [RadarPlots.envs.mutaters] SingleSample = \"if_else(Sample == 'MM003-Eariler', Sample, NA)\" [RadarPlots.envs] subject = \"SingleSample\" group = \"Source\" Then you will get only one plot for MM003-Eariler , but not for MM005-Eariler . The NA s will be filtered out automatically.","title":"Filtering/Subsetting the data"},{"location":"configurations/#namespace-environment-variables","text":"There are some enviroment variables marked as namespace , which means that you can have sub-keys for them. For example, the envs.SCTransform of SeuratClusteringOfAllCells process is a namespace environment variable. It takes the arguments of Seurat::SCTransform() function. The names of arguments have dot ( . ) in them, such as do.scale , do.center , seed.use , etc. In the configuration file, we need to use dash ( - ) instead of dot ( . ) to set the values for these arguments. For example, if we want to set do.scale to TRUE , we need to set do-scale to true in the configuration file. [SeuratClusteringOfAllCells.envs.SCTransform] do-scale = true This is because that we use pipen-args plugin backended by argx to parse the command line arguments, including the configuration file. If we use . directly in the configuration file: [SeuratClusteringOfAllCells.envs.SCTransform] do . scale = true Then the pipen-args will parse it as do is the key and scale is the sub-key, and the above configuration will be parsed as: [SeuratClusteringOfAllCells.envs.SCTransform] do = { scale = true } which is not what we want. The reason why . is parsed as sub-key is that we want the argument to be able to be passed from command line. For example, if we want to set do.scale to TRUE from command line, we can do: $ immunopipe --SeuratClusteringOfAllCells.envs.SCTransform.do-scale true If we use . instead of - : $ immunopipe --SeuratClusteringOfAllCells.envs.SCTransform.do.scale true Then the pipen-args will parse it as [SeuratClusteringOfAllCells.envs.SCTransform] do = { scale = true } again. Tip You don't need to worry about which environment variables are namespace ones. We will mention it in the individual process pages and the description of the environment variables in pipen-board configuration descriptions.","title":"Namespace environment variables"},{"location":"configurations/#multi-case-variable-design","text":"Some environment variables are designed to support multiple cases. However, in most cases, we only need to set the values for the default case. In such cases, the environment variable is usually a namespace environment variable with the sub-keys needed for the default case. In order to support multiple cases, a sub-key cases is added to the namespace environment variable. The cases is a dictionary (key-value pairs), where the keys are the names of the cases, and the values are the sub-keys for the corresponding cases. For example, the envs.cluster_size of TCRClusterStats process: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = {} If cases is empty, the default case will be added automatically. The name of the default case is DEFAULT . So the above configuration is equivalent to: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = {} } If you want to add more cases, you can add them to the cases dictionary. For example, if you want to add a case named CASE1 , you can do: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = {}, CASE1 = {} } Then you can set the values for the default case and CASE1 case. For example, if you want to set the by column to Sample for the default case and Sample1 for CASE1 , you can do: [TCRClusterStats.envs.cluster_size] by = \"Sample\" devpars = { width = 1000 , height = 1000 , res = 100 } cases = { DEFAULT = { }, CASE1 = { by = \"Sample1\" } } If a key in a case is not specified, the value in the default case will be used. In the above example, \"Sample\" will be used for by of the DEFAULT case, and { width = 1000, height = 1000, res = 100 } will be used for devpars of the CASE1 case.","title":"Multi-case variable design"},{"location":"configurations/#security-alert","text":"Danger Note that some configuration items will be evaluated in the scripts directly. For example, the mutaters will be passed to R scripts, parsed and evaluated so that they can be used in dplyr::mutate() . Even though some were evaluated by rlang , not all of them are safe. Some of them are evaluated directly. For example, one could inject malicious code in the expressions passed by dplyr::filter() . For example, in the script: df %>% filter ({{ expression }}) The expected expression is something like Sample == \"Sample001\" . However, one could pass Sample == \"Sample001\"); system(\"cat /etc/passwd\") to the expression , which will be evaluated as: df %>% filter ( Sample == \"Sample001\" ); system ( \"cat /etc/passwd\" ) This will cause the pipeline to run the command cat /etc/passwd in the shell. This is just an example. One could do more harm by injecting malicious code. When you give acess of composing the configuration file to others or the public (not recommended), either via the command line or the web interface by pipen-board , you need to be careful about the security issues.","title":"Security alert"},{"location":"faq/","text":"FAQ \u00b6 immunopipe command not found? Please make sure if you have installed immunopipe on the right python . If you have used pip to install immunopipe , make sure the pip is associated with the right python . You may try /path/to/python -m pip install -U immunopipe to ensure immunopipe is installed with the python you wanted. If immunopipe still can't be found from command line, try /path/to/python -m immunopipe . Why I am getting \"Error writing to connection: No space left on device\" while running ImmunarchLoading ? If you are running the pipeline and it complains about \"No space left on device\" at ImmunarchLoading , and you are pretty sure that your working directory is way from full, it is likely that your temporary directory does not have enough space. This is because that the ImmunarchLoading process will create a temporary directory to store the intermediate files, and the default temporary directory is /tmp . Make sure that you have enough space in /tmp or you can change the temporary directory by setting the environment variable of the process: envs.tmpdir . It is also likely that you are running the pipeline in a docker container and the docker container does not have enough space in /tmp . In such case, you can try to run the pipeline with the -v option of docker to local directory to /tmp in the container. For example: docker run --rm -w /workdir -v .:/workdir -v path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ justold/immunopipe:<tag> @config.toml If you are using singularity / apptainer , you can try to use the -B option to bind the local directory to /tmp in the container. Singularity Apptainer singularity run \\ --pwd /workdir -B .:/workdir -c -e --writable-tmpfs \\ -B path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ docker://justold/immunopipe:<tag> \\ @config.toml apptainer run \\ --pwd /workdir -B .:/workdir -c -e --unsquash --writable-tmpfs \\ -B path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ docker://justold/immunopipe:<tag> \\ @config.toml Why does the pipeline stop at SeuratClusteringOfAllCells and family without a clear error message? This is likely because that the pipeline is running out of memory. The SeuratClusteringOfAllCells and family processes (e.g. SeuratClustering ) will run the a series of Seurat functions to perform the clustering, especially the IntegrateData and FindIntegrationAnchors functions, and IntegrateLayers with Seurat v5. Please see the following issues for more details: https://github.com/satijalab/seurat/issues/3326 https://github.com/satijalab/seurat/issues/1720 https://github.com/satijalab/seurat/issues/2828 https://github.com/satijalab/seurat/issues/1254 https://github.com/satijalab/seurat/issues/7027 Also check out the tips by the Seurat team: https://satijalab.org/seurat/articles/integration_large_datasets Two possible solutions are: Use reduction = \"rpca\" for FindIntegrationAnchors under [SeuratClusteringOfAllCells.envs.FindIntegrationAnchors] . Use Reference-based integration reference = [1, 2] for FindIntegrationAnchors under [SeuratClusteringOfAllCells.envs.FindIntegrationAnchors] . For Seurat v5, use corresponding parameters for IntegrateLayers . Tip You can also pass a list of sample names instead of the sample indices. For example, reference = [\"sample1\", \"sample2\"] under [SeuratPreparing.envs.IntegrateLayers] to use sample1 and sample2 as the reference samples. See also description about IntegrateLayers here . Can I run one of the processes from the pipeline separately if I have the input files prepared? Only for some of the processes. immunopipe depends on biopipen . Most of the processes in immunopipe are subclasses of processes in biopipen . You can run the processes in biopipen separately by: pipen run scrna SeuratClustering [ options ] Note that only the processes from biopipen can be run separately. The processes in immunopipe are not designed to be run separately. For example, the SeuratClusteringOfAllCells process in immunopipe is a subclass of the SeuratClustering process in biopipen . It's specialized for the immunopipe pipeline. If you want to run a similar process separately, you should use the SeuratClustering process in biopipen instead. Like immunopipe , you can also either provide a configuration file: pipen run scrna SeuratClustering @config.toml or specify the options in the command line: pipen run scrna SeuratClustering --in.srtobj path/to/srtobj.RDS ... You can also use the -h / --help option to see the brief options of the process, or use -h+ / --help+ to see the full options of the process. How to run the pipeline on a cluster? To run the pipeline on a cluster, it's recommended to install the pipeline locally so that the cluster nodes can access the pipeline. immunopipe is built on top of pipen and xqute . A set of schedulers are supported by default. These schedulers are: local : Run the pipeline locally. slurm : Run the pipeline on a slurm cluster. sge : Run the pipeline on a sge cluster. ssh : Run the pipeline on a remote host via ssh. The scheduler can be specified via scheduler_opts for the whole pipeline or for a specific process. For example, to run the whole pipeline on a slurm cluster, you can use the following configuration file: scheduler = \"slurm\" [scheduler_opts] sbatch_partition = \"1-day\" To run a specific process on a slurm cluster, you can use the following configuration file: [ < Process > ] scheduler = \"slurm\" [ < Process > .scheduler_opts] sbatch_partition = \"1-day\" You can also use profiles to switch between different schedulers. See also https://pwwang.github.io/pipen/configurations/#profiles Unlike the pipeline installed locally, using a doker image to run the pipeline on a cluster, we need to run the whole pipeline as a job. For example, to run the pipeline on a slurm cluster using apptainer , you can use slurm to submit the job: srun <srun options> \\ apptainer run --pwd /workdir -B /path/to/workdir:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ -B /path/to/tmp:/tmp \\ docker://justold/immunopipe:<tag> \\ @config.toml If you are using docker and its alternatives, please also refer to: https://slurm.schedmd.com/containers.html Do I have to re-run the entire pipeline if I want to change some parameters? If you want to change some parameters for a specific process, you just modify the configuration file and re-run the pipeline. The pipeline will detect the changes and re-run the necessary processes. For example, if you are changing some environment variables for ScFGSEA , the prior processes, such as the ones for clustering and differential expression analysis, will be cached and will not be re-run. Why I am getting this error when running with apptainer : FATAL: no SIF writable overlay partition found in /tmp/apptainer_cache_xxx/... ? You may need to add --unsquash option for apptainer run . How can I use data with soft links while using docker image to run the pipeline? The container does not have access to the host filesystem directly. You need to mount the directory containing the data to the container. For example, if your real data is under /path/to/data , you can mount it to /data in the container (using -v /path/to/data:/data option for docker or -B /path/to/data:/data option for singularity or apptainer ). Then you can use /data in the container to access the data under /path/to/data on the host. Also remember to change the path of RNAData and TCRData in the file (e.g. samples.txt ) that is passed to SampleInfo process. Other than /data , there are other directories that you can use for mounting inside the container, including /mnt and /tmp , in case your want to mount multiple directories. See also The directory structure in the container . Why I am getting disk quota exceeded error while pulling the docker image using apptainer with still plenty of space on the disk? It's probably because that the cache directory of apptainer is full. You can try to use a different cache directory by setting the environment variable APPTAINER_CACHEDIR to a different directory. For example: export APPTAINER_CACHEDIR = /path/to/cache apptainer pull justold/immunopipe:<tag> See also: https://apptainer.org/docs/user/main/build_env.html#cache-folders Unable to fork: Cannot allocate memory or long vectors not supported yet during clustering using Seurat? This is likely because that the pipeline is running out of memory. The SeuratClusteringOfAllCells and family processes (e.g. SeuratClustering ) will run the a series of Seurat functions to perform the clustering, especially the IntegrateData and FindIntegrationAnchors functions, and IntegrateLayers with Seurat v5. You can try to set envs.ncores to a smaller number to reduce the memory usage. For example: [SeuratClusteringOfAllCells.envs] ncores = 4 # instead of 16 The other strategy is to use Reference-based integration reference = [1, 2] for IntegrateLayers with method rpca or cca . See also description about IntegrateLayers here . For example: [SeuratPreparing.envs.IntegrateLayers] method = \"rpca\" reference = [ 1 , 2 ] # You can also use sample names instead of indices See also these issues for more details: https://github.com/satijalab/seurat/issues/1029 https://github.com/satijalab/seurat/issues/7419 Got error Not all stats values are finite numbers while running ScFGSEA ? It's probably because that there are too many missing values in the expression matrix and signal_to_noise is not able to detect the rank of the genes. You can try a different method for gene preranking. For example: [ScFGSEA.envs] method = \"diff_of_classes\"","title":"FAQ"},{"location":"faq/#faq","text":"immunopipe command not found? Please make sure if you have installed immunopipe on the right python . If you have used pip to install immunopipe , make sure the pip is associated with the right python . You may try /path/to/python -m pip install -U immunopipe to ensure immunopipe is installed with the python you wanted. If immunopipe still can't be found from command line, try /path/to/python -m immunopipe . Why I am getting \"Error writing to connection: No space left on device\" while running ImmunarchLoading ? If you are running the pipeline and it complains about \"No space left on device\" at ImmunarchLoading , and you are pretty sure that your working directory is way from full, it is likely that your temporary directory does not have enough space. This is because that the ImmunarchLoading process will create a temporary directory to store the intermediate files, and the default temporary directory is /tmp . Make sure that you have enough space in /tmp or you can change the temporary directory by setting the environment variable of the process: envs.tmpdir . It is also likely that you are running the pipeline in a docker container and the docker container does not have enough space in /tmp . In such case, you can try to run the pipeline with the -v option of docker to local directory to /tmp in the container. For example: docker run --rm -w /workdir -v .:/workdir -v path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ justold/immunopipe:<tag> @config.toml If you are using singularity / apptainer , you can try to use the -B option to bind the local directory to /tmp in the container. Singularity Apptainer singularity run \\ --pwd /workdir -B .:/workdir -c -e --writable-tmpfs \\ -B path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ docker://justold/immunopipe:<tag> \\ @config.toml apptainer run \\ --pwd /workdir -B .:/workdir -c -e --unsquash --writable-tmpfs \\ -B path/to/tmp:/tmp \\ # ^^^^^^^^^^^^^^^^^^^ docker://justold/immunopipe:<tag> \\ @config.toml Why does the pipeline stop at SeuratClusteringOfAllCells and family without a clear error message? This is likely because that the pipeline is running out of memory. The SeuratClusteringOfAllCells and family processes (e.g. SeuratClustering ) will run the a series of Seurat functions to perform the clustering, especially the IntegrateData and FindIntegrationAnchors functions, and IntegrateLayers with Seurat v5. Please see the following issues for more details: https://github.com/satijalab/seurat/issues/3326 https://github.com/satijalab/seurat/issues/1720 https://github.com/satijalab/seurat/issues/2828 https://github.com/satijalab/seurat/issues/1254 https://github.com/satijalab/seurat/issues/7027 Also check out the tips by the Seurat team: https://satijalab.org/seurat/articles/integration_large_datasets Two possible solutions are: Use reduction = \"rpca\" for FindIntegrationAnchors under [SeuratClusteringOfAllCells.envs.FindIntegrationAnchors] . Use Reference-based integration reference = [1, 2] for FindIntegrationAnchors under [SeuratClusteringOfAllCells.envs.FindIntegrationAnchors] . For Seurat v5, use corresponding parameters for IntegrateLayers . Tip You can also pass a list of sample names instead of the sample indices. For example, reference = [\"sample1\", \"sample2\"] under [SeuratPreparing.envs.IntegrateLayers] to use sample1 and sample2 as the reference samples. See also description about IntegrateLayers here . Can I run one of the processes from the pipeline separately if I have the input files prepared? Only for some of the processes. immunopipe depends on biopipen . Most of the processes in immunopipe are subclasses of processes in biopipen . You can run the processes in biopipen separately by: pipen run scrna SeuratClustering [ options ] Note that only the processes from biopipen can be run separately. The processes in immunopipe are not designed to be run separately. For example, the SeuratClusteringOfAllCells process in immunopipe is a subclass of the SeuratClustering process in biopipen . It's specialized for the immunopipe pipeline. If you want to run a similar process separately, you should use the SeuratClustering process in biopipen instead. Like immunopipe , you can also either provide a configuration file: pipen run scrna SeuratClustering @config.toml or specify the options in the command line: pipen run scrna SeuratClustering --in.srtobj path/to/srtobj.RDS ... You can also use the -h / --help option to see the brief options of the process, or use -h+ / --help+ to see the full options of the process. How to run the pipeline on a cluster? To run the pipeline on a cluster, it's recommended to install the pipeline locally so that the cluster nodes can access the pipeline. immunopipe is built on top of pipen and xqute . A set of schedulers are supported by default. These schedulers are: local : Run the pipeline locally. slurm : Run the pipeline on a slurm cluster. sge : Run the pipeline on a sge cluster. ssh : Run the pipeline on a remote host via ssh. The scheduler can be specified via scheduler_opts for the whole pipeline or for a specific process. For example, to run the whole pipeline on a slurm cluster, you can use the following configuration file: scheduler = \"slurm\" [scheduler_opts] sbatch_partition = \"1-day\" To run a specific process on a slurm cluster, you can use the following configuration file: [ < Process > ] scheduler = \"slurm\" [ < Process > .scheduler_opts] sbatch_partition = \"1-day\" You can also use profiles to switch between different schedulers. See also https://pwwang.github.io/pipen/configurations/#profiles Unlike the pipeline installed locally, using a doker image to run the pipeline on a cluster, we need to run the whole pipeline as a job. For example, to run the pipeline on a slurm cluster using apptainer , you can use slurm to submit the job: srun <srun options> \\ apptainer run --pwd /workdir -B /path/to/workdir:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ -B /path/to/tmp:/tmp \\ docker://justold/immunopipe:<tag> \\ @config.toml If you are using docker and its alternatives, please also refer to: https://slurm.schedmd.com/containers.html Do I have to re-run the entire pipeline if I want to change some parameters? If you want to change some parameters for a specific process, you just modify the configuration file and re-run the pipeline. The pipeline will detect the changes and re-run the necessary processes. For example, if you are changing some environment variables for ScFGSEA , the prior processes, such as the ones for clustering and differential expression analysis, will be cached and will not be re-run. Why I am getting this error when running with apptainer : FATAL: no SIF writable overlay partition found in /tmp/apptainer_cache_xxx/... ? You may need to add --unsquash option for apptainer run . How can I use data with soft links while using docker image to run the pipeline? The container does not have access to the host filesystem directly. You need to mount the directory containing the data to the container. For example, if your real data is under /path/to/data , you can mount it to /data in the container (using -v /path/to/data:/data option for docker or -B /path/to/data:/data option for singularity or apptainer ). Then you can use /data in the container to access the data under /path/to/data on the host. Also remember to change the path of RNAData and TCRData in the file (e.g. samples.txt ) that is passed to SampleInfo process. Other than /data , there are other directories that you can use for mounting inside the container, including /mnt and /tmp , in case your want to mount multiple directories. See also The directory structure in the container . Why I am getting disk quota exceeded error while pulling the docker image using apptainer with still plenty of space on the disk? It's probably because that the cache directory of apptainer is full. You can try to use a different cache directory by setting the environment variable APPTAINER_CACHEDIR to a different directory. For example: export APPTAINER_CACHEDIR = /path/to/cache apptainer pull justold/immunopipe:<tag> See also: https://apptainer.org/docs/user/main/build_env.html#cache-folders Unable to fork: Cannot allocate memory or long vectors not supported yet during clustering using Seurat? This is likely because that the pipeline is running out of memory. The SeuratClusteringOfAllCells and family processes (e.g. SeuratClustering ) will run the a series of Seurat functions to perform the clustering, especially the IntegrateData and FindIntegrationAnchors functions, and IntegrateLayers with Seurat v5. You can try to set envs.ncores to a smaller number to reduce the memory usage. For example: [SeuratClusteringOfAllCells.envs] ncores = 4 # instead of 16 The other strategy is to use Reference-based integration reference = [1, 2] for IntegrateLayers with method rpca or cca . See also description about IntegrateLayers here . For example: [SeuratPreparing.envs.IntegrateLayers] method = \"rpca\" reference = [ 1 , 2 ] # You can also use sample names instead of indices See also these issues for more details: https://github.com/satijalab/seurat/issues/1029 https://github.com/satijalab/seurat/issues/7419 Got error Not all stats values are finite numbers while running ScFGSEA ? It's probably because that there are too many missing values in the expression matrix and signal_to_noise is not able to detect the rank of the genes. You can try a different method for gene preranking. For example: [ScFGSEA.envs] method = \"diff_of_classes\"","title":"FAQ"},{"location":"gallery/","text":"Gallery \u00b6 The following are some datasets with both scRNA-seq and scTCR-seq data available in the publications. The data were reanalyzed using immunopipe with the configurations provided in each repository, where the results are also available. In the README file of each repository, you can find the links to the original publications and the reports generated by immunopipe . ID GEO Repository Condition 1 GSE144469 immunopipe-AdrienneML-2020 Melanoma and therapy 2 GSE176201 immunopipe-CheonIS-2021 COVID-19 lung tissue 3 GSE180268 immunopipe-EberhardtCS-2021 HPV and Head and Neck cancer 4 GSE114724 immunopipe-ElhamA-2018 Breast Cancer 5 GSE161192 immunopipe-GateD-2021 LB dementia 6 GSE179994 immunopipe-LiuB-2022 anti-PD-1 therapy in lung cancer 7 GSE148190 immunopipe-MahuronKM-2020 Skin cancer 8 GSE139555 immunopipe-ThomasW-2020 Anti-PD1 therapy 9 GSE145370 immunopipe-ZhengY-2020 Oesophageal cancer ID # Individuals # Samples # Cells # matched TCR seqs 1 22 22 75,569 68,760 2 5 6 34,781 23,081 3 6 6 53,303 26,844 4 3 5 28,341 24,039 5 2 4 6,438 5,642 6 38 47 150,849 77,030 7 1 2 8,794 4,904 8 14 32 194,519 67,700 9 7 14 108,226 35,449 ID Reference 1 Luoma, Adrienne M., et al. 2020 2 Cheon, I. S., et al. 2021 3 Eberhardt, Christian S., et al. 2021 4 Alizadeh, Elham, et al. 2018 5 Gate, David, et al. 2021 6 Liu, B., et al. 2022 7 Mahuron, Kelly M., et al. 2020 8 Wu, Thomas D., et al. 2020 9 Zheng, Y., et al. 2020","title":"Gallery"},{"location":"gallery/#gallery","text":"The following are some datasets with both scRNA-seq and scTCR-seq data available in the publications. The data were reanalyzed using immunopipe with the configurations provided in each repository, where the results are also available. In the README file of each repository, you can find the links to the original publications and the reports generated by immunopipe . ID GEO Repository Condition 1 GSE144469 immunopipe-AdrienneML-2020 Melanoma and therapy 2 GSE176201 immunopipe-CheonIS-2021 COVID-19 lung tissue 3 GSE180268 immunopipe-EberhardtCS-2021 HPV and Head and Neck cancer 4 GSE114724 immunopipe-ElhamA-2018 Breast Cancer 5 GSE161192 immunopipe-GateD-2021 LB dementia 6 GSE179994 immunopipe-LiuB-2022 anti-PD-1 therapy in lung cancer 7 GSE148190 immunopipe-MahuronKM-2020 Skin cancer 8 GSE139555 immunopipe-ThomasW-2020 Anti-PD1 therapy 9 GSE145370 immunopipe-ZhengY-2020 Oesophageal cancer ID # Individuals # Samples # Cells # matched TCR seqs 1 22 22 75,569 68,760 2 5 6 34,781 23,081 3 6 6 53,303 26,844 4 3 5 28,341 24,039 5 2 4 6,438 5,642 6 38 47 150,849 77,030 7 1 2 8,794 4,904 8 14 32 194,519 67,700 9 7 14 108,226 35,449 ID Reference 1 Luoma, Adrienne M., et al. 2020 2 Cheon, I. S., et al. 2021 3 Eberhardt, Christian S., et al. 2021 4 Alizadeh, Elham, et al. 2018 5 Gate, David, et al. 2021 6 Liu, B., et al. 2022 7 Mahuron, Kelly M., et al. 2020 8 Wu, Thomas D., et al. 2020 9 Zheng, Y., et al. 2020","title":"Gallery"},{"location":"getting-started/","text":"Getting started \u00b6 You can find the nessary files and source code of this tutorial in the example repository . In this tutorial we will show you how to run the immunopipe pipeline on a small dataset of 6 patients from 3 groups: colitis (n=2), non-colitis(n=2) and control(n=2). The dataset is part of the data used in the publication below: Luoma, Adrienne M., et al. \"Molecular pathways of colon inflammation induced by cancer immunotherapy.\" Cell 182.3 (2020): 655-671. We are using a small subset of the data to make the tutorial run faster. The full dataset can be downloaded from Gene Expression Omnibus (GEO) GSE144469 . Download and prepare the data \u00b6 The data can be downloaded and prepared by running the following commands: # Clone the example repository git clone https://github.com/pwwang/immunopipe-example.git # Enter the example directory cd immunopipe-example # Download and prepare the data bash prepare-data.sh # The data from GSE144469 (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE144469) # will be downloaded and extracted into: # # ./prepared-data/C1 # ./prepared-data/C2 # ... # You may also check other files in the data/ directory, especially the samples.txt file, which contains the sample information for the dataset we prepared above. Prepare the configuration file \u00b6 To run the pipeline, we need to prepare a configuration file (recommended) or pass the arguments directly via command line. Here we will use the configuration file. See also Configurations for more details. As explained in the Configurations page, we can provide a configuration file with a minimal set of configuration items to get the pipeline running. The only required configuration item is the input file for the SampleInfo process. However, here we want to give the pipeline a different name and output directory to distinguish it from other runs with a different set of configurations. The configuration file shall be in the TOML format. We can create a file named ImmunopipeMinimal.config.toml with the following content: name = \"ImmunopipeMinimal\" outdir = \"minimal\" [SampleInfo.in] infile = [ \"data/samples.txt\" ] Run the pipeline \u00b6 The easiest way to run the pipeline is to run it within the docker container. We can use the following command to run the pipeline with the configuration file we just created: Using docker Using singularity Using apptainer docker run \\ --rm -w /workdir -v .:/workdir \\ justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml Tip docker , singularity and apptainer commands map the current directory ( . ) to the /workdir directory in the container. To get the detailed directory structure in the container, please refer to the The directory structure in the container . Tip If you want to install and run the pipeline without docker, please refer to the Installation and Running the pipeline pages for more details. Note You need at least 16GB of memory to run the pipeline with the example dataset and minimal configuration. You may also need to decrease ncores of some processes to avoid running out of memory. For example: [SeuratClusteringOfAllCells.envs] - ncores = 8 + ncores = 4 Check the results \u00b6 With that \"minimal\" configuration file, only a subset of the processes will be run. See also Enabling/Disabling processes . The results will be saved in the minimal directory. You can also check the reports at minimal/REPORTS/index.html with a web browser. You can also visit the following link to see the reports of the pipeline we just ran: http://imp.pwwang.com/minimal/REPORTS/index.html Next steps \u00b6 You may read through this documentation to learn more about the pipeline and how to configure it. There is also a configuration file, named Immunopipe.config.toml in the example repository, with more processes enabled. You can use it to run the pipeline with the dataset prepared above. Check out the following link for the reports: http://imp.pwwang.com/output/REPORTS/index.html Note The results provided by this example configuration files are for demonstration purpose only. They are not intended to be used for any scientific analysis. You may also want to try other routes of the pipeline with the prepared data. These routes are defined in: ImmunopipeMinimalNoTCR.config.toml : The configuration for minimal analyses without scTCR-seq data. ImmunopipeMinimalSupervised.config.toml : The configuration for minimal analyses with supervised clustering of T cells. ImmunopipeNoTCR.config.toml : The configuration for full analyses without scTCR-seq data. ImmunopipeWSNoTCR.config.toml : The configuration for full analyses without scTCR-seq data, but with selection of T cells. ImmunopipeSupervised.config.toml : The configuration for full analyses with supervised clustering of T cells. Also check out the gallery for more real-world examples.","title":"Geting started"},{"location":"getting-started/#getting-started","text":"You can find the nessary files and source code of this tutorial in the example repository . In this tutorial we will show you how to run the immunopipe pipeline on a small dataset of 6 patients from 3 groups: colitis (n=2), non-colitis(n=2) and control(n=2). The dataset is part of the data used in the publication below: Luoma, Adrienne M., et al. \"Molecular pathways of colon inflammation induced by cancer immunotherapy.\" Cell 182.3 (2020): 655-671. We are using a small subset of the data to make the tutorial run faster. The full dataset can be downloaded from Gene Expression Omnibus (GEO) GSE144469 .","title":"Getting started"},{"location":"getting-started/#download-and-prepare-the-data","text":"The data can be downloaded and prepared by running the following commands: # Clone the example repository git clone https://github.com/pwwang/immunopipe-example.git # Enter the example directory cd immunopipe-example # Download and prepare the data bash prepare-data.sh # The data from GSE144469 (https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE144469) # will be downloaded and extracted into: # # ./prepared-data/C1 # ./prepared-data/C2 # ... # You may also check other files in the data/ directory, especially the samples.txt file, which contains the sample information for the dataset we prepared above.","title":"Download and prepare the data"},{"location":"getting-started/#prepare-the-configuration-file","text":"To run the pipeline, we need to prepare a configuration file (recommended) or pass the arguments directly via command line. Here we will use the configuration file. See also Configurations for more details. As explained in the Configurations page, we can provide a configuration file with a minimal set of configuration items to get the pipeline running. The only required configuration item is the input file for the SampleInfo process. However, here we want to give the pipeline a different name and output directory to distinguish it from other runs with a different set of configurations. The configuration file shall be in the TOML format. We can create a file named ImmunopipeMinimal.config.toml with the following content: name = \"ImmunopipeMinimal\" outdir = \"minimal\" [SampleInfo.in] infile = [ \"data/samples.txt\" ]","title":"Prepare the configuration file"},{"location":"getting-started/#run-the-pipeline","text":"The easiest way to run the pipeline is to run it within the docker container. We can use the following command to run the pipeline with the configuration file we just created: Using docker Using singularity Using apptainer docker run \\ --rm -w /workdir -v .:/workdir \\ justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:master \\ @ImmunopipeMinimal.config.toml Tip docker , singularity and apptainer commands map the current directory ( . ) to the /workdir directory in the container. To get the detailed directory structure in the container, please refer to the The directory structure in the container . Tip If you want to install and run the pipeline without docker, please refer to the Installation and Running the pipeline pages for more details. Note You need at least 16GB of memory to run the pipeline with the example dataset and minimal configuration. You may also need to decrease ncores of some processes to avoid running out of memory. For example: [SeuratClusteringOfAllCells.envs] - ncores = 8 + ncores = 4","title":"Run the pipeline"},{"location":"getting-started/#check-the-results","text":"With that \"minimal\" configuration file, only a subset of the processes will be run. See also Enabling/Disabling processes . The results will be saved in the minimal directory. You can also check the reports at minimal/REPORTS/index.html with a web browser. You can also visit the following link to see the reports of the pipeline we just ran: http://imp.pwwang.com/minimal/REPORTS/index.html","title":"Check the results"},{"location":"getting-started/#next-steps","text":"You may read through this documentation to learn more about the pipeline and how to configure it. There is also a configuration file, named Immunopipe.config.toml in the example repository, with more processes enabled. You can use it to run the pipeline with the dataset prepared above. Check out the following link for the reports: http://imp.pwwang.com/output/REPORTS/index.html Note The results provided by this example configuration files are for demonstration purpose only. They are not intended to be used for any scientific analysis. You may also want to try other routes of the pipeline with the prepared data. These routes are defined in: ImmunopipeMinimalNoTCR.config.toml : The configuration for minimal analyses without scTCR-seq data. ImmunopipeMinimalSupervised.config.toml : The configuration for minimal analyses with supervised clustering of T cells. ImmunopipeNoTCR.config.toml : The configuration for full analyses without scTCR-seq data. ImmunopipeWSNoTCR.config.toml : The configuration for full analyses without scTCR-seq data, but with selection of T cells. ImmunopipeSupervised.config.toml : The configuration for full analyses with supervised clustering of T cells. Also check out the gallery for more real-world examples.","title":"Next steps"},{"location":"installation/","text":"Installation \u00b6 Install the pipline and the dependencies using conda \u00b6 Tip If you plan to use the docker image, you can skip this section. immunopipe is built upon pipen framework, and a number of packages written in R and python . It's not recommended to install the packages manually. Instead, you can use the provided environment.yml to create a conda environment. $ conda env create \\ -n immunopipe \\ -f https://raw.githubusercontent.com/pwwang/immunopipe/master/docker/environment.yml Attention The environment.yml includes only a subset of the packages required by the pipeline. The dependencies of the TESSA process are not included. If you want to enable TESSA process , please use the environment_full.yml ( https://raw.githubusercontent.com/pwwang/immunopipe/master/docker/environment_full.yml ) instead. See also Choose the right tag of the docker image . If the URL doesn't work, you can download the file and create the environment locally. For more detailed instructions of conda env create , please refer to conda docs . Attention The pipeline itself is NOT included in the conda environment. You need to install it separately. $ conda activate immunopipe $ pip install -U immunopipe $ # If you want to create diagram and generate running information $ pip install -U immunopipe [ diagram,runinfo ] $ # You also need to install the frontend dependencies to generate reports $ pipen report update Use the docker image \u00b6 You can also use the docker image to run the pipeline. The image is built upon miniconda3 and micromamba is used as the package manager. The image is available at Docker Hub . To pull the image: Using docker Using singularity Using apptainer $ docker pull justold/immunopipe:<tag> If you are using singularity , you can pull and convert the image to sif format: $ singularity pull docker://justold/immunopipe:<tag> $ apptainer pull docker://justold/immunopipe:<tag> To run the pipeline use the image, please refer to Running the pipeline . The directory structure in the container \u00b6 The docker image is build upon mambaorg/micromamba:1.4.3 . The OS is linux/amd64. Other than the default directories, the following directories are also created or should be mapped during the run: /immunopipe : The directory where the source code of the pipeline is. It is general a clone of the repository . The pipeline is also installed from this directory. /workdir : The working directory. It is the directory where the pipeline is run. It is recommended to map the current directory ( . ) to this directory. /data : An empty directory. You can map your data directory to this directory.","title":"Installation"},{"location":"installation/#installation","text":"","title":"Installation"},{"location":"installation/#install-the-pipline-and-the-dependencies-using-conda","text":"Tip If you plan to use the docker image, you can skip this section. immunopipe is built upon pipen framework, and a number of packages written in R and python . It's not recommended to install the packages manually. Instead, you can use the provided environment.yml to create a conda environment. $ conda env create \\ -n immunopipe \\ -f https://raw.githubusercontent.com/pwwang/immunopipe/master/docker/environment.yml Attention The environment.yml includes only a subset of the packages required by the pipeline. The dependencies of the TESSA process are not included. If you want to enable TESSA process , please use the environment_full.yml ( https://raw.githubusercontent.com/pwwang/immunopipe/master/docker/environment_full.yml ) instead. See also Choose the right tag of the docker image . If the URL doesn't work, you can download the file and create the environment locally. For more detailed instructions of conda env create , please refer to conda docs . Attention The pipeline itself is NOT included in the conda environment. You need to install it separately. $ conda activate immunopipe $ pip install -U immunopipe $ # If you want to create diagram and generate running information $ pip install -U immunopipe [ diagram,runinfo ] $ # You also need to install the frontend dependencies to generate reports $ pipen report update","title":"Install the pipline and the dependencies using conda"},{"location":"installation/#use-the-docker-image","text":"You can also use the docker image to run the pipeline. The image is built upon miniconda3 and micromamba is used as the package manager. The image is available at Docker Hub . To pull the image: Using docker Using singularity Using apptainer $ docker pull justold/immunopipe:<tag> If you are using singularity , you can pull and convert the image to sif format: $ singularity pull docker://justold/immunopipe:<tag> $ apptainer pull docker://justold/immunopipe:<tag> To run the pipeline use the image, please refer to Running the pipeline .","title":"Use the docker image"},{"location":"installation/#the-directory-structure-in-the-container","text":"The docker image is build upon mambaorg/micromamba:1.4.3 . The OS is linux/amd64. Other than the default directories, the following directories are also created or should be mapped during the run: /immunopipe : The directory where the source code of the pipeline is. It is general a clone of the repository . The pipeline is also installed from this directory. /workdir : The working directory. It is the directory where the pipeline is run. It is recommended to map the current directory ( . ) to this directory. /data : An empty directory. You can map your data directory to this directory.","title":"The directory structure in the container"},{"location":"introduction/","text":"Introduction \u00b6 The pipeline architecture \u00b6 immunopipe is built upon pipen . It is recommended to read the pipen docs first to get a better understanding of the pipeline. Here, we just want to highlight some concepts that are helpful to use the pipeline as a user. A process is a unit of work in the pipeline. immunopipe includes a set of processes. Some of them are reused from biopipen and some are written specifically for immunopipe . The input of a process is typically a pandas DataFrame , which serves as the channel passing data between processes. The rows of the data frame are distributed to the jobs of the process, and columns are spreaded to the input variables of the job s. See more illustration here . In our case, most processes are just single-job processes. Other than the start processes, the input of a process is the output of other process(es). So users don't need to worry about the input of the processes in the configurations. envs of a process is the most important part of immunopipe that a user needs to configure. It defines the environment variables of the process. The environment variables are shared by all the jobs of the process. Attention These environment variables are not the same as the environment variables of the system. They are just variables that are used in the process across its jobs. See individual process pages for more details about the envs of each process. Analyses and processes \u00b6 As shown in the figure above, immunopipe includes a set of processes for scTCR- and scRNA-seq data analysis. The processes are grouped into categories below: Data input and QC \u00b6 SampleInfo : Read sample information from a CSV file and list the sample information in the report. ImmunarchLoading : Load the data into immunarch objects. SeuratPreparing : Read the data into Seurat objects and perform QC. T cell selection \u00b6 SeuratClusteringOfAllCells : Perform clustering on all cells if non-T cells are present in the data. ClusterMarkersOfAllCells : Find markers for each cluster of all the cells and perform enrichment analysis. TopExpressingGenesOfAllCells : Find top expressing genes for each cluster of all the cells and perform enrichment analysis. TCellSelection : Select T cells from all cells. Clustering of T cells \u00b6 SeuratClustering : Perform clustering on all or T cells selected above. SeuratMap2Ref : Map the cells to a reference dataset. CellTypeAnnotation : Annotate cell types for each T-cell cluster. SeuratSubClustering : Perform sub-clustering on subsets of cells. ClusterMarkers : Find markers for each T-cell cluster and perform enrichment analysis. TopExpressingGenes : Find top expressing genes for each T-cell cluster and perform enrichment analysis. ModuleScoreCalculator : Calculate module scores or cell cycle scores for each cell. TCR data analyses \u00b6 CloneResidency : Explore the residency of TCR clones for paired samples (e.g. tumor vs blood) from the same patient. TCRClustering : Perform clustering on TCR clones based on CDR3 amino acid sequences. TCRClusterStats : Investigate statistics for TCR clusters (i.e. TCR cluster size distribution, shared TCR clusters among samples, revisited sample diversity using TCR clusters instead of clonotypes, etc.) Immunarch : Perform TCR clonotype analyses using immunarch package. Integrative analyses \u00b6 TESSA : Perform integrative analyses using Tessa . SeuratClusterStats : Investigate statistics for each T-cell cluster (i.e. the number of cells in each cluster, the number of cells in each sample for each cluster, feature/gene expression visualization, dimension reduction plots, etc.). It's also possible to perform stats on TCR clones/clusters for each T-cell cluster. IntegratingTCRClusters : Attach TCR clusters to Seurat objects. IntegratingTCR : Integrate TCR data into Seurat objects. RadarPlots : Visualize proportion of cells in different groups for each cluster. CellsDistribution : Investigate the distribution of cells in different groups for each T-cell cluster. CDR3AAPhyschem : Investigate the physicochemical properties of CDR3 amino acid sequences of one cell type over another (i.e. Treg vs Tconv ). ScFGSEA : Perform GSEA analysis for comparisons between two groups of cells. For example, between two cell types, clone groups, TCR clusters or clinical groups. MarkersFinder : Find markers (differentially expressed genes) for any two groups, including clones or clone groups. MetaMarkers : Find meta markers for more than 2 clones or clone groups and perform enrichment analysis. Metabolic landscape analyses \u00b6 ScrnaMetabolicLandscape : A group of folowwing processes to perform metabolic landscape analyses. MetabolicInput : Prepare the input files for metabolic landscape analyses. MetabolicExprImpution : Impute the dropout values in the expression matrix. MetabolicPathwayActivity : Investigate the metabolic pathways of the cells in different groups and subsets. MetabolicPathwayHeterogeneity : Show metabolic pathways enriched in genes with highest contribution to the metabolic heterogeneities. MetabolicFeatures : Perform gene set enrichment analysis against the metabolic pathways for groups in different subsets. MetabolicFeaturesIntraSubset : Perform gene set enrichment analysis against the metabolic pathways for subsets based on the designed comparison in different groups. Routes of the pipeline \u00b6 immunopipe is designed to be flexible. It can be used in different ways. Here we list some common routes of the pipeline: Both scRNA-seq and scTCR-seq data avaiable \u00b6 To enable this route, you need to: tell the pipeline that scTCR-seq data is available by adding a column named TCRData in the sample information file. put the path of the sample information file in the configuration file [SampleInfo.in.infile] , instead of passing it as a command line argument ( --Sample.in.infile ). Unsupervised clustering [SeuratClustering] on selected T cells is the default setting. If you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If so, SeuratClustering will be replaced by SeuratMap2Ref in the pipeline. If you need to select T cells from all cells available for later analyses, you need to add [TCellSelection] in the configuration file. If so, the processes annotated as For T cell selection will be added to the pipeline. This is the most common route of the pipeline: The optional processes are enabled only when the corresponding sections are added in the configuration file. For example, if you want to add module scores (e.g. cell activation score) to the Seurat object, you need to add [ModuleScoreCalculator] in the configuration file. Only scRNA-seq data avaiable \u00b6 When you have only scRNA-seq data, you just don't need to add the TCRData column in the sample information file. The pipeline will automatically skip the processes related to scTCR-seq data analysis. Attention You need to specify the sample information file in the configuration file [SampleInfo.in.infile] to enable this route. Passing the sample information file as a command line argument ( --Sample.in.infile ) does not trigger this route. Unsupervised clustering [SeuratClustering] on selected T cells is the default setting. If you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If so, SeuratClustering will be replaced by SeuratMap2Ref in the pipeline. If you need to select T cells from all cells available for later analyses, you need to add [TCellSelection] in the configuration file. If so, the processes annotated as For T cell selection will be added to the pipeline.","title":"Introduction"},{"location":"introduction/#introduction","text":"","title":"Introduction"},{"location":"introduction/#the-pipeline-architecture","text":"immunopipe is built upon pipen . It is recommended to read the pipen docs first to get a better understanding of the pipeline. Here, we just want to highlight some concepts that are helpful to use the pipeline as a user. A process is a unit of work in the pipeline. immunopipe includes a set of processes. Some of them are reused from biopipen and some are written specifically for immunopipe . The input of a process is typically a pandas DataFrame , which serves as the channel passing data between processes. The rows of the data frame are distributed to the jobs of the process, and columns are spreaded to the input variables of the job s. See more illustration here . In our case, most processes are just single-job processes. Other than the start processes, the input of a process is the output of other process(es). So users don't need to worry about the input of the processes in the configurations. envs of a process is the most important part of immunopipe that a user needs to configure. It defines the environment variables of the process. The environment variables are shared by all the jobs of the process. Attention These environment variables are not the same as the environment variables of the system. They are just variables that are used in the process across its jobs. See individual process pages for more details about the envs of each process.","title":"The pipeline architecture"},{"location":"introduction/#analyses-and-processes","text":"As shown in the figure above, immunopipe includes a set of processes for scTCR- and scRNA-seq data analysis. The processes are grouped into categories below:","title":"Analyses and processes"},{"location":"introduction/#data-input-and-qc","text":"SampleInfo : Read sample information from a CSV file and list the sample information in the report. ImmunarchLoading : Load the data into immunarch objects. SeuratPreparing : Read the data into Seurat objects and perform QC.","title":"Data input and QC"},{"location":"introduction/#t-cell-selection","text":"SeuratClusteringOfAllCells : Perform clustering on all cells if non-T cells are present in the data. ClusterMarkersOfAllCells : Find markers for each cluster of all the cells and perform enrichment analysis. TopExpressingGenesOfAllCells : Find top expressing genes for each cluster of all the cells and perform enrichment analysis. TCellSelection : Select T cells from all cells.","title":"T cell selection"},{"location":"introduction/#clustering-of-t-cells","text":"SeuratClustering : Perform clustering on all or T cells selected above. SeuratMap2Ref : Map the cells to a reference dataset. CellTypeAnnotation : Annotate cell types for each T-cell cluster. SeuratSubClustering : Perform sub-clustering on subsets of cells. ClusterMarkers : Find markers for each T-cell cluster and perform enrichment analysis. TopExpressingGenes : Find top expressing genes for each T-cell cluster and perform enrichment analysis. ModuleScoreCalculator : Calculate module scores or cell cycle scores for each cell.","title":"Clustering of T cells"},{"location":"introduction/#tcr-data-analyses","text":"CloneResidency : Explore the residency of TCR clones for paired samples (e.g. tumor vs blood) from the same patient. TCRClustering : Perform clustering on TCR clones based on CDR3 amino acid sequences. TCRClusterStats : Investigate statistics for TCR clusters (i.e. TCR cluster size distribution, shared TCR clusters among samples, revisited sample diversity using TCR clusters instead of clonotypes, etc.) Immunarch : Perform TCR clonotype analyses using immunarch package.","title":"TCR data analyses"},{"location":"introduction/#integrative-analyses","text":"TESSA : Perform integrative analyses using Tessa . SeuratClusterStats : Investigate statistics for each T-cell cluster (i.e. the number of cells in each cluster, the number of cells in each sample for each cluster, feature/gene expression visualization, dimension reduction plots, etc.). It's also possible to perform stats on TCR clones/clusters for each T-cell cluster. IntegratingTCRClusters : Attach TCR clusters to Seurat objects. IntegratingTCR : Integrate TCR data into Seurat objects. RadarPlots : Visualize proportion of cells in different groups for each cluster. CellsDistribution : Investigate the distribution of cells in different groups for each T-cell cluster. CDR3AAPhyschem : Investigate the physicochemical properties of CDR3 amino acid sequences of one cell type over another (i.e. Treg vs Tconv ). ScFGSEA : Perform GSEA analysis for comparisons between two groups of cells. For example, between two cell types, clone groups, TCR clusters or clinical groups. MarkersFinder : Find markers (differentially expressed genes) for any two groups, including clones or clone groups. MetaMarkers : Find meta markers for more than 2 clones or clone groups and perform enrichment analysis.","title":"Integrative analyses"},{"location":"introduction/#metabolic-landscape-analyses","text":"ScrnaMetabolicLandscape : A group of folowwing processes to perform metabolic landscape analyses. MetabolicInput : Prepare the input files for metabolic landscape analyses. MetabolicExprImpution : Impute the dropout values in the expression matrix. MetabolicPathwayActivity : Investigate the metabolic pathways of the cells in different groups and subsets. MetabolicPathwayHeterogeneity : Show metabolic pathways enriched in genes with highest contribution to the metabolic heterogeneities. MetabolicFeatures : Perform gene set enrichment analysis against the metabolic pathways for groups in different subsets. MetabolicFeaturesIntraSubset : Perform gene set enrichment analysis against the metabolic pathways for subsets based on the designed comparison in different groups.","title":"Metabolic landscape analyses"},{"location":"introduction/#routes-of-the-pipeline","text":"immunopipe is designed to be flexible. It can be used in different ways. Here we list some common routes of the pipeline:","title":"Routes of the pipeline"},{"location":"introduction/#both-scrna-seq-and-sctcr-seq-data-avaiable","text":"To enable this route, you need to: tell the pipeline that scTCR-seq data is available by adding a column named TCRData in the sample information file. put the path of the sample information file in the configuration file [SampleInfo.in.infile] , instead of passing it as a command line argument ( --Sample.in.infile ). Unsupervised clustering [SeuratClustering] on selected T cells is the default setting. If you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If so, SeuratClustering will be replaced by SeuratMap2Ref in the pipeline. If you need to select T cells from all cells available for later analyses, you need to add [TCellSelection] in the configuration file. If so, the processes annotated as For T cell selection will be added to the pipeline. This is the most common route of the pipeline: The optional processes are enabled only when the corresponding sections are added in the configuration file. For example, if you want to add module scores (e.g. cell activation score) to the Seurat object, you need to add [ModuleScoreCalculator] in the configuration file.","title":"Both scRNA-seq and scTCR-seq data avaiable"},{"location":"introduction/#only-scrna-seq-data-avaiable","text":"When you have only scRNA-seq data, you just don't need to add the TCRData column in the sample information file. The pipeline will automatically skip the processes related to scTCR-seq data analysis. Attention You need to specify the sample information file in the configuration file [SampleInfo.in.infile] to enable this route. Passing the sample information file as a command line argument ( --Sample.in.infile ) does not trigger this route. Unsupervised clustering [SeuratClustering] on selected T cells is the default setting. If you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If so, SeuratClustering will be replaced by SeuratMap2Ref in the pipeline. If you need to select T cells from all cells available for later analyses, you need to add [TCellSelection] in the configuration file. If so, the processes annotated as For T cell selection will be added to the pipeline.","title":"Only scRNA-seq data avaiable"},{"location":"preparing-input/","text":"Preparing the input data \u00b6 Single-cell RNA-seq (scRNA-seq) data \u00b6 Currently only 10X Genomics data are supported. For each sample, you need to provide a directory containing the files that are generated by CellRanger . Specifically, the directory should be able to be read by Seurat::Read_10X() . For example, the directory should contain matrix.mtx , barcodes.tsv and features.tsv . These files can also be gzipped. You can also use the h5 file generated by CellRanger . Single-cell TCR-seq (scTCR-seq) data \u00b6 The scRNA-seq data is optional for the pipeline. However, the scTCR-seq data is required for the pipeline. The scTCR-seq data, if available, should be paired with the scRNA-seq data. Theoratically, as long as the data can be loaded by immunarch::repLoad() , it should be fine. However, the pipeline is only tested with the data generated by CellRanger . Specifically, the directory should contain filtered_contig_annotations.csv file, or at least the all_contig_annotations.csv file. Metadata \u00b6 A metadata file is required as an input file for the pipeline. It should be a TAB delimited file with 3 required columns: Sample : A unique id for each sample RNAData : The directory or h5 file for single-cell RNA data for this sample, as described above. TCRData (optional): The directory for single-cell TCR data for this sample as described above. When TCRData is not provided, the pipeline will skip the processes related to scTCR-seq data (see Routes of the pipeline for more details). You can also add other columns to the metadata file. The columns will be added to both: meta data of the object loaded by immunarch::repLoad() (i.e. data$meta ) meta data of the seurat object loaded by Seurat::Read10X() or Seurat::Read10X_h5() (i.e. srtobj@meta.data ) This file should be provided to SampleInfo process. See SampleInfo for more details. An example metadata file can be found here . You can also use SampleInfo with envs.save_mutated = true and/or IntegratingTCR to add columns to metadata by configuration. These columns are persisted for downstream analysis. The difference is that SampleInfo can only use the columns that are already in the metadata file, while IntegratingTCR can use the columns that are generated by the pipeline (e.g. TCR clone information). Other optional files \u00b6 Genes/Features to visualize for Seurat object \u00b6 If you have a set of genes/features of interest, you can provide a file with those genes, one gene per line, to SeuratClusterStats.envs.exprs.features for: Ridge plots using Seurat::RidgePlot() , Violin plots using Seurat::VlnPlot() , Feature plots using Seurat::FeaturePlot() , Dot plots using Seurat::DotPlot() , and Heatmaps using Seurat::DoHeatmap() . Note The genes should exist in the RNA-seq data (i.e features.tsv or the h5 file from cellranger). See SeuratClusterStats for more details. Pathways for Gene Set Enrichment Analysis (GSEA) \u00b6 If you want to perform GSEA, you need to provide a file containing the pathways. The file should be in the GMT format . You can provide the file to ScFGSEA.envs.gmtfile . Similarly, the genes should exist (be in the same format) in the features.tsv file. See ScFGSEA for more details. You can also find an example here: https://github.com/pwwang/immunopipe-example/blob/master/data/MSigDB_Hallmark_v7.5.1.gmt Cell type database for cell type annotation by sctype or hitype \u00b6 If you want to perform cell type annotation, you need to provide a file containing the cell type database if you are using sctype or hitype . The database file should be fed to CellTypeAnnotation.envs.sctype_db if you are using sctype , or CellTypeAnnotation.envs.hitype_db if you are using hitype . Again, the markers in the database should exist (be in the same format) in the features.tsv file or the h5 file. See CellTypeAnnotation for more details. Examples can be found here: ScTypeDB_short.xlsx and ScTypeDB_full.xlsx . Model for cell type annotation by celltypist \u00b6 If you want to perform cell type annotation by celltypist , you need to provide a model file. The model file should be fed to CellTypeAnnotation.envs.celltypist_args.model . The information of models can be found here . Download the one you want to use and provide the path to the file. Metabolic pathway for Metabolic Landscape Analysis \u00b6 Similarly, if you want to perform metabolic landscape analysis, you need to provide a file containing the metabolic pathways. The file should be in the GMT format . You can provide the file to ScMetabolicLandscape.envs.gmtfile . This file can also be used for GSEA. A pathway file for KEGG metabolism is provided here . See ScrnaMetabolicLandscape for more details. Reference for Seurat mapping if you want to perform supervised clustering \u00b6 If you want to perform supervised clustering, you need to provide a reference for SeuratMap2Ref . The reference should be a Seurat object in RDS or h5seurat file. You can provide the reference to SeuratMap2Ref.envs.ref . See SeuratMap2Ref for more details.","title":"Preparing the input"},{"location":"preparing-input/#preparing-the-input-data","text":"","title":"Preparing the input data"},{"location":"preparing-input/#single-cell-rna-seq-scrna-seq-data","text":"Currently only 10X Genomics data are supported. For each sample, you need to provide a directory containing the files that are generated by CellRanger . Specifically, the directory should be able to be read by Seurat::Read_10X() . For example, the directory should contain matrix.mtx , barcodes.tsv and features.tsv . These files can also be gzipped. You can also use the h5 file generated by CellRanger .","title":"Single-cell RNA-seq (scRNA-seq) data"},{"location":"preparing-input/#single-cell-tcr-seq-sctcr-seq-data","text":"The scRNA-seq data is optional for the pipeline. However, the scTCR-seq data is required for the pipeline. The scTCR-seq data, if available, should be paired with the scRNA-seq data. Theoratically, as long as the data can be loaded by immunarch::repLoad() , it should be fine. However, the pipeline is only tested with the data generated by CellRanger . Specifically, the directory should contain filtered_contig_annotations.csv file, or at least the all_contig_annotations.csv file.","title":"Single-cell TCR-seq (scTCR-seq) data"},{"location":"preparing-input/#metadata","text":"A metadata file is required as an input file for the pipeline. It should be a TAB delimited file with 3 required columns: Sample : A unique id for each sample RNAData : The directory or h5 file for single-cell RNA data for this sample, as described above. TCRData (optional): The directory for single-cell TCR data for this sample as described above. When TCRData is not provided, the pipeline will skip the processes related to scTCR-seq data (see Routes of the pipeline for more details). You can also add other columns to the metadata file. The columns will be added to both: meta data of the object loaded by immunarch::repLoad() (i.e. data$meta ) meta data of the seurat object loaded by Seurat::Read10X() or Seurat::Read10X_h5() (i.e. srtobj@meta.data ) This file should be provided to SampleInfo process. See SampleInfo for more details. An example metadata file can be found here . You can also use SampleInfo with envs.save_mutated = true and/or IntegratingTCR to add columns to metadata by configuration. These columns are persisted for downstream analysis. The difference is that SampleInfo can only use the columns that are already in the metadata file, while IntegratingTCR can use the columns that are generated by the pipeline (e.g. TCR clone information).","title":"Metadata"},{"location":"preparing-input/#other-optional-files","text":"","title":"Other optional files"},{"location":"preparing-input/#genesfeatures-to-visualize-for-seurat-object","text":"If you have a set of genes/features of interest, you can provide a file with those genes, one gene per line, to SeuratClusterStats.envs.exprs.features for: Ridge plots using Seurat::RidgePlot() , Violin plots using Seurat::VlnPlot() , Feature plots using Seurat::FeaturePlot() , Dot plots using Seurat::DotPlot() , and Heatmaps using Seurat::DoHeatmap() . Note The genes should exist in the RNA-seq data (i.e features.tsv or the h5 file from cellranger). See SeuratClusterStats for more details.","title":"Genes/Features to visualize for Seurat object"},{"location":"preparing-input/#pathways-for-gene-set-enrichment-analysis-gsea","text":"If you want to perform GSEA, you need to provide a file containing the pathways. The file should be in the GMT format . You can provide the file to ScFGSEA.envs.gmtfile . Similarly, the genes should exist (be in the same format) in the features.tsv file. See ScFGSEA for more details. You can also find an example here: https://github.com/pwwang/immunopipe-example/blob/master/data/MSigDB_Hallmark_v7.5.1.gmt","title":"Pathways for Gene Set Enrichment Analysis (GSEA)"},{"location":"preparing-input/#cell-type-database-for-cell-type-annotation-by-sctype-or-hitype","text":"If you want to perform cell type annotation, you need to provide a file containing the cell type database if you are using sctype or hitype . The database file should be fed to CellTypeAnnotation.envs.sctype_db if you are using sctype , or CellTypeAnnotation.envs.hitype_db if you are using hitype . Again, the markers in the database should exist (be in the same format) in the features.tsv file or the h5 file. See CellTypeAnnotation for more details. Examples can be found here: ScTypeDB_short.xlsx and ScTypeDB_full.xlsx .","title":"Cell type database for cell type annotation by sctype or hitype"},{"location":"preparing-input/#model-for-cell-type-annotation-by-celltypist","text":"If you want to perform cell type annotation by celltypist , you need to provide a model file. The model file should be fed to CellTypeAnnotation.envs.celltypist_args.model . The information of models can be found here . Download the one you want to use and provide the path to the file.","title":"Model for cell type annotation by celltypist"},{"location":"preparing-input/#metabolic-pathway-for-metabolic-landscape-analysis","text":"Similarly, if you want to perform metabolic landscape analysis, you need to provide a file containing the metabolic pathways. The file should be in the GMT format . You can provide the file to ScMetabolicLandscape.envs.gmtfile . This file can also be used for GSEA. A pathway file for KEGG metabolism is provided here . See ScrnaMetabolicLandscape for more details.","title":"Metabolic pathway for Metabolic Landscape Analysis"},{"location":"preparing-input/#reference-for-seurat-mapping-if-you-want-to-perform-supervised-clustering","text":"If you want to perform supervised clustering, you need to provide a reference for SeuratMap2Ref . The reference should be a Seurat object in RDS or h5seurat file. You can provide the reference to SeuratMap2Ref.envs.ref . See SeuratMap2Ref for more details.","title":"Reference for Seurat mapping if you want to perform supervised clustering"},{"location":"running/","text":"Running the pipeline \u00b6 Run the pipeline locally via CLI \u00b6 Once the pipeline is installed, you can run it via CLI: $ immunopipe --help You can specify the options directly in the CLI. For example: $ immunopipe --forks 4 --TopExpressingGenes.envs.n 100 ... It's recommended to use a configuration file to specify all the options. For example: $ immunopipe @config.toml You can also use both ways together. The options specified in the CLI will override the ones in the configuration file. $ immunopipe @config.toml --forks 4 --TopExpressingGenes.envs.n 100 ... For configuration items, see configurations for more details. Tip If you want to run the pipeline on a cluster, see How to run the pipeline on a cluster? for more details. Attention For settings that determine the routes of the pipeline, you should define them in the configuration file. For example, if you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If you just pass the section as a command line argument ( --SeuratMap2Ref ), it will not trigger the corresponding processes. To indicator whether the scTCR-seq data is available or not, you also need to specify the sample information file in the configuration file [SampleInfo.in.infile] . Passing the sample information file as a command line argument ( --Sample.in.infile ) does not trigger the corresponding processes. See Routes of the pipeline for more details. Run the pipeline via pipen-board \u00b6 pipen-board is a web-based dashboard for pipen . It provides a user-friendly interface to configure and run the pipeline. It also provides a way to monitor the running progress of the pipeline. pipen-board is installed by default with immunopipe . You can run it via CLI: $ pipen board immunopipe:Immunopipe * * __ __ __. . __ __ + __ __ * | __ )|| __ ) | _ | \\ | __ | __ ) / \\ / \\ | __ ) | \\ * | || | __ | \\| | __ ) \\_ _//-- \\| \\ | __/ * * version: 0 .11.1 * * Configure and run pipen pipelines from the web * * Serving Quart app 'pipen_board' * Environment: development * Debug mode: True * Running on http://0.0.0.0:18521 ( CTRL + C to quit ) [ 07 /31/23 21 :23:27 ] INFO Running on http://0.0.0.0:18521 ( CTRL + C to quit ) Then you can open the dashboard in your browser at http://localhost:18521 . In the Configuration tab, you can configure the pipeline and the processes. Then you can use the Generate Configuration button to generate the configuration file and then use the generated configuration file to run the pipeline via CLI. If you want to run the pipeline via pipen-board , you need an additional configuration file to tell pipen-board how to run the pipeline: $ pipen board immunopipe:Immunopipe -a gh:pwwang/immunopipe/board.toml@dev The additional file is available at immunopipe 's GitHub repo. You can also download it and modify it to fit your needs, but in most cases, you don't have to. With the additional file, you can find four running options , LOCAL , DOCKER , SINGULARITY and APPTAINER , on the left side of the Configuration tab. You can choose one of them to run the pipeline. Take LOCAL as an example. When clicking the Run the command button, a configuration file specified by configfile is saved and used to run the pipeline via CLI. Then the Previous Run tab is replaced by the Running tab to track the progress of the pipeline. Run the pipeline using docker image \u00b6 Choose the right tag of the docker image \u00b6 The docker image is tagged with the version of immunopipe , together with master and dev . They are listed here: https://hub.docker.com/repository/docker/justold/immunopipe/tags . dev is the latest development version of immunopipe . It may have unstable features. If you want to use a more stable version, please try master , or a specific semantic version. Any tags with a -full suffix are the full version of the image. It contains all the dependencies of the pipeline, especially keras and tensorflow that are required by the embedding procedure of TESSA . Those packages take quite a lot of the space of the image. If you don't need the TESSA process, you can use the minimal version of the image. Any tags without the -full suffix are the minimal version of the image. TESSA process is also NOT supported in the minimal version. keras and tensorflow are also NOT included in the image. Please also keep in mind that there is no GPU support with either type of the image. You can pull the images in advance using docker , singularity or apptainer . See help options of docker pull , singularity pull or apptainer pull for more details. You can also specify the tag when running the pipeline. See the following sections for more details. Using docker Using singularity Using apptainer To run the pipeline using the docker image with docker , you need to mount the current working directory to the /workdir directory in the container. You also need to specify the configuration file via @<configfile> option. For example: $ docker run \\ --rm -w /workdir -v .:/workdir -v /tmp:/tmp \\ justold/immunopipe:<tag> \\ @config.toml You also need to mount the current working directory to the /workdir directory in the container if you are using singularity . You also need to specify the configuration file via @<configfile> option. For example: $ singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:<tag> \\ @config.toml You also need to mount the current working directory to the /workdir directory in the container if you are using apptainer . You also need to specify the configuration file via @<configfile> option. For example: $ apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:<tag> \\ @config.toml Run the pipeline via pipen-board using docker image \u00b6 Using docker Using singularity Using apptainer You can also run the pipeline via pipen-board using the docker image with docker : $ docker run -p 18521 :18521 \\ --rm -w /workdir -v .:/workdir -v /tmp:/tmp \\ justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml The under the running options , choose LOCAL to run the pipeline. Note You should use LOCAL instead of DOCKER to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the docker container. You can also run the pipeline via pipen-board using the docker image with singularity : $ singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml The under the running options , choose LOCAL to run the pipeline. Similarly, you should use LOCAL instead of SINGULARITY to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the container. You can also run the pipeline via pipen-board using the docker image with apptainer : $ apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml Also similarly, you should use LOCAL instead of APPTAINER to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the container. When the command is running, you will see the following message: Then, You can open the dashboard in your browser at http://localhost:18521 .","title":"Running the pipeline"},{"location":"running/#running-the-pipeline","text":"","title":"Running the pipeline"},{"location":"running/#run-the-pipeline-locally-via-cli","text":"Once the pipeline is installed, you can run it via CLI: $ immunopipe --help You can specify the options directly in the CLI. For example: $ immunopipe --forks 4 --TopExpressingGenes.envs.n 100 ... It's recommended to use a configuration file to specify all the options. For example: $ immunopipe @config.toml You can also use both ways together. The options specified in the CLI will override the ones in the configuration file. $ immunopipe @config.toml --forks 4 --TopExpressingGenes.envs.n 100 ... For configuration items, see configurations for more details. Tip If you want to run the pipeline on a cluster, see How to run the pipeline on a cluster? for more details. Attention For settings that determine the routes of the pipeline, you should define them in the configuration file. For example, if you want to perform supervised clustering, you need to add [SeuratMap2Ref] in the configuration file with necessary parameters. If you just pass the section as a command line argument ( --SeuratMap2Ref ), it will not trigger the corresponding processes. To indicator whether the scTCR-seq data is available or not, you also need to specify the sample information file in the configuration file [SampleInfo.in.infile] . Passing the sample information file as a command line argument ( --Sample.in.infile ) does not trigger the corresponding processes. See Routes of the pipeline for more details.","title":"Run the pipeline locally via CLI"},{"location":"running/#run-the-pipeline-via-pipen-board","text":"pipen-board is a web-based dashboard for pipen . It provides a user-friendly interface to configure and run the pipeline. It also provides a way to monitor the running progress of the pipeline. pipen-board is installed by default with immunopipe . You can run it via CLI: $ pipen board immunopipe:Immunopipe * * __ __ __. . __ __ + __ __ * | __ )|| __ ) | _ | \\ | __ | __ ) / \\ / \\ | __ ) | \\ * | || | __ | \\| | __ ) \\_ _//-- \\| \\ | __/ * * version: 0 .11.1 * * Configure and run pipen pipelines from the web * * Serving Quart app 'pipen_board' * Environment: development * Debug mode: True * Running on http://0.0.0.0:18521 ( CTRL + C to quit ) [ 07 /31/23 21 :23:27 ] INFO Running on http://0.0.0.0:18521 ( CTRL + C to quit ) Then you can open the dashboard in your browser at http://localhost:18521 . In the Configuration tab, you can configure the pipeline and the processes. Then you can use the Generate Configuration button to generate the configuration file and then use the generated configuration file to run the pipeline via CLI. If you want to run the pipeline via pipen-board , you need an additional configuration file to tell pipen-board how to run the pipeline: $ pipen board immunopipe:Immunopipe -a gh:pwwang/immunopipe/board.toml@dev The additional file is available at immunopipe 's GitHub repo. You can also download it and modify it to fit your needs, but in most cases, you don't have to. With the additional file, you can find four running options , LOCAL , DOCKER , SINGULARITY and APPTAINER , on the left side of the Configuration tab. You can choose one of them to run the pipeline. Take LOCAL as an example. When clicking the Run the command button, a configuration file specified by configfile is saved and used to run the pipeline via CLI. Then the Previous Run tab is replaced by the Running tab to track the progress of the pipeline.","title":"Run the pipeline via pipen-board"},{"location":"running/#run-the-pipeline-using-docker-image","text":"","title":"Run the pipeline using docker image"},{"location":"running/#choose-the-right-tag-of-the-docker-image","text":"The docker image is tagged with the version of immunopipe , together with master and dev . They are listed here: https://hub.docker.com/repository/docker/justold/immunopipe/tags . dev is the latest development version of immunopipe . It may have unstable features. If you want to use a more stable version, please try master , or a specific semantic version. Any tags with a -full suffix are the full version of the image. It contains all the dependencies of the pipeline, especially keras and tensorflow that are required by the embedding procedure of TESSA . Those packages take quite a lot of the space of the image. If you don't need the TESSA process, you can use the minimal version of the image. Any tags without the -full suffix are the minimal version of the image. TESSA process is also NOT supported in the minimal version. keras and tensorflow are also NOT included in the image. Please also keep in mind that there is no GPU support with either type of the image. You can pull the images in advance using docker , singularity or apptainer . See help options of docker pull , singularity pull or apptainer pull for more details. You can also specify the tag when running the pipeline. See the following sections for more details. Using docker Using singularity Using apptainer To run the pipeline using the docker image with docker , you need to mount the current working directory to the /workdir directory in the container. You also need to specify the configuration file via @<configfile> option. For example: $ docker run \\ --rm -w /workdir -v .:/workdir -v /tmp:/tmp \\ justold/immunopipe:<tag> \\ @config.toml You also need to mount the current working directory to the /workdir directory in the container if you are using singularity . You also need to specify the configuration file via @<configfile> option. For example: $ singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:<tag> \\ @config.toml You also need to mount the current working directory to the /workdir directory in the container if you are using apptainer . You also need to specify the configuration file via @<configfile> option. For example: $ apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:<tag> \\ @config.toml","title":"Choose the right tag of the docker image"},{"location":"running/#run-the-pipeline-via-pipen-board-using-docker-image","text":"Using docker Using singularity Using apptainer You can also run the pipeline via pipen-board using the docker image with docker : $ docker run -p 18521 :18521 \\ --rm -w /workdir -v .:/workdir -v /tmp:/tmp \\ justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml The under the running options , choose LOCAL to run the pipeline. Note You should use LOCAL instead of DOCKER to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the docker container. You can also run the pipeline via pipen-board using the docker image with singularity : $ singularity run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --writable-tmpfs \\ docker://justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml The under the running options , choose LOCAL to run the pipeline. Similarly, you should use LOCAL instead of SINGULARITY to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the container. You can also run the pipeline via pipen-board using the docker image with apptainer : $ apptainer run \\ --pwd /workdir -B .:/workdir,/tmp -c -e --unsquash --writable-tmpfs \\ docker://justold/immunopipe:<tag> board \\ immunopipe:Immunopipe \\ -a /immunopipe/board.toml Also similarly, you should use LOCAL instead of APPTAINER to run the pipeline. Otherwise, the pipeline will be run in a docker container inside the container. When the command is running, you will see the following message: Then, You can open the dashboard in your browser at http://localhost:18521 .","title":"Run the pipeline via pipen-board using docker image"},{"location":"processes/CDR3AAPhyschem/","text":"CDR3AAPhyschem \u00b6 CDR3 AA physicochemical feature analysis The idea is to perform a regression between two groups of cells (e.g. Treg vs Tconv) at different length of CDR3 AA sequences. The regression will be performed for each physicochemical feature of the AA (hydrophobicity, volume and isolectric point). Input \u00b6 immdata : The data loaded by immunarch::repLoad() , saved in RDS format srtobj : The Seurat object, saved in RDS format, used to get the metadata for each cell (e.g. cell type) It could also be a tab delimited file with meta.data of the Seurat object. It has to have a Sample column, which is used to match the immdata object. It is optional, if not provided, the metadata from the immdata object will be used. Output \u00b6 outdir : Default: {{in.immdata | stem}}.cdr3aaphyschem . The output directory Environment Variables \u00b6 group : The key of group in metadata to define the groups to compare. For example, CellType , which has cell types annotated for each cell in the combined object (immdata + Seurat metadata) comparison ( type=json ) : A dict of two groups, with keys as the group names and values as the group labels. For example, Treg = [ \"CD4 CTL\" , \"CD4 Naive\" , \"CD4 TCM\" , \"CD4 TEM\" ] Tconv = \"Tconv\" prefix : Default: {Sample}_ . The prefix of the cell names (rownames) in the metadata. The prefix is usually not needed in immdata, as the data is stored in the immdata object separately for each sample. However, the Seurat object has a combined meta.data for all the samples, so the prefix is needed. Usually, the prefix is the sample name. For example, Sample1-AACGTTGAGGCTACGT-1 . We need this prefix to add the sample name to the cell names in immdata, so that we can match the cells in immdata and Seurat object. Set it to None or an empty string if the Seurat object has the same cell names as immdata . You can use placeholders to specify the prefix, e.g., {Sample}_ . In such a case, the Sample column must exist in the Seurat object. target : Which group to use as the target group. The target group will be labeled as 1, and the other group will be labeled as 0 in the regression. subset : A column, or a list of columns separated by comma, in the merged object to subset the cells to perform the regression, for each group in the columns. If not provided, all the cells will be used. Reference \u00b6 Stadinski, Brian D., et al. \"Hydrophobic CDR3 residues promote the development of self-reactive T cells.\" Nature immunology 17.8 (2016): 946-955. Lagattuta, Kaitlyn A., et al. \"Repertoire analyses reveal T cell antigen receptor sequence features that influence T cell fate.\" Nature immunology 23.3 (2022): 446-457. Wimley, W. C. & White, S. H. Experimentally determined hydrophobicity scale for proteins at membrane - interfaces. Nat. Struct. Biol. 3, 842-848 (1996). Handbook of chemistry & physics 72nd edition. (CRC Press, 1991). Zamyatnin, A. A. Protein volume in solution. Prog. Biophys. Mol. Biol. 24, 107-123 (1972).","title":"CDR3AAPhyschem"},{"location":"processes/CDR3AAPhyschem/#cdr3aaphyschem","text":"CDR3 AA physicochemical feature analysis The idea is to perform a regression between two groups of cells (e.g. Treg vs Tconv) at different length of CDR3 AA sequences. The regression will be performed for each physicochemical feature of the AA (hydrophobicity, volume and isolectric point).","title":"CDR3AAPhyschem"},{"location":"processes/CDR3AAPhyschem/#input","text":"immdata : The data loaded by immunarch::repLoad() , saved in RDS format srtobj : The Seurat object, saved in RDS format, used to get the metadata for each cell (e.g. cell type) It could also be a tab delimited file with meta.data of the Seurat object. It has to have a Sample column, which is used to match the immdata object. It is optional, if not provided, the metadata from the immdata object will be used.","title":"Input"},{"location":"processes/CDR3AAPhyschem/#output","text":"outdir : Default: {{in.immdata | stem}}.cdr3aaphyschem . The output directory","title":"Output"},{"location":"processes/CDR3AAPhyschem/#environment-variables","text":"group : The key of group in metadata to define the groups to compare. For example, CellType , which has cell types annotated for each cell in the combined object (immdata + Seurat metadata) comparison ( type=json ) : A dict of two groups, with keys as the group names and values as the group labels. For example, Treg = [ \"CD4 CTL\" , \"CD4 Naive\" , \"CD4 TCM\" , \"CD4 TEM\" ] Tconv = \"Tconv\" prefix : Default: {Sample}_ . The prefix of the cell names (rownames) in the metadata. The prefix is usually not needed in immdata, as the data is stored in the immdata object separately for each sample. However, the Seurat object has a combined meta.data for all the samples, so the prefix is needed. Usually, the prefix is the sample name. For example, Sample1-AACGTTGAGGCTACGT-1 . We need this prefix to add the sample name to the cell names in immdata, so that we can match the cells in immdata and Seurat object. Set it to None or an empty string if the Seurat object has the same cell names as immdata . You can use placeholders to specify the prefix, e.g., {Sample}_ . In such a case, the Sample column must exist in the Seurat object. target : Which group to use as the target group. The target group will be labeled as 1, and the other group will be labeled as 0 in the regression. subset : A column, or a list of columns separated by comma, in the merged object to subset the cells to perform the regression, for each group in the columns. If not provided, all the cells will be used.","title":"Environment Variables"},{"location":"processes/CDR3AAPhyschem/#reference","text":"Stadinski, Brian D., et al. \"Hydrophobic CDR3 residues promote the development of self-reactive T cells.\" Nature immunology 17.8 (2016): 946-955. Lagattuta, Kaitlyn A., et al. \"Repertoire analyses reveal T cell antigen receptor sequence features that influence T cell fate.\" Nature immunology 23.3 (2022): 446-457. Wimley, W. C. & White, S. H. Experimentally determined hydrophobicity scale for proteins at membrane - interfaces. Nat. Struct. Biol. 3, 842-848 (1996). Handbook of chemistry & physics 72nd edition. (CRC Press, 1991). Zamyatnin, A. A. Protein volume in solution. Prog. Biophys. Mol. Biol. 24, 107-123 (1972).","title":"Reference"},{"location":"processes/CellTypeAnnotation/","text":"CellTypeAnnotation \u00b6 Annotate the T cell clusters. Annotate the cell clusters. Currently, four ways are supported: Pass the cell type annotation directly Use ScType Use scCATCH Use hitype The annotated cell types will replace the original seurat_clusters column in the metadata, so that the downstream processes will use the annotated cell types. The old seurat_clusters column will be renamed to seurat_clusters_id . If you are using ScType , scCATCH , or hitype , a text file containing the mapping from the old seurat_clusters to the new cell types will be generated and saved to cluster2celltype.tsv under <workdir>/<pipline_name>/CellTypeAnnotation/0/output/ . The <workdir> is typically ./.pipen and the <pipline_name> is Immunopipe by default. Note When supervised clustering SeuratMap2Ref is used, this process will be ignored. Note When cell types are annotated, the old seurat_clusters column will be renamed to seurat_clusters_id , and the new seurat_clusters column will be added. Input \u00b6 sobjfile : The seurat object Output \u00b6 outfile : Default: {{in.sobjfile | stem}}.annotated.{{- ext0(in.sobjfile) if envs.outtype == 'input' else envs.outtype -}} . The rds file of seurat object with cell type annotated Environment Variables \u00b6 tool ( choice ) : Default: direct . The tool to use for cell type annotation. sctype : Use scType to annotate cell types. See https://github.com/IanevskiAleksandr/sc-type hitype : Use hitype to annotate cell types. See https://github.com/pwwang/hitype sccatch : Use scCATCH to annotate cell types. See https://github.com/ZJUFanLab/scCATCH celltypist : Use celltypist to annotate cell types. See https://github.com/Teichlab/celltypist direct : Directly assign cell types sctype_tissue : The tissue to use for sctype . Avaiable tissues should be the first column ( tissueType ) of sctype_db . If not specified, all rows in sctype_db will be used. sctype_db : The database to use for sctype. Check examples at https://github.com/IanevskiAleksandr/sc-type/blob/master/ScTypeDB_full.xlsx hitype_tissue : The tissue to use for hitype . Avaiable tissues should be the first column ( tissueType ) of hitype_db . If not specified, all rows in hitype_db will be used. hitype_db : The database to use for hitype. Compatible with sctype_db . See also https://pwwang.github.io/hitype/articles/prepare-gene-sets.html You can also use built-in databases, including hitypedb_short , hitypedb_full , and hitypedb_pbmc3k . cell_types ( list ) : Default: [] . The cell types to use for direct annotation. You can use \"-\" or \"\" as the placeholder for the clusters that you want to keep the original cell types ( seurat_clusters ). If the length of cell_types is shorter than the number of clusters, the remaining clusters will be kept as the original cell types. You can also use NA to remove the clusters from downstream analysis. This only works when envs.newcol is not specified. Note If tool is direct and cell_types is not specified or an empty list, the original cell types will be kept and nothing will be changed. sccatch_args ( ns ) : The arguments for scCATCH::findmarkergene() if tool is sccatch . species : The specie of cells. cancer : Default: Normal . If the sample is from cancer tissue, then the cancer type may be defined. tissue : Tissue origin of cells must be defined. marker : The marker genes for cell type identification. if_use_custom_marker ( flag ) : Default: False . Whether to use custom marker genes. If True , no species , cancer , and tissue are needed. <more> : Other arguments for scCATCH::findmarkergene() . You can pass an RDS file to sccatch_args.marker to work as custom marker. If so, if_use_custom_marker will be set to TRUE automatically. celltypist_args ( ns ) : The arguments for celltypist::celltypist() if tool is celltypist . model : The path to model file. python : Default: python . The python path where celltypist is installed. majority_voting : Default: True . When true, it refines cell identities within local subclusters after an over-clustering approach at the cost of increased runtime. over_clustering ( type=auto ) : Default: seurat_clusters . The column name in metadata to use as clusters for majority voting. Set to False to disable over-clustering. assay : When converting a Seurat object to AnnData, the assay to use. If input is h5seurat, this defaults to RNA. If input is Seurat object in RDS, this defaults to the default assay. merge ( flag ) : Default: False . Whether to merge the clusters with the same cell types. Otherwise, a suffix will be added to the cell types (ie. .1 , .2 , etc). newcol : The new column name to store the cell types. If not specified, the seurat_clusters column will be overwritten. If specified, the original seurat_clusters column will be kept and Idents will be kept as the original seurat_clusters . outtype ( choice ) : Default: input . The output file type. Currently only works for celltypist . An RDS file will be generated for other tools. input : Use the same file type as the input. rds : Use RDS file. h5seurat : Use h5seurat file. h5ad : Use AnnData file. Examples \u00b6 [CellTypeAnnotation.envs] tool = \"direct\" cell_types = [ \"CellType1\" , \"CellType2\" , \"-\" , \"CellType4\" ] The cell types will be assigned as: 0 -> CellType1 1 -> CellType2 2 -> 2 3 -> CellType4 Metadata \u00b6 When envs.tool is direct and envs.cell_types is empty, the metadata of the Seurat object will be kept as is. When envs.newcol is specified, the original seurat_clusters column will be kept is, and the annotated cell types will be saved in the new column. Otherwise, the original seurat_clusters column will be replaced by the annotated cell types and the original seurat_clusters column will be saved at seurat_clusters_id .","title":"CellTypeAnnotation"},{"location":"processes/CellTypeAnnotation/#celltypeannotation","text":"Annotate the T cell clusters. Annotate the cell clusters. Currently, four ways are supported: Pass the cell type annotation directly Use ScType Use scCATCH Use hitype The annotated cell types will replace the original seurat_clusters column in the metadata, so that the downstream processes will use the annotated cell types. The old seurat_clusters column will be renamed to seurat_clusters_id . If you are using ScType , scCATCH , or hitype , a text file containing the mapping from the old seurat_clusters to the new cell types will be generated and saved to cluster2celltype.tsv under <workdir>/<pipline_name>/CellTypeAnnotation/0/output/ . The <workdir> is typically ./.pipen and the <pipline_name> is Immunopipe by default. Note When supervised clustering SeuratMap2Ref is used, this process will be ignored. Note When cell types are annotated, the old seurat_clusters column will be renamed to seurat_clusters_id , and the new seurat_clusters column will be added.","title":"CellTypeAnnotation"},{"location":"processes/CellTypeAnnotation/#input","text":"sobjfile : The seurat object","title":"Input"},{"location":"processes/CellTypeAnnotation/#output","text":"outfile : Default: {{in.sobjfile | stem}}.annotated.{{- ext0(in.sobjfile) if envs.outtype == 'input' else envs.outtype -}} . The rds file of seurat object with cell type annotated","title":"Output"},{"location":"processes/CellTypeAnnotation/#environment-variables","text":"tool ( choice ) : Default: direct . The tool to use for cell type annotation. sctype : Use scType to annotate cell types. See https://github.com/IanevskiAleksandr/sc-type hitype : Use hitype to annotate cell types. See https://github.com/pwwang/hitype sccatch : Use scCATCH to annotate cell types. See https://github.com/ZJUFanLab/scCATCH celltypist : Use celltypist to annotate cell types. See https://github.com/Teichlab/celltypist direct : Directly assign cell types sctype_tissue : The tissue to use for sctype . Avaiable tissues should be the first column ( tissueType ) of sctype_db . If not specified, all rows in sctype_db will be used. sctype_db : The database to use for sctype. Check examples at https://github.com/IanevskiAleksandr/sc-type/blob/master/ScTypeDB_full.xlsx hitype_tissue : The tissue to use for hitype . Avaiable tissues should be the first column ( tissueType ) of hitype_db . If not specified, all rows in hitype_db will be used. hitype_db : The database to use for hitype. Compatible with sctype_db . See also https://pwwang.github.io/hitype/articles/prepare-gene-sets.html You can also use built-in databases, including hitypedb_short , hitypedb_full , and hitypedb_pbmc3k . cell_types ( list ) : Default: [] . The cell types to use for direct annotation. You can use \"-\" or \"\" as the placeholder for the clusters that you want to keep the original cell types ( seurat_clusters ). If the length of cell_types is shorter than the number of clusters, the remaining clusters will be kept as the original cell types. You can also use NA to remove the clusters from downstream analysis. This only works when envs.newcol is not specified. Note If tool is direct and cell_types is not specified or an empty list, the original cell types will be kept and nothing will be changed. sccatch_args ( ns ) : The arguments for scCATCH::findmarkergene() if tool is sccatch . species : The specie of cells. cancer : Default: Normal . If the sample is from cancer tissue, then the cancer type may be defined. tissue : Tissue origin of cells must be defined. marker : The marker genes for cell type identification. if_use_custom_marker ( flag ) : Default: False . Whether to use custom marker genes. If True , no species , cancer , and tissue are needed. <more> : Other arguments for scCATCH::findmarkergene() . You can pass an RDS file to sccatch_args.marker to work as custom marker. If so, if_use_custom_marker will be set to TRUE automatically. celltypist_args ( ns ) : The arguments for celltypist::celltypist() if tool is celltypist . model : The path to model file. python : Default: python . The python path where celltypist is installed. majority_voting : Default: True . When true, it refines cell identities within local subclusters after an over-clustering approach at the cost of increased runtime. over_clustering ( type=auto ) : Default: seurat_clusters . The column name in metadata to use as clusters for majority voting. Set to False to disable over-clustering. assay : When converting a Seurat object to AnnData, the assay to use. If input is h5seurat, this defaults to RNA. If input is Seurat object in RDS, this defaults to the default assay. merge ( flag ) : Default: False . Whether to merge the clusters with the same cell types. Otherwise, a suffix will be added to the cell types (ie. .1 , .2 , etc). newcol : The new column name to store the cell types. If not specified, the seurat_clusters column will be overwritten. If specified, the original seurat_clusters column will be kept and Idents will be kept as the original seurat_clusters . outtype ( choice ) : Default: input . The output file type. Currently only works for celltypist . An RDS file will be generated for other tools. input : Use the same file type as the input. rds : Use RDS file. h5seurat : Use h5seurat file. h5ad : Use AnnData file.","title":"Environment Variables"},{"location":"processes/CellTypeAnnotation/#examples","text":"[CellTypeAnnotation.envs] tool = \"direct\" cell_types = [ \"CellType1\" , \"CellType2\" , \"-\" , \"CellType4\" ] The cell types will be assigned as: 0 -> CellType1 1 -> CellType2 2 -> 2 3 -> CellType4","title":"Examples"},{"location":"processes/CellTypeAnnotation/#metadata","text":"When envs.tool is direct and envs.cell_types is empty, the metadata of the Seurat object will be kept as is. When envs.newcol is specified, the original seurat_clusters column will be kept is, and the annotated cell types will be saved in the new column. Otherwise, the original seurat_clusters column will be replaced by the annotated cell types and the original seurat_clusters column will be saved at seurat_clusters_id .","title":"Metadata"},{"location":"processes/CellsDistribution/","text":"CellsDistribution \u00b6 Distribution of cells (i.e. in a TCR clone) from different groups for each cluster This generates a set of pie charts with proportion of cells in each cluster Rows are the cells identities (i.e. TCR clones or TCR clusters), columns are groups (i.e. clinic groups). Input \u00b6 srtobj : The seurat object in RDS format Output \u00b6 outdir : Default: {{in.srtobj | stem}}.cells_distribution . The output directory Environment Variables \u00b6 mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata Keys are the names of the mutaters and values are the R expressions passed by dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . cluster_orderby : The order of the clusters to show on the plot. An expression passed to dplyr::summarise() on the grouped data frame (by seurat_clusters ). The summary stat will be passed to dplyr::arrange() to order the clusters. It's applied on the whole meta.data before grouping and subsetting. For example, you can order the clusters by the activation score of the cluster: desc(mean(ActivationScore, na.rm = TRUE)) , suppose you have a column ActivationScore in the metadata. group_by : The column name in metadata to group the cells for the columns of the plot. group_order ( list ) : Default: [] . The order of the groups (columns) to show on the plot cells_by : The column name in metadata to group the cells for the rows of the plot. If your cell groups have overlapping cells, you can also use multiple columns, separated by comma ( , ). These columns will be concatenated to form the cell groups. For the overlapping cells, they will be counted multiple times for different groups. So make sure the cell group names in different columns are unique. cells_order ( list ) : Default: [] . The order of the cells (rows) to show on the plot cells_orderby : An expression passed to dplyr::arrange() to order the cells (rows) of the plot. Only works when cells-order is not specified. The data frame passed to dplyr::arrange() is grouped by cells_by before ordering. You can have multiple expressions separated by semicolon ( ; ). The expessions will be parsed by rlang::parse_exprs() . 4 extra columns were added to the metadata for ordering the rows in the plot: CloneSize : The size (number of cells) of clones (identified by cells_by ) CloneGroupSize : The clone size in each group (identified by group_by ) CloneClusterSize : The clone size in each cluster (identified by seurat_clusters ) CloneGroupClusterSize : The clone size in each group and cluster (identified by group_by and seurat_clusters ) cells_n ( type=int ) : Default: 10 . The max number of groups to show for each cell group identity (row). Ignored if cells_order is specified. subset : An expression to subset the cells, will be passed to dplyr::filter() on metadata. This will be applied prior to each . descr : The description of the case, will be shown in the report. hm_devpars ( ns ) : The device parameters for the heatmaps. res ( type=int ) : The resolution of the heatmaps. height ( type=int ) : The height of the heatmaps. width ( type=int ) : The width of the heatmaps. devpars ( ns ) : The device parameters for the plots of pie charts. res ( type=int ) : The resolution of the plots height ( type=int ) : The height of the plots width ( type=int ) : The width of the plots each : The column name in metadata to separate the cells into different plots. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the value as the case/section name. section : Default: DEFAULT . The section to show in the report. This allows different cases to be put in the same section in report. Only works when each is not specified. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. overlap ( list ) : Default: [] . Plot the overlap of cell groups (values of cells_by ) in different cases under the same section. The section must have at least 2 cases, each case should have a single cells_by column. cases ( type=json;order=99 ) : Default: {} . If you have multiple cases, you can specify them here. Keys are the names of the cases and values are the options above except mutaters . If some options are not specified, the options in envs will be used. If no cases are specified, a default case will be used with case name DEFAULT . Examples \u00b6 [CellsDistribution.envs.mutaters] # Add Patient1_Tumor_Expanded column with CDR3.aa that # expands in Tumor of patient 1 Patient1_Tumor_Expanded = ''' expanded(., region, \"Tumor\", subset = patient == \"Lung1\", uniq = FALSE) ''' [CellsDistribution.envs.cases.Patient1_Tumor_Expanded] cells_by = \"Patient1_Tumor_Expanded\" cells_orderby = \"desc(CloneSize)\" group_by = \"region\" group_order = [ \"Tumor\" , \"Normal\" ]","title":"CellsDistribution"},{"location":"processes/CellsDistribution/#cellsdistribution","text":"Distribution of cells (i.e. in a TCR clone) from different groups for each cluster This generates a set of pie charts with proportion of cells in each cluster Rows are the cells identities (i.e. TCR clones or TCR clusters), columns are groups (i.e. clinic groups).","title":"CellsDistribution"},{"location":"processes/CellsDistribution/#input","text":"srtobj : The seurat object in RDS format","title":"Input"},{"location":"processes/CellsDistribution/#output","text":"outdir : Default: {{in.srtobj | stem}}.cells_distribution . The output directory","title":"Output"},{"location":"processes/CellsDistribution/#environment-variables","text":"mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata Keys are the names of the mutaters and values are the R expressions passed by dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . cluster_orderby : The order of the clusters to show on the plot. An expression passed to dplyr::summarise() on the grouped data frame (by seurat_clusters ). The summary stat will be passed to dplyr::arrange() to order the clusters. It's applied on the whole meta.data before grouping and subsetting. For example, you can order the clusters by the activation score of the cluster: desc(mean(ActivationScore, na.rm = TRUE)) , suppose you have a column ActivationScore in the metadata. group_by : The column name in metadata to group the cells for the columns of the plot. group_order ( list ) : Default: [] . The order of the groups (columns) to show on the plot cells_by : The column name in metadata to group the cells for the rows of the plot. If your cell groups have overlapping cells, you can also use multiple columns, separated by comma ( , ). These columns will be concatenated to form the cell groups. For the overlapping cells, they will be counted multiple times for different groups. So make sure the cell group names in different columns are unique. cells_order ( list ) : Default: [] . The order of the cells (rows) to show on the plot cells_orderby : An expression passed to dplyr::arrange() to order the cells (rows) of the plot. Only works when cells-order is not specified. The data frame passed to dplyr::arrange() is grouped by cells_by before ordering. You can have multiple expressions separated by semicolon ( ; ). The expessions will be parsed by rlang::parse_exprs() . 4 extra columns were added to the metadata for ordering the rows in the plot: CloneSize : The size (number of cells) of clones (identified by cells_by ) CloneGroupSize : The clone size in each group (identified by group_by ) CloneClusterSize : The clone size in each cluster (identified by seurat_clusters ) CloneGroupClusterSize : The clone size in each group and cluster (identified by group_by and seurat_clusters ) cells_n ( type=int ) : Default: 10 . The max number of groups to show for each cell group identity (row). Ignored if cells_order is specified. subset : An expression to subset the cells, will be passed to dplyr::filter() on metadata. This will be applied prior to each . descr : The description of the case, will be shown in the report. hm_devpars ( ns ) : The device parameters for the heatmaps. res ( type=int ) : The resolution of the heatmaps. height ( type=int ) : The height of the heatmaps. width ( type=int ) : The width of the heatmaps. devpars ( ns ) : The device parameters for the plots of pie charts. res ( type=int ) : The resolution of the plots height ( type=int ) : The height of the plots width ( type=int ) : The width of the plots each : The column name in metadata to separate the cells into different plots. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the value as the case/section name. section : Default: DEFAULT . The section to show in the report. This allows different cases to be put in the same section in report. Only works when each is not specified. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. overlap ( list ) : Default: [] . Plot the overlap of cell groups (values of cells_by ) in different cases under the same section. The section must have at least 2 cases, each case should have a single cells_by column. cases ( type=json;order=99 ) : Default: {} . If you have multiple cases, you can specify them here. Keys are the names of the cases and values are the options above except mutaters . If some options are not specified, the options in envs will be used. If no cases are specified, a default case will be used with case name DEFAULT .","title":"Environment Variables"},{"location":"processes/CellsDistribution/#examples","text":"[CellsDistribution.envs.mutaters] # Add Patient1_Tumor_Expanded column with CDR3.aa that # expands in Tumor of patient 1 Patient1_Tumor_Expanded = ''' expanded(., region, \"Tumor\", subset = patient == \"Lung1\", uniq = FALSE) ''' [CellsDistribution.envs.cases.Patient1_Tumor_Expanded] cells_by = \"Patient1_Tumor_Expanded\" cells_orderby = \"desc(CloneSize)\" group_by = \"region\" group_order = [ \"Tumor\" , \"Normal\" ]","title":"Examples"},{"location":"processes/CloneResidency/","text":"CloneResidency \u00b6 Identification of clone residency This process is used to investigate the residency of clones in groups, typically two samples (e.g. tumor and normal) from the same patient. But it can be used for any two groups of clones. There are three types of output from this process Count tables of the clones in the two groups CDR3_aa Tumor Normal CASSYGLSWGSYEQYF 306 55 CASSVTGAETQYF 295 37 CASSVPSAHYNEQFF 197 9 ... ... ... Residency plots showing the residency of clones in the two groups The points in the plot are jittered to avoid overplotting. The x-axis is the residency in the first group and the y-axis is the residency in the second group. The size of the points are relative to the normalized size of the clones. You may identify different types of clones in the plot based on their residency in the two groups: Collapsed (The clones that are collapsed in the second group) Dual (The clones that are present in both groups with equal size) Expanded (The clones that are expanded in the second group) First Group Multiplet (The clones only in the First Group with size > 1) Second Group Multiplet (The clones only in the Second Group with size > 1) First Group Singlet (The clones only in the First Group with size = 1) Second Group Singlet (The clones only in the Second Group with size = 1) This idea is borrowed from this paper: Wu, Thomas D., et al. \"Peripheral T cell expansion predicts tumour infiltration and clinical response.\" Nature 579.7798 (2020): 274-278. Venn diagrams showing the overlap of the clones in the two groups Input \u00b6 immdata : The data loaded by immunarch::repLoad() metafile : A cell-level metafile, where the first column must be the cell barcodes that match the cell barcodes in immdata . The other columns can be any metadata that you want to use for the analysis. The loaded metadata will be left-joined to the converted cell-level data from immdata . This can also be a Seurat object RDS file. If so, the sobj@meta.data will be used as the metadata. Output \u00b6 outdir : Default: {{in.immdata | stem}}.cloneov . The output directory Environment Variables \u00b6 subject ( list ) : Default: [] . The key of subject in metadata. The clone residency will be examined for this subject/patient group : The key of group in metadata. This usually marks the samples that you want to compare. For example, Tumor vs Normal, post-treatment vs baseline It doesn't have to be 2 groups always. If there are more than 3 groups, instead of venn diagram, upset plots will be used. order ( list ) : Default: [] . The order of the values in group . In scatter/residency plots, X in X,Y will be used as x-axis and Y will be used as y-axis. You can also have multiple orders. For example: [\"X,Y\", \"X,Z\"] . If you only have two groups, you can set order = [\"X\", \"Y\"] , which will be the same as order = [\"X,Y\"] . section : How the subjects aligned in the report. Multiple subjects with the same value will be grouped together. Useful for cohort with large number of samples. mutaters ( type=json ) : Default: {} . The mutaters passed to dplyr::mutate() on the cell-level data converted from in.immdata . If in.metafile is provided, the mutaters will be applied to the joined data. The keys will be the names of the new columns, and the values will be the expressions. The new names can be used in subject , group , order and section . subset : The filter passed to dplyr::filter() to filter the data for the cells before calculating the clone residency. For example, Clones > 1 to filter out singletons. prefix : Default: {Sample}_ . The prefix of the cell barcodes in the Seurat object. upset_ymax : The maximum value of the y-axis in the upset bar plots. upset_trans : The transformation to apply to the y axis of upset bar plots. For example, log10 or sqrt . If not specified, the y axis will be plotted as is. Note that the position of the bar plots will be dodged instead of stacked when the transformation is applied. See also https://github.com/tidyverse/ggplot2/issues/3671 cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments. If no cases are specified, the default case will be added, with the name DEFAULT and the values of envs.subject , envs.group , envs.order and envs.section . These values are also the defaults for the other cases.","title":"CloneResidency"},{"location":"processes/CloneResidency/#cloneresidency","text":"Identification of clone residency This process is used to investigate the residency of clones in groups, typically two samples (e.g. tumor and normal) from the same patient. But it can be used for any two groups of clones. There are three types of output from this process Count tables of the clones in the two groups CDR3_aa Tumor Normal CASSYGLSWGSYEQYF 306 55 CASSVTGAETQYF 295 37 CASSVPSAHYNEQFF 197 9 ... ... ... Residency plots showing the residency of clones in the two groups The points in the plot are jittered to avoid overplotting. The x-axis is the residency in the first group and the y-axis is the residency in the second group. The size of the points are relative to the normalized size of the clones. You may identify different types of clones in the plot based on their residency in the two groups: Collapsed (The clones that are collapsed in the second group) Dual (The clones that are present in both groups with equal size) Expanded (The clones that are expanded in the second group) First Group Multiplet (The clones only in the First Group with size > 1) Second Group Multiplet (The clones only in the Second Group with size > 1) First Group Singlet (The clones only in the First Group with size = 1) Second Group Singlet (The clones only in the Second Group with size = 1) This idea is borrowed from this paper: Wu, Thomas D., et al. \"Peripheral T cell expansion predicts tumour infiltration and clinical response.\" Nature 579.7798 (2020): 274-278. Venn diagrams showing the overlap of the clones in the two groups","title":"CloneResidency"},{"location":"processes/CloneResidency/#input","text":"immdata : The data loaded by immunarch::repLoad() metafile : A cell-level metafile, where the first column must be the cell barcodes that match the cell barcodes in immdata . The other columns can be any metadata that you want to use for the analysis. The loaded metadata will be left-joined to the converted cell-level data from immdata . This can also be a Seurat object RDS file. If so, the sobj@meta.data will be used as the metadata.","title":"Input"},{"location":"processes/CloneResidency/#output","text":"outdir : Default: {{in.immdata | stem}}.cloneov . The output directory","title":"Output"},{"location":"processes/CloneResidency/#environment-variables","text":"subject ( list ) : Default: [] . The key of subject in metadata. The clone residency will be examined for this subject/patient group : The key of group in metadata. This usually marks the samples that you want to compare. For example, Tumor vs Normal, post-treatment vs baseline It doesn't have to be 2 groups always. If there are more than 3 groups, instead of venn diagram, upset plots will be used. order ( list ) : Default: [] . The order of the values in group . In scatter/residency plots, X in X,Y will be used as x-axis and Y will be used as y-axis. You can also have multiple orders. For example: [\"X,Y\", \"X,Z\"] . If you only have two groups, you can set order = [\"X\", \"Y\"] , which will be the same as order = [\"X,Y\"] . section : How the subjects aligned in the report. Multiple subjects with the same value will be grouped together. Useful for cohort with large number of samples. mutaters ( type=json ) : Default: {} . The mutaters passed to dplyr::mutate() on the cell-level data converted from in.immdata . If in.metafile is provided, the mutaters will be applied to the joined data. The keys will be the names of the new columns, and the values will be the expressions. The new names can be used in subject , group , order and section . subset : The filter passed to dplyr::filter() to filter the data for the cells before calculating the clone residency. For example, Clones > 1 to filter out singletons. prefix : Default: {Sample}_ . The prefix of the cell barcodes in the Seurat object. upset_ymax : The maximum value of the y-axis in the upset bar plots. upset_trans : The transformation to apply to the y axis of upset bar plots. For example, log10 or sqrt . If not specified, the y axis will be plotted as is. Note that the position of the bar plots will be dodged instead of stacked when the transformation is applied. See also https://github.com/tidyverse/ggplot2/issues/3671 cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments. If no cases are specified, the default case will be added, with the name DEFAULT and the values of envs.subject , envs.group , envs.order and envs.section . These values are also the defaults for the other cases.","title":"Environment Variables"},{"location":"processes/ClusterMarkers/","text":"ClusterMarkers \u00b6 Markers for clusters of all or selected T cells. This process is extended from MarkersFinder from the biopipen package. MarkersFinder is a pipen process that wraps the Seurat::FindMarkers() function, and performs enrichment analysis for the markers found. The enrichment analysis is done by enrichr . Note Since this process is extended from MarkersFinder , other environment variables from MarkersFinder are also available. However, they should not be used in this process. Other environment variables are used for more complicated cases for marker finding (See MarkersFinder for more details). If you are using pipen-board to run the pipeline (see here and here ), you may see the other environment variables of this process are hidden and readonly. Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform . Output \u00b6 outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 & avg_log2FC > 0 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. section : Default: DEFAULT . The section name for the report. It must not contain colon ( : ). Ignored when each is not specified and ident-1 is specified. When neither each nor ident-1 is specified, case name will be used as section name. If each is specified, the section name will be constructed from each and case name. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough).","title":"ClusterMarkers"},{"location":"processes/ClusterMarkers/#clustermarkers","text":"Markers for clusters of all or selected T cells. This process is extended from MarkersFinder from the biopipen package. MarkersFinder is a pipen process that wraps the Seurat::FindMarkers() function, and performs enrichment analysis for the markers found. The enrichment analysis is done by enrichr . Note Since this process is extended from MarkersFinder , other environment variables from MarkersFinder are also available. However, they should not be used in this process. Other environment variables are used for more complicated cases for marker finding (See MarkersFinder for more details). If you are using pipen-board to run the pipeline (see here and here ), you may see the other environment variables of this process are hidden and readonly.","title":"ClusterMarkers"},{"location":"processes/ClusterMarkers/#input","text":"srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform .","title":"Input"},{"location":"processes/ClusterMarkers/#output","text":"outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers","title":"Output"},{"location":"processes/ClusterMarkers/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 & avg_log2FC > 0 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. section : Default: DEFAULT . The section name for the report. It must not contain colon ( : ). Ignored when each is not specified and ident-1 is specified. When neither each nor ident-1 is specified, case name will be used as section name. If each is specified, the section name will be constructed from each and case name. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough).","title":"Environment Variables"},{"location":"processes/ClusterMarkersOfAllCells/","text":"ClusterMarkersOfAllCells \u00b6 Markers for clusters of all cells. See also ClusterMarkers . Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform . Output \u00b6 outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html group-by : Default: seurat_clusters . The column name in metadata to group the cells. If only group-by is specified, and ident-1 and ident-2 are not specified, markers will be found for all groups in this column in the manner of \"group vs rest\" comparison. NA group will be ignored. prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 & avg_log2FC > 0 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough).","title":"ClusterMarkersOfAllCells"},{"location":"processes/ClusterMarkersOfAllCells/#clustermarkersofallcells","text":"Markers for clusters of all cells. See also ClusterMarkers .","title":"ClusterMarkersOfAllCells"},{"location":"processes/ClusterMarkersOfAllCells/#input","text":"srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform .","title":"Input"},{"location":"processes/ClusterMarkersOfAllCells/#output","text":"outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers","title":"Output"},{"location":"processes/ClusterMarkersOfAllCells/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html group-by : Default: seurat_clusters . The column name in metadata to group the cells. If only group-by is specified, and ident-1 and ident-2 are not specified, markers will be found for all groups in this column in the manner of \"group vs rest\" comparison. NA group will be ignored. prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 & avg_log2FC > 0 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough).","title":"Environment Variables"},{"location":"processes/Immunarch/","text":"Immunarch \u00b6 Exploration of Single-cell and Bulk T-cell/Antibody Immune Repertoires Changed in 0.10.0 envs.mutaters are now applied at cell level. Seurat clustering information and other information are added at cell level, which can be used to subset the cells for listed analyses. You can now use subset to subset the cells for listed analyses, at cell level. See https://immunarch.com/articles/web_only/v3_basic_analysis.html After ImmunarchLoading loads the raw data into an immunarch object, this process wraps the functions from immunarch to do the following: Basic statistics, provided by immunarch::repExplore , such as number of clones or distributions of lengths and counts. The clonality of repertoires, provided by immunarch::repClonality The repertoire overlap, provided by immunarch::repOverlap The repertoire overlap, including different clustering procedures and PCA, provided by immunarch::repOverlapAnalysis The distributions of V or J genes, provided by immunarch::geneUsage The diversity of repertoires, provided by immunarch::repDiversity The dynamics of repertoires across time points/samples, provided by immunarch::trackClonotypes The spectratype of clonotypes, provided by immunarch::spectratype The distributions of kmers and sequence profiles, provided by immunarch::getKmers The V-J junction circos plots, implemented within the script of this process. Input \u00b6 immdata : The data loaded by immunarch::repLoad() metafile : A cell-level metafile, where the first column must be the cell barcodes that match the cell barcodes in immdata . The other columns can be any metadata that you want to use for the analysis. The loaded metadata will be left-joined to the converted cell-level data from immdata . This can also be a Seurat object RDS file. If so, the sobj@meta.data will be used as the metadata. Output \u00b6 outdir : Default: {{in.immdata | stem}}.immunarch . The output directory Environment Variables \u00b6 mutaters ( type=json;order=-9 ) : Default: {} . The mutaters passed to dplyr::mutate() on expanded cell-level data to add new columns. The keys will be the names of the columns, and the values will be the expressions. The new names can be used in volumes , lens , counts , top_clones , rare_clones , hom_clones , gene_usages , divs , etc. prefix : The prefix to the barcodes. You can use placeholder like {Sample}_ The prefixed barcodes will be used to match the barcodes in in.metafile . Not used if in.metafile is not specified. If None (default), immdata$prefix will be used. volumes ( ns ) : Explore clonotype volume (sizes). by : Groupings when visualize clonotype volumes, passed to the .by argument of vis(imm_vol, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.volumes will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.volume.by , envs.volume.devpars . lens ( ns ) : Explore clonotype CDR3 lengths. by : Groupings when visualize clonotype lengths, passed to the .by argument of vis(imm_len, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.lens will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.lens.by , envs.lens.devpars . counts ( ns ) : Explore clonotype counts. by : Groupings when visualize clonotype counts, passed to the .by argument of vis(imm_count, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.counts will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.counts.by , envs.counts.devpars . top_clones ( ns ) : Explore top clonotypes. by : Groupings when visualize top clones, passed to the .by argument of vis(imm_top, .by = <values>) . Multiple columns should be separated by , . marks ( list;itype=int ) : Default: [10, 100, 1000, 3000, 10000, 30000, 100000.0] . A numerical vector with ranges of the top clonotypes. Passed to the .head argument of repClonoality() . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.top_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.top_clones.by , envs.top_clones.marks and envs.top_clones.devpars . rare_clones ( ns ) : Explore rare clonotypes. by : Groupings when visualize rare clones, passed to the .by argument of vis(imm_rare, .by = <values>) . Multiple columns should be separated by , . marks ( list;itype=int ) : Default: [1, 3, 10, 30, 100] . A numerical vector with ranges of abundance for the rare clonotypes in the dataset. Passed to the .bound argument of repClonoality() . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.rare_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.rare_clones.by , envs.rare_clones.marks and envs.rare_clones.devpars . hom_clones ( ns ) : Explore homeo clonotypes. by : Groupings when visualize homeo clones, passed to the .by argument of vis(imm_hom, .by = <values>) . Multiple columns should be separated by , . marks ( ns ) : A dict with the threshold of the half-closed intervals that mark off clonal groups. Passed to the .clone.types arguments of repClonoality() . The keys could be: Rare ( type=float ) : Default: 1e-05 . the rare clonotypes Small ( type=float ) : Default: 0.0001 . the small clonotypes Medium ( type=float ) : Default: 0.001 . the medium clonotypes Large ( type=float ) : Default: 0.01 . the large clonotypes Hyperexpanded ( type=float ) : Default: 1.0 . the hyperexpanded clonotypes subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.hom_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.hom_clones.by , envs.hom_clones.marks and envs.hom_clones.devpars . overlaps ( ns ) : Explore clonotype overlaps. method ( choice ) : Default: public . The method to calculate overlaps. public : number of public clonotypes between two samples. overlap : a normalised measure of overlap similarity. It is defined as the size of the intersection divided by the smaller of the size of the two sets. jaccard : conceptually a percentage of how many objects two sets have in common out of how many objects they have total. tversky : an asymmetric similarity measure on sets that compares a variant to a prototype. cosine : a measure of similarity between two non-zero vectors of an inner product space that measures the cosine of the angle between them. morisita : how many times it is more likely to randomly select two sampled points from the same quadrat (the dataset is covered by a regular grid of changing size) then it would be in the case of a random distribution generated from a Poisson process. Duplicate objects are merged with their counts are summed up. inc+public : incremental overlaps of the N most abundant clonotypes with incrementally growing N using the public method. inc+morisita : incremental overlaps of the N most abundant clonotypes with incrementally growing N using the morisita method. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions vis(imm_ov, ...) . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. analyses ( ns;order=8 ) : Perform overlap analyses. method : Default: none . Plot the samples with these dimension reduction methods. The methods could be hclust , tsne , mds or combination of them, such as mds+hclust . You can also set to none to skip the analyses. They could also be combined, for example, mds+hclust . See https://immunarch.com/reference/repOverlapAnalysis.html . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.overlaps.analyses will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.overlaps.analyses.method , envs.overlaps.analyses.vis_args and envs.overlaps.analyses.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.overlaps will be used. If NO cases are specified, the default case will be added, with the key the default method and the values of envs.overlaps.method , envs.overlaps.vis_args , envs.overlaps.devpars and envs.overlaps.analyses . gene_usages ( ns ) : Explore gene usages. top ( type=int ) : Default: 30 . How many top (ranked by total usage across samples) genes to show in the plots. Use 0 to use all genes. norm ( flag ) : Default: False . If True then use proportions of genes, else use counts of genes. by : Groupings to show gene usages, passed to the .by argument of vis(imm_gu_top, .by = <values>) . Multiple columns should be separated by , . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. analyses ( ns;order=8 ) : Perform gene usage analyses. method : Default: none . The method to control how the data is going to be preprocessed and analysed. One of js , cor , cosine , pca , mds and tsne . Can also be combined with following methods for the actual analyses: hclust , kmeans , dbscan , and kruskal . For example: cosine+hclust . You can also set to none to skip the analyses. See https://immunarch.com/articles/web_only/v5_gene_usage.html . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.gene_usages.analyses will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.gene_usages.analyses.method , envs.gene_usages.analyses.vis_args and envs.gene_usages.analyses.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.gene_usages will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.gene_usages.top , envs.gene_usages.norm , envs.gene_usages.by , envs.gene_usages.vis_args , envs.gene_usages.devpars and envs.gene_usages.analyses . spects ( ns ) : Spectratyping analysis. quant : Select the column with clonal counts to evaluate. Set to id to count every clonotype once. Set to count to take into the account number of clones per clonotype. Multiple columns should be separated by , . col : A string that specifies the column(s) to be processed. The output is one of the following strings, separated by the plus sign: \"nt\" for nucleotide sequences, \"aa\" for amino acid sequences, \"v\" for V gene segments, \"j\" for J gene segments. E.g., pass \"aa+v\" for spectratyping on CDR3 amino acid sequences paired with V gene segments, i.e., in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment. Clonal counts of equal clonotypes will be summed up. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {'By_Clonotype': Diot({'quant': 'id', 'col': 'nt'}), 'By_Num_Clones': Diot({'quant': 'count', 'col': 'aa+v'})} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.spects will be used. By default, a By_Clonotype case will be added, with the values of quant = \"id\" and col = \"nt\" , and a By_Num_Clones case will be added, with the values of quant = \"count\" and col = \"aa+v\" . divs ( ns ) : Parameters to control the diversity analysis. method ( choice ) : Default: gini . The method to calculate diversity. chao1 : a nonparameteric asymptotic estimator of species richness. (number of species in a population). hill : Hill numbers are a mathematically unified family of diversity indices. (differing only by an exponent q). div : true diversity, or the effective number of types. It refers to the number of equally abundant types needed for the average proportional abundance of the types to equal that observed in the dataset of interest where all types may not be equally abundant. gini.simp : The Gini-Simpson index. It is the probability of interspecific encounter, i.e., probability that two entities represent different types. inv.simp : Inverse Simpson index. It is the effective number of types that is obtained when the weighted arithmetic mean is used to quantify average proportional abundance of types in the dataset of interest. gini : The Gini coefficient. It measures the inequality among values of a frequency distribution (for example levels of income). A Gini coefficient of zero expresses perfect equality, where all values are the same (for example, where everyone has the same income). A Gini coefficient of one (or 100 percents) expresses maximal inequality among values (for example where only one person has all the income). d50 : The D50 index. It is the number of types that are needed to cover 50%% of the total abundance. raref : Species richness from the results of sampling through extrapolation. by : The variables (column names) to group samples. Multiple columns should be separated by , . plot_type ( choice ) : Default: bar . The type of the plot, works when by is specified. Not working for raref . box : Boxplot bar : Barplot with error bars subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. args ( type=json ) : Default: {} . Other arguments for repDiversity() . Do not include the preceding . and use - instead of . in the argument names. For example, do-norm will be compiled to .do.norm . See all arguments at https://immunarch.com/reference/repDiversity.html . order ( list ) : Default: [] . The order of the values in by on the x-axis of the plots. If not specified, the values will be used as-is. test ( ns ) : Perform statistical tests between each pair of groups. Does NOT work for raref . method ( choice ) : Default: none . The method to perform the test none : No test t.test : Welch's t-test wilcox.test : Wilcoxon rank sum test padjust ( choice ) : Default: none . The method to adjust p-values. Defaults to none . bonferroni : one-step correction holm : step-down method using Bonferroni adjustments hochberg : step-up method (independent) hommel : closed method based on Simes tests (non-negative) BH : Benjamini & Hochberg (non-negative) BY : Benjamini & Yekutieli (negative) fdr : Benjamini & Hochberg (non-negative) none : no correction. separate_by : A column name used to separate the samples into different plots. split_by : A column name used to split the samples into different subplots. Like separate_by , but the plots will be put in the same figure. y-axis will be shared, even if align_y is False or ymin / ymax are not specified. ncol will be ignored. split_order : The order of the values in split_by on the x-axis of the plots. It can also be used for separate_by to control the order of the plots. Values can be separated by , . align_x ( flag ) : Default: False . Align the x-axis of multiple plots. Only works for raref . align_y ( flag ) : Default: False . Align the y-axis of multiple plots. ymin ( type=float ) : The minimum value of the y-axis. The minimum value of the y-axis for plots splitting by separate_by . align_y is forced True when both ymin and ymax are specified. ymax ( type=float ) : The maximum value of the y-axis. The maximum value of the y-axis for plots splitting by separate_by . align_y is forced True when both ymin and ymax are specified. Works when both ymin and ymax are specified. log ( flag ) : Default: False . Indicate whether we should plot with log-transformed x-axis using vis(.log = TRUE) . Only works for raref . ncol ( type=int ) : Default: 2 . The number of columns of the plots. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 800 . The width of the device height ( type=int ) : Default: 800 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If NO cases are specified, the default case will be added, with the name of envs.div.method . The values specified in envs.div will be used as the defaults for the cases here. trackings ( ns ) : Parameters to control the clonotype tracking analysis. targets : Either a set of CDR3AA seq of clonotypes to track (separated by , ), or simply an integer to track the top N clonotypes. subject_col : Default: Sample . The column name in meta data that contains the subjects/samples on the x-axis of the alluvial plot. If the values in this column are not unique, the values will be merged with the values in subject_col to form the x-axis. This defaults to Sample . subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. subjects ( list ) : Default: [] . A list of values from subject_col to show in the alluvial plot on the x-axis. If not specified, all values in subject_col will be used. This also specifies the order of the x-axis. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments ( target , subject_col , and subjects ). If any of these arguments are not specified, the values in envs.trackings will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.trackings.target , envs.trackings.subject_col , and envs.trackings.subjects . kmers ( ns ) : Arguments for kmer analysis. k ( type=int ) : Default: 5 . The length of kmer. head ( type=int ) : Default: 10 . The number of top kmers to show. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. profiles ( ns;order=8 ) : Arguments for sequence profilings. method ( choice ) : Default: self . The method for the position matrix. For more information see https://en.wikipedia.org/wiki/Position_weight_matrix . freq : position frequency matrix (PFM) - a matrix with occurences of each amino acid in each position. prob : position probability matrix (PPM) - a matrix with probabilities of each amino acid in each position. wei : position weight matrix (PWM) - a matrix with log likelihoods of PPM elements. self : self-information matrix (SIM) - a matrix with self-information of elements in PWM. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.kmers.profiles will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.kmers.profiles.method , envs.kmers.profiles.vis_args and envs.kmers.profiles.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the default case will be added, with the name DEFAULT and the values of envs.kmers.k , envs.kmers.head , envs.kmers.vis_args and envs.kmers.devpars . vj_junc ( ns ) : Arguments for VJ junction circos plots. This analysis is not included in immunarch . It is a separate implementation using circlize . by : Default: Sample . Groupings to show VJ usages. Typically, this is the Sample column, so that the VJ usages are shown for each sample. But you can also use other columns, such as Subject to show the VJ usages for each subject. Multiple columns should be separated by , . by_clones ( flag ) : Default: True . If True, the VJ usages will be calculated based on the distinct clonotypes, instead of the individual cells. subset : Subset the data before plotting VJ usages. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data, which will affect the VJ usages at cell level (by_clones=False). devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 800 . The width of the plot. height ( type=int ) : Default: 800 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.vj_junc will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.vj_junc.by , envs.vj_junc.by_clones envs.vj_junc.subset and envs.vj_junc.devpars . Environment Variable Design \u00b6 With different sets of arguments, a single function of the above can perform different tasks. For example, repExplore can be used to get the statistics of the size of the repertoire, the statistics of the length of the CDR3 region, or the statistics of the number of the clonotypes. Other than that, you can also have different ways to visualize the results, by passing different arguments to the immunarch::vis function. For example, you can pass .by to vis to visualize the results of repExplore by different groups. Before we explain each environment variable in details in the next section, we will give some examples here to show how the environment variables are organized in order for a single function to perform different tasks. # Repertoire overlapping [Immunarch.envs.overlaps] # The method to calculate the overlap, passed to `repOverlap` method = \"public\" What if we want to calculate the overlap by different methods at the same time? We can use the following configuration: [Immunarch.envs.overlaps.cases] Public = { method = \"public\" } Jaccard = { method = \"jaccard\" } Then, the repOverlap function will be called twice, once with method = \"public\" and once with method = \"jaccard\" . We can also use different arguments to visualize the results. These arguments will be passed to the vis function: [Immunarch.envs.overlaps.cases.Public] method = \"public\" vis_args = { \"-plot\" : \"heatmap2\" } [Immunarch.envs.overlaps.cases.Jaccard] method = \"jaccard\" vis_args = { \"-plot\" : \"heatmap2\" } -plot will be translated to .plot and then passed to vis . If multiple cases share the same arguments, we can use the following configuration: [Immunarch.envs.overlaps] vis_args = { \"-plot\" : \"heatmap2\" } [Immunarch.envs.overlaps.cases] Public = { method = \"public\" } Jaccard = { method = \"jaccard\" } For some results, there are futher analysis that can be performed. For example, for the repertoire overlap, we can perform clustering and PCA (see also https://immunarch.com/articles/web_only/v4_overlap.html ): imm_ov1 <- repOverlap ( immdata $ data , .method = \"public\" , .verbose = F ) repOverlapAnalysis ( imm_ov1 , \"mds\" ) %>% vis () repOverlapAnalysis ( imm_ov1 , \"tsne\" ) %>% vis () In such a case, we can use the following configuration: [Immunarch.envs.overlaps] method = \"public\" [Immunarch.envs.overlaps.analyses.cases] MDS = { \"-method\" : \"mds\" } TSNE = { \"-method\" : \"tsne\" } Then, the repOverlapAnalysis function will be called twice on the result generated by repOverlap(immdata$data, .method = \"public\") , once with .method = \"mds\" and once with .method = \"tsne\" . We can also use different arguments to visualize the results. These arguments will be passed to the vis function: [Immunarch.envs.overlaps] method = \"public\" [Immunarch.envs.overlaps.analyses] # See: <https://immunarch.com/reference/vis.immunr_hclust.html> vis_args = { \"-plot\" : \"best\" } [Immunarch.envs.overlaps.analyses.cases] MDS = { \"-method\" : \"mds\" } TSNE = { \"-method\" : \"tsne\" } Generally, you don't need to specify cases if you only have one case. A default case will be created for you. For multiple cases, the arguments at the same level as cases will be inherited by all cases. Examples \u00b6 [Immunarch.envs.kmers] k = 5 [Immunarch.envs.kmers] # Shared by cases k = 5 [Immunarch.envs.kmers.cases] Head5 = { head = 5 , -position = \"stack\" } Head10 = { head = 10 , -position = \"fill\" } Head30 = { head = 30 , -position = \"dodge\" } With motif profiling: [Immunarch.envs.kmers] k = 5 [Immnuarch.envs.kmers.profiles.cases] TextPlot = { method = \"self\" , vis_args = { \"-plot\" : \"text\" } } SeqPlot = { method = \"self\" , vis_args = { \"-plot\" : \"seq\" } }","title":"Immunarch"},{"location":"processes/Immunarch/#immunarch","text":"Exploration of Single-cell and Bulk T-cell/Antibody Immune Repertoires Changed in 0.10.0 envs.mutaters are now applied at cell level. Seurat clustering information and other information are added at cell level, which can be used to subset the cells for listed analyses. You can now use subset to subset the cells for listed analyses, at cell level. See https://immunarch.com/articles/web_only/v3_basic_analysis.html After ImmunarchLoading loads the raw data into an immunarch object, this process wraps the functions from immunarch to do the following: Basic statistics, provided by immunarch::repExplore , such as number of clones or distributions of lengths and counts. The clonality of repertoires, provided by immunarch::repClonality The repertoire overlap, provided by immunarch::repOverlap The repertoire overlap, including different clustering procedures and PCA, provided by immunarch::repOverlapAnalysis The distributions of V or J genes, provided by immunarch::geneUsage The diversity of repertoires, provided by immunarch::repDiversity The dynamics of repertoires across time points/samples, provided by immunarch::trackClonotypes The spectratype of clonotypes, provided by immunarch::spectratype The distributions of kmers and sequence profiles, provided by immunarch::getKmers The V-J junction circos plots, implemented within the script of this process.","title":"Immunarch"},{"location":"processes/Immunarch/#input","text":"immdata : The data loaded by immunarch::repLoad() metafile : A cell-level metafile, where the first column must be the cell barcodes that match the cell barcodes in immdata . The other columns can be any metadata that you want to use for the analysis. The loaded metadata will be left-joined to the converted cell-level data from immdata . This can also be a Seurat object RDS file. If so, the sobj@meta.data will be used as the metadata.","title":"Input"},{"location":"processes/Immunarch/#output","text":"outdir : Default: {{in.immdata | stem}}.immunarch . The output directory","title":"Output"},{"location":"processes/Immunarch/#environment-variables","text":"mutaters ( type=json;order=-9 ) : Default: {} . The mutaters passed to dplyr::mutate() on expanded cell-level data to add new columns. The keys will be the names of the columns, and the values will be the expressions. The new names can be used in volumes , lens , counts , top_clones , rare_clones , hom_clones , gene_usages , divs , etc. prefix : The prefix to the barcodes. You can use placeholder like {Sample}_ The prefixed barcodes will be used to match the barcodes in in.metafile . Not used if in.metafile is not specified. If None (default), immdata$prefix will be used. volumes ( ns ) : Explore clonotype volume (sizes). by : Groupings when visualize clonotype volumes, passed to the .by argument of vis(imm_vol, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.volumes will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.volume.by , envs.volume.devpars . lens ( ns ) : Explore clonotype CDR3 lengths. by : Groupings when visualize clonotype lengths, passed to the .by argument of vis(imm_len, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.lens will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.lens.by , envs.lens.devpars . counts ( ns ) : Explore clonotype counts. by : Groupings when visualize clonotype counts, passed to the .by argument of vis(imm_count, .by = <values>) . Multiple columns should be separated by , . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.counts will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.counts.by , envs.counts.devpars . top_clones ( ns ) : Explore top clonotypes. by : Groupings when visualize top clones, passed to the .by argument of vis(imm_top, .by = <values>) . Multiple columns should be separated by , . marks ( list;itype=int ) : Default: [10, 100, 1000, 3000, 10000, 30000, 100000.0] . A numerical vector with ranges of the top clonotypes. Passed to the .head argument of repClonoality() . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.top_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.top_clones.by , envs.top_clones.marks and envs.top_clones.devpars . rare_clones ( ns ) : Explore rare clonotypes. by : Groupings when visualize rare clones, passed to the .by argument of vis(imm_rare, .by = <values>) . Multiple columns should be separated by , . marks ( list;itype=int ) : Default: [1, 3, 10, 30, 100] . A numerical vector with ranges of abundance for the rare clonotypes in the dataset. Passed to the .bound argument of repClonoality() . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.rare_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.rare_clones.by , envs.rare_clones.marks and envs.rare_clones.devpars . hom_clones ( ns ) : Explore homeo clonotypes. by : Groupings when visualize homeo clones, passed to the .by argument of vis(imm_hom, .by = <values>) . Multiple columns should be separated by , . marks ( ns ) : A dict with the threshold of the half-closed intervals that mark off clonal groups. Passed to the .clone.types arguments of repClonoality() . The keys could be: Rare ( type=float ) : Default: 1e-05 . the rare clonotypes Small ( type=float ) : Default: 0.0001 . the small clonotypes Medium ( type=float ) : Default: 0.001 . the medium clonotypes Large ( type=float ) : Default: 0.01 . the large clonotypes Hyperexpanded ( type=float ) : Default: 1.0 . the hyperexpanded clonotypes subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.hom_clones will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.hom_clones.by , envs.hom_clones.marks and envs.hom_clones.devpars . overlaps ( ns ) : Explore clonotype overlaps. method ( choice ) : Default: public . The method to calculate overlaps. public : number of public clonotypes between two samples. overlap : a normalised measure of overlap similarity. It is defined as the size of the intersection divided by the smaller of the size of the two sets. jaccard : conceptually a percentage of how many objects two sets have in common out of how many objects they have total. tversky : an asymmetric similarity measure on sets that compares a variant to a prototype. cosine : a measure of similarity between two non-zero vectors of an inner product space that measures the cosine of the angle between them. morisita : how many times it is more likely to randomly select two sampled points from the same quadrat (the dataset is covered by a regular grid of changing size) then it would be in the case of a random distribution generated from a Poisson process. Duplicate objects are merged with their counts are summed up. inc+public : incremental overlaps of the N most abundant clonotypes with incrementally growing N using the public method. inc+morisita : incremental overlaps of the N most abundant clonotypes with incrementally growing N using the morisita method. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions vis(imm_ov, ...) . devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. analyses ( ns;order=8 ) : Perform overlap analyses. method : Default: none . Plot the samples with these dimension reduction methods. The methods could be hclust , tsne , mds or combination of them, such as mds+hclust . You can also set to none to skip the analyses. They could also be combined, for example, mds+hclust . See https://immunarch.com/reference/repOverlapAnalysis.html . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.overlaps.analyses will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.overlaps.analyses.method , envs.overlaps.analyses.vis_args and envs.overlaps.analyses.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.overlaps will be used. If NO cases are specified, the default case will be added, with the key the default method and the values of envs.overlaps.method , envs.overlaps.vis_args , envs.overlaps.devpars and envs.overlaps.analyses . gene_usages ( ns ) : Explore gene usages. top ( type=int ) : Default: 30 . How many top (ranked by total usage across samples) genes to show in the plots. Use 0 to use all genes. norm ( flag ) : Default: False . If True then use proportions of genes, else use counts of genes. by : Groupings to show gene usages, passed to the .by argument of vis(imm_gu_top, .by = <values>) . Multiple columns should be separated by , . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. analyses ( ns;order=8 ) : Perform gene usage analyses. method : Default: none . The method to control how the data is going to be preprocessed and analysed. One of js , cor , cosine , pca , mds and tsne . Can also be combined with following methods for the actual analyses: hclust , kmeans , dbscan , and kruskal . For example: cosine+hclust . You can also set to none to skip the analyses. See https://immunarch.com/articles/web_only/v5_gene_usage.html . vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.gene_usages.analyses will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.gene_usages.analyses.method , envs.gene_usages.analyses.vis_args and envs.gene_usages.analyses.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.gene_usages will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.gene_usages.top , envs.gene_usages.norm , envs.gene_usages.by , envs.gene_usages.vis_args , envs.gene_usages.devpars and envs.gene_usages.analyses . spects ( ns ) : Spectratyping analysis. quant : Select the column with clonal counts to evaluate. Set to id to count every clonotype once. Set to count to take into the account number of clones per clonotype. Multiple columns should be separated by , . col : A string that specifies the column(s) to be processed. The output is one of the following strings, separated by the plus sign: \"nt\" for nucleotide sequences, \"aa\" for amino acid sequences, \"v\" for V gene segments, \"j\" for J gene segments. E.g., pass \"aa+v\" for spectratyping on CDR3 amino acid sequences paired with V gene segments, i.e., in this case a unique clonotype is a pair of CDR3 amino acid and V gene segment. Clonal counts of equal clonotypes will be summed up. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {'By_Clonotype': Diot({'quant': 'id', 'col': 'nt'}), 'By_Num_Clones': Diot({'quant': 'count', 'col': 'aa+v'})} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.spects will be used. By default, a By_Clonotype case will be added, with the values of quant = \"id\" and col = \"nt\" , and a By_Num_Clones case will be added, with the values of quant = \"count\" and col = \"aa+v\" . divs ( ns ) : Parameters to control the diversity analysis. method ( choice ) : Default: gini . The method to calculate diversity. chao1 : a nonparameteric asymptotic estimator of species richness. (number of species in a population). hill : Hill numbers are a mathematically unified family of diversity indices. (differing only by an exponent q). div : true diversity, or the effective number of types. It refers to the number of equally abundant types needed for the average proportional abundance of the types to equal that observed in the dataset of interest where all types may not be equally abundant. gini.simp : The Gini-Simpson index. It is the probability of interspecific encounter, i.e., probability that two entities represent different types. inv.simp : Inverse Simpson index. It is the effective number of types that is obtained when the weighted arithmetic mean is used to quantify average proportional abundance of types in the dataset of interest. gini : The Gini coefficient. It measures the inequality among values of a frequency distribution (for example levels of income). A Gini coefficient of zero expresses perfect equality, where all values are the same (for example, where everyone has the same income). A Gini coefficient of one (or 100 percents) expresses maximal inequality among values (for example where only one person has all the income). d50 : The D50 index. It is the number of types that are needed to cover 50%% of the total abundance. raref : Species richness from the results of sampling through extrapolation. by : The variables (column names) to group samples. Multiple columns should be separated by , . plot_type ( choice ) : Default: bar . The type of the plot, works when by is specified. Not working for raref . box : Boxplot bar : Barplot with error bars subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. args ( type=json ) : Default: {} . Other arguments for repDiversity() . Do not include the preceding . and use - instead of . in the argument names. For example, do-norm will be compiled to .do.norm . See all arguments at https://immunarch.com/reference/repDiversity.html . order ( list ) : Default: [] . The order of the values in by on the x-axis of the plots. If not specified, the values will be used as-is. test ( ns ) : Perform statistical tests between each pair of groups. Does NOT work for raref . method ( choice ) : Default: none . The method to perform the test none : No test t.test : Welch's t-test wilcox.test : Wilcoxon rank sum test padjust ( choice ) : Default: none . The method to adjust p-values. Defaults to none . bonferroni : one-step correction holm : step-down method using Bonferroni adjustments hochberg : step-up method (independent) hommel : closed method based on Simes tests (non-negative) BH : Benjamini & Hochberg (non-negative) BY : Benjamini & Yekutieli (negative) fdr : Benjamini & Hochberg (non-negative) none : no correction. separate_by : A column name used to separate the samples into different plots. split_by : A column name used to split the samples into different subplots. Like separate_by , but the plots will be put in the same figure. y-axis will be shared, even if align_y is False or ymin / ymax are not specified. ncol will be ignored. split_order : The order of the values in split_by on the x-axis of the plots. It can also be used for separate_by to control the order of the plots. Values can be separated by , . align_x ( flag ) : Default: False . Align the x-axis of multiple plots. Only works for raref . align_y ( flag ) : Default: False . Align the y-axis of multiple plots. ymin ( type=float ) : The minimum value of the y-axis. The minimum value of the y-axis for plots splitting by separate_by . align_y is forced True when both ymin and ymax are specified. ymax ( type=float ) : The maximum value of the y-axis. The maximum value of the y-axis for plots splitting by separate_by . align_y is forced True when both ymin and ymax are specified. Works when both ymin and ymax are specified. log ( flag ) : Default: False . Indicate whether we should plot with log-transformed x-axis using vis(.log = TRUE) . Only works for raref . ncol ( type=int ) : Default: 2 . The number of columns of the plots. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 800 . The width of the device height ( type=int ) : Default: 800 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If NO cases are specified, the default case will be added, with the name of envs.div.method . The values specified in envs.div will be used as the defaults for the cases here. trackings ( ns ) : Parameters to control the clonotype tracking analysis. targets : Either a set of CDR3AA seq of clonotypes to track (separated by , ), or simply an integer to track the top N clonotypes. subject_col : Default: Sample . The column name in meta data that contains the subjects/samples on the x-axis of the alluvial plot. If the values in this column are not unique, the values will be merged with the values in subject_col to form the x-axis. This defaults to Sample . subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. subjects ( list ) : Default: [] . A list of values from subject_col to show in the alluvial plot on the x-axis. If not specified, all values in subject_col will be used. This also specifies the order of the x-axis. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments ( target , subject_col , and subjects ). If any of these arguments are not specified, the values in envs.trackings will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.trackings.target , envs.trackings.subject_col , and envs.trackings.subjects . kmers ( ns ) : Arguments for kmer analysis. k ( type=int ) : Default: 5 . The length of kmer. head ( type=int ) : Default: 10 . The number of top kmers to show. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. subset : Subset the data before calculating the clonotype volumes. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data. profiles ( ns;order=8 ) : Arguments for sequence profilings. method ( choice ) : Default: self . The method for the position matrix. For more information see https://en.wikipedia.org/wiki/Position_weight_matrix . freq : position frequency matrix (PFM) - a matrix with occurences of each amino acid in each position. prob : position probability matrix (PPM) - a matrix with probabilities of each amino acid in each position. wei : position weight matrix (PWM) - a matrix with log likelihoods of PPM elements. self : self-information matrix (SIM) - a matrix with self-information of elements in PWM. vis_args ( type=json ) : Default: {} . Other arguments for the plotting functions. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the plot. height ( type=int ) : Default: 1000 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.kmers.profiles will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.kmers.profiles.method , envs.kmers.profiles.vis_args and envs.kmers.profiles.devpars . cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the default case will be added, with the name DEFAULT and the values of envs.kmers.k , envs.kmers.head , envs.kmers.vis_args and envs.kmers.devpars . vj_junc ( ns ) : Arguments for VJ junction circos plots. This analysis is not included in immunarch . It is a separate implementation using circlize . by : Default: Sample . Groupings to show VJ usages. Typically, this is the Sample column, so that the VJ usages are shown for each sample. But you can also use other columns, such as Subject to show the VJ usages for each subject. Multiple columns should be separated by , . by_clones ( flag ) : Default: True . If True, the VJ usages will be calculated based on the distinct clonotypes, instead of the individual cells. subset : Subset the data before plotting VJ usages. The whole data will be expanded to cell level, and then subsetted. Clone sizes will be re-calculated based on the subsetted data, which will affect the VJ usages at cell level (by_clones=False). devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 800 . The width of the plot. height ( type=int ) : Default: 800 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. cases ( type=json;order=9 ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be used as the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.vj_junc will be used. If NO cases are specified, the default case will be added, with the name DEFAULT and the values of envs.vj_junc.by , envs.vj_junc.by_clones envs.vj_junc.subset and envs.vj_junc.devpars .","title":"Environment Variables"},{"location":"processes/Immunarch/#environment-variable-design","text":"With different sets of arguments, a single function of the above can perform different tasks. For example, repExplore can be used to get the statistics of the size of the repertoire, the statistics of the length of the CDR3 region, or the statistics of the number of the clonotypes. Other than that, you can also have different ways to visualize the results, by passing different arguments to the immunarch::vis function. For example, you can pass .by to vis to visualize the results of repExplore by different groups. Before we explain each environment variable in details in the next section, we will give some examples here to show how the environment variables are organized in order for a single function to perform different tasks. # Repertoire overlapping [Immunarch.envs.overlaps] # The method to calculate the overlap, passed to `repOverlap` method = \"public\" What if we want to calculate the overlap by different methods at the same time? We can use the following configuration: [Immunarch.envs.overlaps.cases] Public = { method = \"public\" } Jaccard = { method = \"jaccard\" } Then, the repOverlap function will be called twice, once with method = \"public\" and once with method = \"jaccard\" . We can also use different arguments to visualize the results. These arguments will be passed to the vis function: [Immunarch.envs.overlaps.cases.Public] method = \"public\" vis_args = { \"-plot\" : \"heatmap2\" } [Immunarch.envs.overlaps.cases.Jaccard] method = \"jaccard\" vis_args = { \"-plot\" : \"heatmap2\" } -plot will be translated to .plot and then passed to vis . If multiple cases share the same arguments, we can use the following configuration: [Immunarch.envs.overlaps] vis_args = { \"-plot\" : \"heatmap2\" } [Immunarch.envs.overlaps.cases] Public = { method = \"public\" } Jaccard = { method = \"jaccard\" } For some results, there are futher analysis that can be performed. For example, for the repertoire overlap, we can perform clustering and PCA (see also https://immunarch.com/articles/web_only/v4_overlap.html ): imm_ov1 <- repOverlap ( immdata $ data , .method = \"public\" , .verbose = F ) repOverlapAnalysis ( imm_ov1 , \"mds\" ) %>% vis () repOverlapAnalysis ( imm_ov1 , \"tsne\" ) %>% vis () In such a case, we can use the following configuration: [Immunarch.envs.overlaps] method = \"public\" [Immunarch.envs.overlaps.analyses.cases] MDS = { \"-method\" : \"mds\" } TSNE = { \"-method\" : \"tsne\" } Then, the repOverlapAnalysis function will be called twice on the result generated by repOverlap(immdata$data, .method = \"public\") , once with .method = \"mds\" and once with .method = \"tsne\" . We can also use different arguments to visualize the results. These arguments will be passed to the vis function: [Immunarch.envs.overlaps] method = \"public\" [Immunarch.envs.overlaps.analyses] # See: <https://immunarch.com/reference/vis.immunr_hclust.html> vis_args = { \"-plot\" : \"best\" } [Immunarch.envs.overlaps.analyses.cases] MDS = { \"-method\" : \"mds\" } TSNE = { \"-method\" : \"tsne\" } Generally, you don't need to specify cases if you only have one case. A default case will be created for you. For multiple cases, the arguments at the same level as cases will be inherited by all cases.","title":"Environment Variable Design"},{"location":"processes/Immunarch/#examples","text":"[Immunarch.envs.kmers] k = 5 [Immunarch.envs.kmers] # Shared by cases k = 5 [Immunarch.envs.kmers.cases] Head5 = { head = 5 , -position = \"stack\" } Head10 = { head = 10 , -position = \"fill\" } Head30 = { head = 30 , -position = \"dodge\" } With motif profiling: [Immunarch.envs.kmers] k = 5 [Immnuarch.envs.kmers.profiles.cases] TextPlot = { method = \"self\" , vis_args = { \"-plot\" : \"text\" } } SeqPlot = { method = \"self\" , vis_args = { \"-plot\" : \"seq\" } }","title":"Examples"},{"location":"processes/ImmunarchLoading/","text":"ImmunarchLoading \u00b6 Immuarch - Loading data Load the raw data into immunarch object, using immunarch::repLoad() . For the data path specified at TCRData in the input file, we will first find filtered_contig_annotations.csv and filtered_config_annotations.csv.gz in the path. If neighter of them exists, we will find all_contig_annotations.csv and all_contig_annotations.csv.gz in the path and a warning will be raised (You can find it at ./.pipen/<pipeline-name>/ImmunarchLoading/0/job.stderr ). If none of the files exists, an error will be raised. This process will also generate a text file with the information for each cell. The file will be saved at ./.pipen/<pipeline-name>/ImmunarchLoading/0/output/<prefix>.tcr.txt . The file can be used by the IntegratingTCR process to integrate the TCR-seq data into the Seurat object for further integrative analysis. envs.metacols can be used to specify the columns to be exported to the text file. Input \u00b6 metafile : The meta data of the samples A tab-delimited file Two columns are required: Sample to specify the sample names. TCRData to assign the path of the data to the samples, and this column will be excluded as metadata. Immunarch is able to fetch the sample names from the names of the target files. However, 10x data yields result like filtered_contig_annotations.csv , which doesn't have any name information. Output \u00b6 rdsfile : Default: {{in.metafile | stem}}.immunarch.RDS . The RDS file with the data and metadata metatxt : Default: {{in.metafile | stem}}.tcr.txt . The meta data at cell level, which can be used to attach to the Seurat object Environment Variables \u00b6 prefix : Default: {Sample}_ . The prefix to the barcodes. You can use placeholder like {Sample}_ to use the meta data from the immunarch object. The prefixed barcodes will be saved in out.metatxt . The immunarch object keeps the original barcodes, but the prefix is saved at immdata$prefix . Note This option is useful because the barcodes for the cells from scRNA-seq data are usually prefixed with the sample name, for example, Sample1_AAACCTGAGAAGGCTA-1 . However, the barcodes for the cells from scTCR-seq data are usually not prefixed with the sample name, for example, AAACCTGAGAAGGCTA-1 . So we need to add the prefix to the barcodes for the scTCR-seq data, and it is easier for us to integrate the data from different sources later. tmpdir : Default: /tmp . The temporary directory to link all data files. Immunarch scans a directory to find the data files. If the data files are not in the same directory, we can link them to a temporary directory and pass the temporary directory to Immunarch . This option is useful when the data files are in different directories. mode : Default: paired . Either \"single\" for single chain data or \"paired\" for paired chain data. For single , only TRB chain will be kept at immdata$data , information for other chains will be saved at immdata$tra and immdata$multi . extracols ( list ) : Default: [] . The extra columns to be exported to the text file. You can refer to the immunarch documentation to get a sense for the full list of the columns. The columns may vary depending on the data source. The columns from immdata$meta and some core columns, including Barcode , CDR3.aa , Clones , Proportion , V.name , J.name , and D.name will be exported by default. You can use this option to specify the extra columns to be exported.","title":"ImmunarchLoading"},{"location":"processes/ImmunarchLoading/#immunarchloading","text":"Immuarch - Loading data Load the raw data into immunarch object, using immunarch::repLoad() . For the data path specified at TCRData in the input file, we will first find filtered_contig_annotations.csv and filtered_config_annotations.csv.gz in the path. If neighter of them exists, we will find all_contig_annotations.csv and all_contig_annotations.csv.gz in the path and a warning will be raised (You can find it at ./.pipen/<pipeline-name>/ImmunarchLoading/0/job.stderr ). If none of the files exists, an error will be raised. This process will also generate a text file with the information for each cell. The file will be saved at ./.pipen/<pipeline-name>/ImmunarchLoading/0/output/<prefix>.tcr.txt . The file can be used by the IntegratingTCR process to integrate the TCR-seq data into the Seurat object for further integrative analysis. envs.metacols can be used to specify the columns to be exported to the text file.","title":"ImmunarchLoading"},{"location":"processes/ImmunarchLoading/#input","text":"metafile : The meta data of the samples A tab-delimited file Two columns are required: Sample to specify the sample names. TCRData to assign the path of the data to the samples, and this column will be excluded as metadata. Immunarch is able to fetch the sample names from the names of the target files. However, 10x data yields result like filtered_contig_annotations.csv , which doesn't have any name information.","title":"Input"},{"location":"processes/ImmunarchLoading/#output","text":"rdsfile : Default: {{in.metafile | stem}}.immunarch.RDS . The RDS file with the data and metadata metatxt : Default: {{in.metafile | stem}}.tcr.txt . The meta data at cell level, which can be used to attach to the Seurat object","title":"Output"},{"location":"processes/ImmunarchLoading/#environment-variables","text":"prefix : Default: {Sample}_ . The prefix to the barcodes. You can use placeholder like {Sample}_ to use the meta data from the immunarch object. The prefixed barcodes will be saved in out.metatxt . The immunarch object keeps the original barcodes, but the prefix is saved at immdata$prefix . Note This option is useful because the barcodes for the cells from scRNA-seq data are usually prefixed with the sample name, for example, Sample1_AAACCTGAGAAGGCTA-1 . However, the barcodes for the cells from scTCR-seq data are usually not prefixed with the sample name, for example, AAACCTGAGAAGGCTA-1 . So we need to add the prefix to the barcodes for the scTCR-seq data, and it is easier for us to integrate the data from different sources later. tmpdir : Default: /tmp . The temporary directory to link all data files. Immunarch scans a directory to find the data files. If the data files are not in the same directory, we can link them to a temporary directory and pass the temporary directory to Immunarch . This option is useful when the data files are in different directories. mode : Default: paired . Either \"single\" for single chain data or \"paired\" for paired chain data. For single , only TRB chain will be kept at immdata$data , information for other chains will be saved at immdata$tra and immdata$multi . extracols ( list ) : Default: [] . The extra columns to be exported to the text file. You can refer to the immunarch documentation to get a sense for the full list of the columns. The columns may vary depending on the data source. The columns from immdata$meta and some core columns, including Barcode , CDR3.aa , Clones , Proportion , V.name , J.name , and D.name will be exported by default. You can use this option to specify the extra columns to be exported.","title":"Environment Variables"},{"location":"processes/IntegratingTCR/","text":"IntegratingTCR \u00b6 Attach TCR clone information as meta columns to Seurat object This process is used to integrate scTCR-seq data into the Seurat object. The scTCR-seq data is loaded by ImmunarchLoading process. The integration is done by matching the barcodes from the Seurat object and the scTCR-seq data. The barcodes from the scTCR-seq data are prefixed with the sample name, for example, Sample1_AAACCTGAGAAGGCTA-1 . The prefix is specified by the prefix environment variable in the ImmunarchLoading process. ImmunarchLoading process will generate a text file with the information for each cell. ImmunarchLoading.envs.metacols can be used to specify the columns to be exported to the text file, which will then be integrated into the Seurat object by this process. You may also use envs.mutaters to add new columns to the metadata. These columns can be used for downstream analysis. An additional column TCR_Presence is added so later on we can overlay the TCR presence on the dimension reduction plot in SeuratClusterStats process. Warning If you are modifying envs.mutaters , make sure you keep the TCR_Presence column if you have scTCR-seq data available by: [IntegratingTCR.envs.mutaters] TCR_Presence = 'if_else(is.na(CDR3.aa), \"TCR_absent\", \"TCR_present\")' # other mutaters Because by default, SeuratClusterStats process will use this column to overlay the TCR presence on the dimension reduction plot with scTCR-seq data available. Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing metafile : Additional metadata A tab-delimited file with columns as meta columns and rows as cells. Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the additional metadata Environment Variables \u00b6 mutaters ( type=json ) : Default: {'TCR_Presence': 'if_else(is.na(CDR3.aa), \"TCR_absent\", \"TCR_present\")'} . The mutaters to mutate the metadata. The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . Metadata \u00b6 The metadata of the Seurat object will be updated with information from TCR data: All of the columns above can be used for downstream analysis.","title":"IntegratingTCR"},{"location":"processes/IntegratingTCR/#integratingtcr","text":"Attach TCR clone information as meta columns to Seurat object This process is used to integrate scTCR-seq data into the Seurat object. The scTCR-seq data is loaded by ImmunarchLoading process. The integration is done by matching the barcodes from the Seurat object and the scTCR-seq data. The barcodes from the scTCR-seq data are prefixed with the sample name, for example, Sample1_AAACCTGAGAAGGCTA-1 . The prefix is specified by the prefix environment variable in the ImmunarchLoading process. ImmunarchLoading process will generate a text file with the information for each cell. ImmunarchLoading.envs.metacols can be used to specify the columns to be exported to the text file, which will then be integrated into the Seurat object by this process. You may also use envs.mutaters to add new columns to the metadata. These columns can be used for downstream analysis. An additional column TCR_Presence is added so later on we can overlay the TCR presence on the dimension reduction plot in SeuratClusterStats process. Warning If you are modifying envs.mutaters , make sure you keep the TCR_Presence column if you have scTCR-seq data available by: [IntegratingTCR.envs.mutaters] TCR_Presence = 'if_else(is.na(CDR3.aa), \"TCR_absent\", \"TCR_present\")' # other mutaters Because by default, SeuratClusterStats process will use this column to overlay the TCR presence on the dimension reduction plot with scTCR-seq data available.","title":"IntegratingTCR"},{"location":"processes/IntegratingTCR/#input","text":"srtobj : The seurat object loaded by SeuratPreparing metafile : Additional metadata A tab-delimited file with columns as meta columns and rows as cells.","title":"Input"},{"location":"processes/IntegratingTCR/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the additional metadata","title":"Output"},{"location":"processes/IntegratingTCR/#environment-variables","text":"mutaters ( type=json ) : Default: {'TCR_Presence': 'if_else(is.na(CDR3.aa), \"TCR_absent\", \"TCR_present\")'} . The mutaters to mutate the metadata. The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE .","title":"Environment Variables"},{"location":"processes/IntegratingTCR/#metadata","text":"The metadata of the Seurat object will be updated with information from TCR data: All of the columns above can be used for downstream analysis.","title":"Metadata"},{"location":"processes/IntegratingTCRClusters/","text":"IntegratingTCRClusters \u00b6 Attach TCR clusters as meta columns to Seurat object This process is used to merge the cluster assignments from TCRClustering to the Seurat object. The cluster assignments are prefixed with S_ or M_ to indicate whether a cluster has only one unique CDR3 sequence or multiple CDR3 sequences. Note that a cluster with S_ prefix may still have multiple cells, as the same CDR3 sequence may be shared by multiple cells. The cluster assignments are saved in the Seurat object at TCR_Cluster column in seurat_object@meta.data in R . Other two columns are also added to the Seurat object: TCR_Cluster_Size and TCR_Cluster_Size1 . The TCR_Cluster_Size column contains the number of cells in each cluster, while the TCR_Cluster_Size1 column contains the number of unique CDR3 sequences in each cluster. Those columns can be then used for further downstream analysis. For example, you can find the markers for the TCR cluster (i.e. S_1 vs S_2 ) in each seurat cluster by [MarkersFinder.envs] group-by = \"TCR_Cluster\" ident-1 = \"S_1\" ident-2 = \"S_2\" each = \"seurat_clusters\" Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing metafile : Additional metadata A tab-delimited file with columns as meta columns and rows as cells. Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the additional metadata Metadata \u00b6 The metadata of the Seurat object will be updated with the TCR cluster assignments and their sizes:","title":"IntegratingTCRClusters"},{"location":"processes/IntegratingTCRClusters/#integratingtcrclusters","text":"Attach TCR clusters as meta columns to Seurat object This process is used to merge the cluster assignments from TCRClustering to the Seurat object. The cluster assignments are prefixed with S_ or M_ to indicate whether a cluster has only one unique CDR3 sequence or multiple CDR3 sequences. Note that a cluster with S_ prefix may still have multiple cells, as the same CDR3 sequence may be shared by multiple cells. The cluster assignments are saved in the Seurat object at TCR_Cluster column in seurat_object@meta.data in R . Other two columns are also added to the Seurat object: TCR_Cluster_Size and TCR_Cluster_Size1 . The TCR_Cluster_Size column contains the number of cells in each cluster, while the TCR_Cluster_Size1 column contains the number of unique CDR3 sequences in each cluster. Those columns can be then used for further downstream analysis. For example, you can find the markers for the TCR cluster (i.e. S_1 vs S_2 ) in each seurat cluster by [MarkersFinder.envs] group-by = \"TCR_Cluster\" ident-1 = \"S_1\" ident-2 = \"S_2\" each = \"seurat_clusters\"","title":"IntegratingTCRClusters"},{"location":"processes/IntegratingTCRClusters/#input","text":"srtobj : The seurat object loaded by SeuratPreparing metafile : Additional metadata A tab-delimited file with columns as meta columns and rows as cells.","title":"Input"},{"location":"processes/IntegratingTCRClusters/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the additional metadata","title":"Output"},{"location":"processes/IntegratingTCRClusters/#metadata","text":"The metadata of the Seurat object will be updated with the TCR cluster assignments and their sizes:","title":"Metadata"},{"location":"processes/MarkersFinder/","text":"MarkersFinder \u00b6 Find markers between different groups of cells MarkersFinder is a process that wraps the Seurat::FindMarkers() function, and performs enrichment analysis for the markers found. Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform . Output \u00b6 outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: df : The metadata data frame. You can use the . to refer to it. id : The column name in metadata for the group ids (i.e. CDR3.aa ). n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE .. See also mutating the metadata . ident-1 : The first group of cells to compare ident-2 : The second group of cells to compare If not provided, the rest of the cells are used for ident-2 . group-by : Default: seurat_clusters . The column name in metadata to group the cells. If only group-by is specified, and ident-1 and ident-2 are not specified, markers will be found for all groups in this column in the manner of \"group vs rest\" comparison. NA group will be ignored. each : The column name in metadata to separate the cells into different cases. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the value as the case/section name. prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. section : Default: DEFAULT . The section name for the report. It must not contain colon ( : ). Ignored when each is not specified and ident-1 is specified. When neither each nor ident-1 is specified, case name will be used as section name. If each is specified, the section name will be constructed from each and case name. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap cases ( type=json ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except ncores and mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the default values under envs with the name DEFAULT . overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough). Examples \u00b6 The examples are for more general use of MarkersFinder , in order to demonstrate how the final cases are constructed. Suppose we have a metadata like this: id seurat_clusters Group 1 1 A 2 1 A 3 2 A 4 2 A 5 3 B 6 3 B 7 4 B 8 4 B Default \u00b6 By default, group-by is seurat_clusters , and ident-1 and ident-2 are not specified. So markers will be found for all clusters in the manner of \"cluster vs rest\" comparison. Cluster 1 (vs 2, 3, 4) 2 (vs 1, 3, 4) 3 (vs 1, 2, 4) 4 (vs 1, 2, 3) Each case will have the markers and the enrichment analysis for the markers as the results. With each group \u00b6 each is used to separate the cells into different cases. group-by is still seurat_clusters . [ < Proc > .envs] group-by = \"seurat_clusters\" each = \"Group\" A:Cluster 1 (vs 2) 2 (vs 1) B:Cluster 3 (vs 4) 4 (vs 3) With ident-1 only \u00b6 ident-1 is used to specify the first group of cells to compare. Then the rest of the cells in the case are used for ident-2 . [ < Proc > .envs] group-by = \"seurat_clusters\" ident-1 = \"1\" Cluster 1 (vs 2, 3, 4) With both ident-1 and ident-2 \u00b6 ident-1 and ident-2 are used to specify the two groups of cells to compare. [ < Proc > .envs] group-by = \"seurat_clusters\" ident-1 = \"1\" ident-2 = \"2\" Cluster 1 (vs 2) Multiple cases \u00b6 [ < Proc > .envs.cases] c1_vs_c2 = { ident-1 = \"1\" , ident-2 = \"2\" } c3_vs_c4 = { ident-1 = \"3\" , ident-2 = \"4\" } DEFAULT:c1_vs_c2 1 (vs 2) DEFAULT:c3_vs_c4 3 (vs 4) The DEFAULT section name will be ignored in the report. You can specify a section name other than DEFAULT for each case to group them in the report.","title":"MarkersFinder"},{"location":"processes/MarkersFinder/#markersfinder","text":"Find markers between different groups of cells MarkersFinder is a process that wraps the Seurat::FindMarkers() function, and performs enrichment analysis for the markers found.","title":"MarkersFinder"},{"location":"processes/MarkersFinder/#input","text":"srtobj : The seurat object loaded by SeuratPreparing If you have your Seurat object prepared by yourself, you can also use it here, but you should make sure that the object has been processed by PrepSCTFindMarkers if data is not normalized using SCTransform .","title":"Input"},{"location":"processes/MarkersFinder/#output","text":"outdir : Default: {{in.srtobj | stem0}}.markers . The output directory for the markers","title":"Output"},{"location":"processes/MarkersFinder/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores to use for parallel computing for some Seurat procedures. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: df : The metadata data frame. You can use the . to refer to it. id : The column name in metadata for the group ids (i.e. CDR3.aa ). n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE .. See also mutating the metadata . ident-1 : The first group of cells to compare ident-2 : The second group of cells to compare If not provided, the rest of the cells are used for ident-2 . group-by : Default: seurat_clusters . The column name in metadata to group the cells. If only group-by is specified, and ident-1 and ident-2 are not specified, markers will be found for all groups in this column in the manner of \"group vs rest\" comparison. NA group will be ignored. each : The column name in metadata to separate the cells into different cases. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the value as the case/section name. prefix_group ( flag ) : Default: True . When neither ident-1 nor ident-2 is specified, should we prefix the group name to the section name? dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries sigmarkers : Default: p_val_adj < 0.05 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. Available variables are p_val , avg_log2FC , pct.1 , pct.2 and p_val_adj . For example, \"p_val_adj < 0.05 & abs(avg_log2FC) > 1\" to select markers with adjusted p-value < 0.05 and absolute log2 fold change > 1. assay : The assay to use. volcano_genes ( type=auto ) : Default: True . The genes to label in the volcano plot if they are significant markers. If True , all significant markers will be labeled. If False , no genes will be labeled. Otherwise, specify the genes to label. It could be either a string with comma separated genes, or a list of genes. section : Default: DEFAULT . The section name for the report. It must not contain colon ( : ). Ignored when each is not specified and ident-1 is specified. When neither each nor ident-1 is specified, case name will be used as section name. If each is specified, the section name will be constructed from each and case name. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. subset : An expression to subset the cells for each case. rest ( ns ) : Rest arguments for Seurat::FindMarkers() . Use - to replace . in the argument name. For example, use min-pct instead of min.pct . This only works when use_presto is False . <more> : See https://satijalab.org/seurat/reference/findmarkers dotplot ( ns ) : Arguments for Seurat::DotPlot() . Use - to replace . in the argument name. For example, use group-bar instead of group.bar . Note that object , features , and group-by are already specified by this process. So you don't need to specify them here. maxgenes ( type=int ) : Default: 20 . The maximum number of genes to plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. <more> : See https://satijalab.org/seurat/reference/doheatmap cases ( type=json ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except ncores and mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the default values under envs with the name DEFAULT . overlap_defaults ( ns ) : The default options for overlapping analysis. venn ( ns ) : The options for the Venn diagram. Venn diagram can only be plotted for sections with no more than 4 cases. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. upset ( ns ) : The options for the UpSet plot. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. overlap ( json ) : Default: {} . The sections to do overlaping analysis, including Venn diagram and UpSet plot. The Venn diagram and UpSet plot will be plotted for the overlapping of significant markers between different cases. The keys of this option are the names of the sections. The values are a dict of options with keys venn and upset , values will be inherited from envs.overlap_defaults , recursively. You can set envs.overlap.<section>.venn to False / None to disable the Venn diagram for the section. It works when each is specified. In such a case, the sections will be the case names. This does not work for the cases where ident-1 is not specified. In case you want to do such analysis for those cases, you should enumerate the idents in different cases and specify them here. cache ( type=auto ) : Default: /tmp . Where to cache to FindAllMarkers results. If True , cache to outdir of the job. If False , don't cache. Otherwise, specify the directory to cache to. Only works when use_presto is False (presto works fast enough).","title":"Environment Variables"},{"location":"processes/MarkersFinder/#examples","text":"The examples are for more general use of MarkersFinder , in order to demonstrate how the final cases are constructed. Suppose we have a metadata like this: id seurat_clusters Group 1 1 A 2 1 A 3 2 A 4 2 A 5 3 B 6 3 B 7 4 B 8 4 B","title":"Examples"},{"location":"processes/MarkersFinder/#default","text":"By default, group-by is seurat_clusters , and ident-1 and ident-2 are not specified. So markers will be found for all clusters in the manner of \"cluster vs rest\" comparison. Cluster 1 (vs 2, 3, 4) 2 (vs 1, 3, 4) 3 (vs 1, 2, 4) 4 (vs 1, 2, 3) Each case will have the markers and the enrichment analysis for the markers as the results.","title":"Default"},{"location":"processes/MarkersFinder/#with-each-group","text":"each is used to separate the cells into different cases. group-by is still seurat_clusters . [ < Proc > .envs] group-by = \"seurat_clusters\" each = \"Group\" A:Cluster 1 (vs 2) 2 (vs 1) B:Cluster 3 (vs 4) 4 (vs 3)","title":"With each group"},{"location":"processes/MarkersFinder/#with-ident-1-only","text":"ident-1 is used to specify the first group of cells to compare. Then the rest of the cells in the case are used for ident-2 . [ < Proc > .envs] group-by = \"seurat_clusters\" ident-1 = \"1\" Cluster 1 (vs 2, 3, 4)","title":"With ident-1 only"},{"location":"processes/MarkersFinder/#with-both-ident-1-and-ident-2","text":"ident-1 and ident-2 are used to specify the two groups of cells to compare. [ < Proc > .envs] group-by = \"seurat_clusters\" ident-1 = \"1\" ident-2 = \"2\" Cluster 1 (vs 2)","title":"With both ident-1 and ident-2"},{"location":"processes/MarkersFinder/#multiple-cases","text":"[ < Proc > .envs.cases] c1_vs_c2 = { ident-1 = \"1\" , ident-2 = \"2\" } c3_vs_c4 = { ident-1 = \"3\" , ident-2 = \"4\" } DEFAULT:c1_vs_c2 1 (vs 2) DEFAULT:c3_vs_c4 3 (vs 4) The DEFAULT section name will be ignored in the report. You can specify a section name other than DEFAULT for each case to group them in the report.","title":"Multiple cases"},{"location":"processes/MetaMarkers/","text":"MetaMarkers \u00b6 Find markers between three or more groups of cells, using one-way ANOVA or Kruskal-Wallis test. Sometimes, you may want to find the markers for cells from more than 2 groups. In this case, you can use this process to find the markers for the groups and do enrichment analysis for the markers. Each marker is examined using either one-way ANOVA or Kruskal-Wallis test. The p values are adjusted using the specified method. The significant markers are then used for enrichment analysis using enrichr api. Other than the markers and the enrichment analysis as outputs, this process also generates violin plots for the top 10 markers. Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing Output \u00b6 outdir : Default: {{in.srtobj | stem}}.meta_markers . The output directory for the markers Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores to use to parallelize for genes mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . group-by : The column name in metadata to group the cells. If only group-by is specified, and idents are not specified, markers will be found for all groups in this column. NA group will be ignored. idents : The groups of cells to compare, values should be in the group-by column. each : The column name in metadata to separate the cells into different cases. prefix_each ( flag ) : Default: True . Whether to add the each value as prefix to the case name. dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries subset : The subset of the cells to do the analysis. An expression passed to dplyr::filter() . p_adjust ( choice ) : Default: BH . The method to adjust the p values, which can be used to filter the significant markers. See also https://rdrr.io/r/stats/p.adjust.html holm : Holm-Bonferroni method hochberg : Hochberg method hommel : Hommel method bonferroni : Bonferroni method BH : Benjamini-Hochberg method BY : Benjamini-Yekutieli method fdr : FDR method of Benjamini-Hochberg none : No adjustment sigmarkers : Default: p_adjust < 0.05 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. The default is p.value < 0.05 . If method = 'anova' , the variables that can be used for filtering are: sumsq , meansq , statistic , p.value and p_adjust . If method = 'kruskal' , the variables that can be used for filtering are: statistic , p.value and p_adjust . section : Default: DEFAULT . The section name for the report. Worked only when each is not specified. Otherwise, the section name will be constructed from each and group-by . If DEFAULT , and it's the only section, it not included in the case/section names. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. method ( choice ) : Default: anova . The method for the test. anova : One-way ANOVA kruskal : Kruskal-Wallis test cases ( type=json ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except ncores and mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the default values under envs with the name DEFAULT .","title":"MetaMarkers"},{"location":"processes/MetaMarkers/#metamarkers","text":"Find markers between three or more groups of cells, using one-way ANOVA or Kruskal-Wallis test. Sometimes, you may want to find the markers for cells from more than 2 groups. In this case, you can use this process to find the markers for the groups and do enrichment analysis for the markers. Each marker is examined using either one-way ANOVA or Kruskal-Wallis test. The p values are adjusted using the specified method. The significant markers are then used for enrichment analysis using enrichr api. Other than the markers and the enrichment analysis as outputs, this process also generates violin plots for the top 10 markers.","title":"MetaMarkers"},{"location":"processes/MetaMarkers/#input","text":"srtobj : The seurat object loaded by SeuratPreparing","title":"Input"},{"location":"processes/MetaMarkers/#output","text":"outdir : Default: {{in.srtobj | stem}}.meta_markers . The output directory for the markers","title":"Output"},{"location":"processes/MetaMarkers/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores to use to parallelize for genes mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . group-by : The column name in metadata to group the cells. If only group-by is specified, and idents are not specified, markers will be found for all groups in this column. NA group will be ignored. idents : The groups of cells to compare, values should be in the group-by column. each : The column name in metadata to separate the cells into different cases. prefix_each ( flag ) : Default: True . Whether to add the each value as prefix to the case name. dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries subset : The subset of the cells to do the analysis. An expression passed to dplyr::filter() . p_adjust ( choice ) : Default: BH . The method to adjust the p values, which can be used to filter the significant markers. See also https://rdrr.io/r/stats/p.adjust.html holm : Holm-Bonferroni method hochberg : Hochberg method hommel : Hommel method bonferroni : Bonferroni method BH : Benjamini-Hochberg method BY : Benjamini-Yekutieli method fdr : FDR method of Benjamini-Hochberg none : No adjustment sigmarkers : Default: p_adjust < 0.05 . An expression passed to dplyr::filter() to filter the significant markers for enrichment analysis. The default is p.value < 0.05 . If method = 'anova' , the variables that can be used for filtering are: sumsq , meansq , statistic , p.value and p_adjust . If method = 'kruskal' , the variables that can be used for filtering are: statistic , p.value and p_adjust . section : Default: DEFAULT . The section name for the report. Worked only when each is not specified. Otherwise, the section name will be constructed from each and group-by . If DEFAULT , and it's the only section, it not included in the case/section names. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. method ( choice ) : Default: anova . The method for the test. anova : One-way ANOVA kruskal : Kruskal-Wallis test cases ( type=json ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except ncores and mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the default values under envs with the name DEFAULT .","title":"Environment Variables"},{"location":"processes/MetabolicExprImputation/","text":"MetabolicExprImputation \u00b6 This process imputes the dropout values in scRNA-seq data. It takes the Seurat object as input and outputs the Seurat object with imputed expression data. You can turn off the imputation by setting the noimpute option of the process group to True . Input \u00b6 infile : The input file in RDS format of Seurat object Output \u00b6 outfile : Default: {{in.infile | stem}}.imputed.RDS . The output file in RDS format of Seurat object Note that with rmagic and alra, the original default assay will be renamed to RAW and the imputed RNA assay will be renamed to RNA and set as default assay. Environment Variables \u00b6 tool ( choice ) : Default: alra . Either alra, scimpute or rmagic alra : Use RunALRA() from Seurat scimpute : Use scImpute() from scimpute rmagic : Use magic() from Rmagic scimpute_args ( ns ) : The arguments for scimpute drop_thre ( type=float ) : Default: 0.5 . The dropout threshold kcluster ( type=int ) : Number of clusters to use ncores ( type=int ) : Default: 1 . Number of cores to use refgene : Default: \"\" . The reference gene file rmagic_args ( ns ) : The arguments for rmagic python : Default: python . The python path where magic-impute is installed. alra_args ( type=json ) : Default: {} . The arguments for RunALRA() Reference \u00b6 Linderman, George C., Jun Zhao, and Yuval Kluger. \"Zero-preserving imputation of scRNA-seq data using low-rank approximation.\" BioRxiv (2018): 397588. Li, Wei Vivian, and Jingyi Jessica Li. \"An accurate and robust imputation method scImpute for single-cell RNA-seq data.\" Nature communications 9.1 (2018): 997. Dijk, David van, et al. \"MAGIC: A diffusion-based imputation method reveals gene-gene interactions in single-cell RNA-sequencing data.\" BioRxiv (2017): 111591.","title":"MetabolicExprImputation"},{"location":"processes/MetabolicExprImputation/#metabolicexprimputation","text":"This process imputes the dropout values in scRNA-seq data. It takes the Seurat object as input and outputs the Seurat object with imputed expression data. You can turn off the imputation by setting the noimpute option of the process group to True .","title":"MetabolicExprImputation"},{"location":"processes/MetabolicExprImputation/#input","text":"infile : The input file in RDS format of Seurat object","title":"Input"},{"location":"processes/MetabolicExprImputation/#output","text":"outfile : Default: {{in.infile | stem}}.imputed.RDS . The output file in RDS format of Seurat object Note that with rmagic and alra, the original default assay will be renamed to RAW and the imputed RNA assay will be renamed to RNA and set as default assay.","title":"Output"},{"location":"processes/MetabolicExprImputation/#environment-variables","text":"tool ( choice ) : Default: alra . Either alra, scimpute or rmagic alra : Use RunALRA() from Seurat scimpute : Use scImpute() from scimpute rmagic : Use magic() from Rmagic scimpute_args ( ns ) : The arguments for scimpute drop_thre ( type=float ) : Default: 0.5 . The dropout threshold kcluster ( type=int ) : Number of clusters to use ncores ( type=int ) : Default: 1 . Number of cores to use refgene : Default: \"\" . The reference gene file rmagic_args ( ns ) : The arguments for rmagic python : Default: python . The python path where magic-impute is installed. alra_args ( type=json ) : Default: {} . The arguments for RunALRA()","title":"Environment Variables"},{"location":"processes/MetabolicExprImputation/#reference","text":"Linderman, George C., Jun Zhao, and Yuval Kluger. \"Zero-preserving imputation of scRNA-seq data using low-rank approximation.\" BioRxiv (2018): 397588. Li, Wei Vivian, and Jingyi Jessica Li. \"An accurate and robust imputation method scImpute for single-cell RNA-seq data.\" Nature communications 9.1 (2018): 997. Dijk, David van, et al. \"MAGIC: A diffusion-based imputation method reveals gene-gene interactions in single-cell RNA-sequencing data.\" BioRxiv (2017): 111591.","title":"Reference"},{"location":"processes/MetabolicExprImpution/","text":"MetabolicExprImpution \u00b6 This process imputes the dropout values in scRNA-seq data. It takes the Seurat object as input and outputs the Seurat object with imputed expression data. You can turn off the imputation by setting the noimpute option of the process group to True . Environment Variables \u00b6 tool ( choice ) : Default: alra . Either alra, scimpute or rmagic alra : Use RunALRA() from Seurat scimpute : Use scImpute() from scimpute rmagic : Use magic() from Rmagic scimpute_args ( ns ) : The arguments for scimpute drop_thre ( type=float ) : Default: 0.5 . The dropout threshold kcluster ( type=int ) : Number of clusters to use ncores ( type=int ) : Default: 1 . Number of cores to use refgene : Default: ~/reference/hg19/hg19-gene.gtf . The reference gene file rmagic_args ( ns ) : The arguments for rmagic python : Default: python . The python path where magic-impute is installed. alra_args ( type=json ) : Default: {} . The arguments for RunALRA() Reference \u00b6 Linderman, George C., Jun Zhao, and Yuval Kluger. \"Zero-preserving imputation of scRNA-seq data using low-rank approximation.\" BioRxiv (2018): 397588. Li, Wei Vivian, and Jingyi Jessica Li. \"An accurate and robust imputation method scImpute for single-cell RNA-seq data.\" Nature communications 9.1 (2018): 997. Dijk, David van, et al. \"MAGIC: A diffusion-based imputation method reveals gene-gene interactions in single-cell RNA-sequencing data.\" BioRxiv (2017): 111591.","title":"MetabolicExprImpution"},{"location":"processes/MetabolicExprImpution/#metabolicexprimpution","text":"This process imputes the dropout values in scRNA-seq data. It takes the Seurat object as input and outputs the Seurat object with imputed expression data. You can turn off the imputation by setting the noimpute option of the process group to True .","title":"MetabolicExprImpution"},{"location":"processes/MetabolicExprImpution/#environment-variables","text":"tool ( choice ) : Default: alra . Either alra, scimpute or rmagic alra : Use RunALRA() from Seurat scimpute : Use scImpute() from scimpute rmagic : Use magic() from Rmagic scimpute_args ( ns ) : The arguments for scimpute drop_thre ( type=float ) : Default: 0.5 . The dropout threshold kcluster ( type=int ) : Number of clusters to use ncores ( type=int ) : Default: 1 . Number of cores to use refgene : Default: ~/reference/hg19/hg19-gene.gtf . The reference gene file rmagic_args ( ns ) : The arguments for rmagic python : Default: python . The python path where magic-impute is installed. alra_args ( type=json ) : Default: {} . The arguments for RunALRA()","title":"Environment Variables"},{"location":"processes/MetabolicExprImpution/#reference","text":"Linderman, George C., Jun Zhao, and Yuval Kluger. \"Zero-preserving imputation of scRNA-seq data using low-rank approximation.\" BioRxiv (2018): 397588. Li, Wei Vivian, and Jingyi Jessica Li. \"An accurate and robust imputation method scImpute for single-cell RNA-seq data.\" Nature communications 9.1 (2018): 997. Dijk, David van, et al. \"MAGIC: A diffusion-based imputation method reveals gene-gene interactions in single-cell RNA-sequencing data.\" BioRxiv (2017): 111591.","title":"Reference"},{"location":"processes/MetabolicFeatures/","text":"MetabolicFeatures \u00b6 This process performs enrichment analysis for the metabolic pathways for each group in each subset. The enrichment analysis is done with fgsea package or the GSEA_R package. Input \u00b6 sobjfile : Output \u00b6 outdir : Default: {{in.sobjfile | stem}}.pathwayfeatures . Environment Variables \u00b6 ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization. Defaults to ScrnaMetabolicLandscape.ncores fgsea ( flag ) : Default: True . Whether to do fast gsea analysis using fgsea package. If False , the GSEA_R package will be used. prerank_method ( choice ) : Default: signal_to_noise . Method to use for gene preranking. Signal to noise: the larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \u201cclass marker.\u201d. Absolute signal to noise: the absolute value of the signal to noise. T test: Uses the difference of means scaled by the standard deviation and number of samples. Ratio of classes: Uses the ratio of class means to calculate fold change for natural scale data. Diff of classes: Uses the difference of class means to calculate fold change for nature scale data Log2 ratio of classes: Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. signal_to_noise : Signal to noise s2n : Alias of signal_to_noise abs_signal_to_noise : absolute signal to noise abs_s2n : Alias of abs_signal_to_noise t_test : T test ratio_of_classes : Also referred to as fold change diff_of_classes : Difference of class means log2_ratio_of_classes : Log2 ratio of class means top ( type=int ) : Default: 10 . N top of enriched pathways to show gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"MetabolicFeatures"},{"location":"processes/MetabolicFeatures/#metabolicfeatures","text":"This process performs enrichment analysis for the metabolic pathways for each group in each subset. The enrichment analysis is done with fgsea package or the GSEA_R package.","title":"MetabolicFeatures"},{"location":"processes/MetabolicFeatures/#input","text":"sobjfile :","title":"Input"},{"location":"processes/MetabolicFeatures/#output","text":"outdir : Default: {{in.sobjfile | stem}}.pathwayfeatures .","title":"Output"},{"location":"processes/MetabolicFeatures/#environment-variables","text":"ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization. Defaults to ScrnaMetabolicLandscape.ncores fgsea ( flag ) : Default: True . Whether to do fast gsea analysis using fgsea package. If False , the GSEA_R package will be used. prerank_method ( choice ) : Default: signal_to_noise . Method to use for gene preranking. Signal to noise: the larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \u201cclass marker.\u201d. Absolute signal to noise: the absolute value of the signal to noise. T test: Uses the difference of means scaled by the standard deviation and number of samples. Ratio of classes: Uses the ratio of class means to calculate fold change for natural scale data. Diff of classes: Uses the difference of class means to calculate fold change for nature scale data Log2 ratio of classes: Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. signal_to_noise : Signal to noise s2n : Alias of signal_to_noise abs_signal_to_noise : absolute signal to noise abs_s2n : Alias of abs_signal_to_noise t_test : T test ratio_of_classes : Also referred to as fold change diff_of_classes : Difference of class means log2_ratio_of_classes : Log2 ratio of class means top ( type=int ) : Default: 10 . N top of enriched pathways to show gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"Environment Variables"},{"location":"processes/MetabolicFeaturesIntraSubset/","text":"MetabolicFeaturesIntraSubset \u00b6 Intra-subset metabolic features - Enrichment analysis in details Similar to the MetabolicFeatures process, this process performs enrichment analysis for the metabolic pathways for each subset in each group, instead of each group in each subset. Input \u00b6 sobjfile : Output \u00b6 outdir : Default: {{in.sobjfile | stem}}.intra-subset-pathwayfeatures . Environment Variables \u00b6 ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores fgsea ( flag ) : Default: True . Whether to do fast gsea analysis prerank_method ( choice ) : Default: signal_to_noise . Method to use for gene preranking Signal to noise: the larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \u201cclass marker.\u201d. Absolute signal to noise: the absolute value of the signal to noise. T test: Uses the difference of means scaled by the standard deviation and number of samples. Ratio of classes: Uses the ratio of class means to calculate fold change for natural scale data. Diff of classes: Uses the difference of class means to calculate fold change for nature scale data Log2 ratio of classes: Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. signal_to_noise : Signal to noise s2n : Alias of signal_to_noise abs_signal_to_noise : absolute signal to noise abs_s2n : Alias of abs_signal_to_noise t_test : T test ratio_of_classes : Also referred to as fold change diff_of_classes : Difference of class means log2_ratio_of_classes : Log2 ratio of class means top ( type=int ) : Default: 10 . N top of enriched pathways to show gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix subsetting_comparison ( type=json;pgarg;readonly ) : Default: {} . How do we compare the subsets. Defaults to ScrnaMetabolicLandscape.subsetting_comparison","title":"MetabolicFeaturesIntraSubset"},{"location":"processes/MetabolicFeaturesIntraSubset/#metabolicfeaturesintrasubset","text":"Intra-subset metabolic features - Enrichment analysis in details Similar to the MetabolicFeatures process, this process performs enrichment analysis for the metabolic pathways for each subset in each group, instead of each group in each subset.","title":"MetabolicFeaturesIntraSubset"},{"location":"processes/MetabolicFeaturesIntraSubset/#input","text":"sobjfile :","title":"Input"},{"location":"processes/MetabolicFeaturesIntraSubset/#output","text":"outdir : Default: {{in.sobjfile | stem}}.intra-subset-pathwayfeatures .","title":"Output"},{"location":"processes/MetabolicFeaturesIntraSubset/#environment-variables","text":"ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores fgsea ( flag ) : Default: True . Whether to do fast gsea analysis prerank_method ( choice ) : Default: signal_to_noise . Method to use for gene preranking Signal to noise: the larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \u201cclass marker.\u201d. Absolute signal to noise: the absolute value of the signal to noise. T test: Uses the difference of means scaled by the standard deviation and number of samples. Ratio of classes: Uses the ratio of class means to calculate fold change for natural scale data. Diff of classes: Uses the difference of class means to calculate fold change for nature scale data Log2 ratio of classes: Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. signal_to_noise : Signal to noise s2n : Alias of signal_to_noise abs_signal_to_noise : absolute signal to noise abs_s2n : Alias of abs_signal_to_noise t_test : T test ratio_of_classes : Also referred to as fold change diff_of_classes : Difference of class means log2_ratio_of_classes : Log2 ratio of class means top ( type=int ) : Default: 10 . N top of enriched pathways to show gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix subsetting_comparison ( type=json;pgarg;readonly ) : Default: {} . How do we compare the subsets. Defaults to ScrnaMetabolicLandscape.subsetting_comparison","title":"Environment Variables"},{"location":"processes/MetabolicInput/","text":"MetabolicInput \u00b6 This process takes Seurat object as input and pass it to the next processes in the ScrnaMetabolicLandscape group. There is no configuration for this process. Input \u00b6 infile : The input file Output \u00b6 outfile : Default: {{in.infile | basename}} . The output symbolic link to the input file","title":"MetabolicInput"},{"location":"processes/MetabolicInput/#metabolicinput","text":"This process takes Seurat object as input and pass it to the next processes in the ScrnaMetabolicLandscape group. There is no configuration for this process.","title":"MetabolicInput"},{"location":"processes/MetabolicInput/#input","text":"infile : The input file","title":"Input"},{"location":"processes/MetabolicInput/#output","text":"outfile : Default: {{in.infile | basename}} . The output symbolic link to the input file","title":"Output"},{"location":"processes/MetabolicPathwayActivity/","text":"MetabolicPathwayActivity \u00b6 This process calculates the pathway activities in different groups and subsets. The cells are first grouped by subsets and then the metabolic activities are examined for each groups in different subsets. For each subset, a heatmap and a violin plot will be generated. The heatmap shows the pathway activities for each group and each metabolic pathway The violin plot shows the distribution of the pathway activities for each group Input \u00b6 sobjfile : Output \u00b6 outdir : Default: {{in.sobjfile | stem}}.pathwayactivity . Environment Variables \u00b6 ntimes ( type=int ) : Default: 5000 . Number of times to do the permutation ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores heatmap_devpars ( ns ) : Device parameters for the heatmap width ( type=int ) : Width of the heatmap height ( type=int ) : Height of the heatmap res ( type=int ) : Resolution of the heatmap violin_devpars ( ns ) : Device parameters for the violin plot width ( type=int ) : Width of the violin plot height ( type=int ) : Height of the violin plot res ( type=int ) : Resolution of the violin plot gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity, typically the clusters. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. For example, if we have grouping_prefix = \"cluster\" and we have 1 and 2 in the grouping column, the groups will be named as cluster_1 and cluster_2 . Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Other columns in the metadata to do comparisons. For example, \"TimePoint\" or [\"TimePoint\", \"Response\"] . Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. For example, if we have subsetting_prefix = \"timepoint\" and we have pre and post in the subsetting column, the subsets will be named as timepoint_pre and timepoint_post . If subsetting is a list, then this should also be a same-length list. If a single string is given, it will be repeated to a list with the same length as subsetting . Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"MetabolicPathwayActivity"},{"location":"processes/MetabolicPathwayActivity/#metabolicpathwayactivity","text":"This process calculates the pathway activities in different groups and subsets. The cells are first grouped by subsets and then the metabolic activities are examined for each groups in different subsets. For each subset, a heatmap and a violin plot will be generated. The heatmap shows the pathway activities for each group and each metabolic pathway The violin plot shows the distribution of the pathway activities for each group","title":"MetabolicPathwayActivity"},{"location":"processes/MetabolicPathwayActivity/#input","text":"sobjfile :","title":"Input"},{"location":"processes/MetabolicPathwayActivity/#output","text":"outdir : Default: {{in.sobjfile | stem}}.pathwayactivity .","title":"Output"},{"location":"processes/MetabolicPathwayActivity/#environment-variables","text":"ntimes ( type=int ) : Default: 5000 . Number of times to do the permutation ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores heatmap_devpars ( ns ) : Device parameters for the heatmap width ( type=int ) : Width of the heatmap height ( type=int ) : Height of the heatmap res ( type=int ) : Resolution of the heatmap violin_devpars ( ns ) : Device parameters for the violin plot width ( type=int ) : Width of the violin plot height ( type=int ) : Height of the violin plot res ( type=int ) : Resolution of the violin plot gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity, typically the clusters. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. For example, if we have grouping_prefix = \"cluster\" and we have 1 and 2 in the grouping column, the groups will be named as cluster_1 and cluster_2 . Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Other columns in the metadata to do comparisons. For example, \"TimePoint\" or [\"TimePoint\", \"Response\"] . Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. For example, if we have subsetting_prefix = \"timepoint\" and we have pre and post in the subsetting column, the subsets will be named as timepoint_pre and timepoint_post . If subsetting is a list, then this should also be a same-length list. If a single string is given, it will be repeated to a list with the same length as subsetting . Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"Environment Variables"},{"location":"processes/MetabolicPathwayHeterogeneity/","text":"MetabolicPathwayHeterogeneity \u00b6 Calculate Metabolic Pathway heterogeneity. For each subset, the normalized enrichment score (NES) of each metabolic pathway is calculated for each group. The NES is calculated by comparing the enrichment score of the subset to the enrichment scores of the same subset in the permutations. The p-value is calculated by comparing the NES to the NESs of the same subset in the permutations. The heterogeneity can be reflected by the NES values and the p-values in different groups for the metabolic pathways. Input \u00b6 sobjfile : Output \u00b6 outdir : Default: {{in.sobjfile | stem}}.pathwayhetero . Environment Variables \u00b6 gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile select_pcs ( type=float ) : Default: 0.8 . Select the PCs to use for the analysis. pathway_pval_cutoff ( type=float ) : Default: 0.01 . The p-value cutoff to select the enriched pathways ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores bubble_devpars ( ns ) : The devpars for the bubble plot width ( type=int ) : The width of the plot height ( type=int ) : The height of the plot res ( type=int ) : The resolution of the plot grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"MetabolicPathwayHeterogeneity"},{"location":"processes/MetabolicPathwayHeterogeneity/#metabolicpathwayheterogeneity","text":"Calculate Metabolic Pathway heterogeneity. For each subset, the normalized enrichment score (NES) of each metabolic pathway is calculated for each group. The NES is calculated by comparing the enrichment score of the subset to the enrichment scores of the same subset in the permutations. The p-value is calculated by comparing the NES to the NESs of the same subset in the permutations. The heterogeneity can be reflected by the NES values and the p-values in different groups for the metabolic pathways.","title":"MetabolicPathwayHeterogeneity"},{"location":"processes/MetabolicPathwayHeterogeneity/#input","text":"sobjfile :","title":"Input"},{"location":"processes/MetabolicPathwayHeterogeneity/#output","text":"outdir : Default: {{in.sobjfile | stem}}.pathwayhetero .","title":"Output"},{"location":"processes/MetabolicPathwayHeterogeneity/#environment-variables","text":"gmtfile ( pgarg ) : The GMT file with the metabolic pathways. Defaults to ScrnaMetabolicLandscape.gmtfile select_pcs ( type=float ) : Default: 0.8 . Select the PCs to use for the analysis. pathway_pval_cutoff ( type=float ) : Default: 0.01 . The p-value cutoff to select the enriched pathways ncores ( type=int;pgarg ) : Default: 1 . Number of cores to use for parallelization Defaults to ScrnaMetabolicLandscape.ncores bubble_devpars ( ns ) : The devpars for the bubble plot width ( type=int ) : The width of the plot height ( type=int ) : The height of the plot res ( type=int ) : The resolution of the plot grouping ( type=auto;pgarg;readonly ) : Defines the basic groups to investigate the metabolic activity. Defaults to ScrnaMetabolicLandscape.grouping grouping_prefix ( type=auto;pgarg;readonly ) : Default: \"\" . Working as a prefix to group names. Defaults to ScrnaMetabolicLandscape.grouping_prefix subsetting ( type=auto;pgarg;readonly ) : How do we subset the data. Another column(s) in the metadata. Defaults to ScrnaMetabolicLandscape.subsetting subsetting_prefix ( type=auto;pgarg;readonly ) : Working as a prefix to subset names. Defaults to ScrnaMetabolicLandscape.subsetting_prefix","title":"Environment Variables"},{"location":"processes/ModuleScoreCalculator/","text":"ModuleScoreCalculator \u00b6 Calculate the module scores for each cell The module scores are calculated by Seurat::AddModuleScore() or Seurat::CellCycleScoring() for cell cycle scores. The module scores are calculated as the average expression levels of each program on single cell level, subtracted by the aggregated expression of control feature sets. All analyzed features are binned based on averaged expression, and the control features are randomly selected from each bin. Input \u00b6 srtobj : The seurat object loaded by SeuratClustering Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with module scores Environment Variables \u00b6 defaults ( ns ) : The default parameters for modules . features : The features to calculate the scores. Multiple features should be separated by comma. You can also specify cc.genes or cc.genes.updated.2019 to use the cell cycle genes to calculate cell cycle scores. If so, three columns will be added to the metadata, including S.Score , G2M.Score and Phase . Only one type of cell cycle scores can be calculated at a time. nbin ( type=int ) : Default: 24 . Number of bins of aggregate expression levels for all analyzed features. ctrl ( type=int ) : Default: 100 . Number of control features selected from the same bin per analyzed feature. k ( flag ) : Default: False . Use feature clusters returned from DoKMeans . assay : The assay to use. seed ( type=int ) : Default: 8525 . Set a random seed. search ( flag ) : Default: False . Search for symbol synonyms for features in features that don't match features in object? keep ( flag ) : Default: False . Keep the scores for each feature? Only works for non-cell cycle scores. agg ( choice ) : Default: mean . The aggregation function to use. Only works for non-cell cycle scores. mean : The mean of the expression levels median : The median of the expression levels sum : The sum of the expression levels max : The max of the expression levels min : The min of the expression levels var : The variance of the expression levels sd : The standard deviation of the expression levels modules ( type=json ) : Default: {} . The modules to calculate the scores. Keys are the names of the expression programs and values are the dicts inherited from env.defaults . Here are some examples - { \"CellCycle\" : { \"features\" : \"cc.genes.updated.2019\" }, \"Exhaustion\" : { \"features\" : \"HAVCR2,ENTPD1,LAYN,LAG3\" }, \"Activation\" : { \"features\" : \"IFNG\" }, \"Proliferation\" : { \"features\" : \"STMN1,TUBB\" } } For CellCycle , the columns S.Score , G2M.Score and Phase will be added to the metadata. S.Score and G2M.Score are the cell cycle scores for each cell, and Phase is the cell cycle phase for each cell. You can also add Diffusion Components (DC) to the modules { \"DC\" : { \"features\" : 2 , \"kind\" : \"diffmap\" }} will perform diffusion map as a reduction and add the first 2 components as DC_1 and DC_2 to the metadata. diffmap is a shortcut for diffusion_map . Other key-value pairs will pass to destiny::DiffusionMap() . You can later plot the diffusion map by using reduction = \"DC\" in env.dimplots in SeuratClusterStats . This requires SingleCellExperiment and destiny R packages. Metadata \u00b6 The metadata of the Seurat object will be updated with the module scores:","title":"ModuleScoreCalculator"},{"location":"processes/ModuleScoreCalculator/#modulescorecalculator","text":"Calculate the module scores for each cell The module scores are calculated by Seurat::AddModuleScore() or Seurat::CellCycleScoring() for cell cycle scores. The module scores are calculated as the average expression levels of each program on single cell level, subtracted by the aggregated expression of control feature sets. All analyzed features are binned based on averaged expression, and the control features are randomly selected from each bin.","title":"ModuleScoreCalculator"},{"location":"processes/ModuleScoreCalculator/#input","text":"srtobj : The seurat object loaded by SeuratClustering","title":"Input"},{"location":"processes/ModuleScoreCalculator/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with module scores","title":"Output"},{"location":"processes/ModuleScoreCalculator/#environment-variables","text":"defaults ( ns ) : The default parameters for modules . features : The features to calculate the scores. Multiple features should be separated by comma. You can also specify cc.genes or cc.genes.updated.2019 to use the cell cycle genes to calculate cell cycle scores. If so, three columns will be added to the metadata, including S.Score , G2M.Score and Phase . Only one type of cell cycle scores can be calculated at a time. nbin ( type=int ) : Default: 24 . Number of bins of aggregate expression levels for all analyzed features. ctrl ( type=int ) : Default: 100 . Number of control features selected from the same bin per analyzed feature. k ( flag ) : Default: False . Use feature clusters returned from DoKMeans . assay : The assay to use. seed ( type=int ) : Default: 8525 . Set a random seed. search ( flag ) : Default: False . Search for symbol synonyms for features in features that don't match features in object? keep ( flag ) : Default: False . Keep the scores for each feature? Only works for non-cell cycle scores. agg ( choice ) : Default: mean . The aggregation function to use. Only works for non-cell cycle scores. mean : The mean of the expression levels median : The median of the expression levels sum : The sum of the expression levels max : The max of the expression levels min : The min of the expression levels var : The variance of the expression levels sd : The standard deviation of the expression levels modules ( type=json ) : Default: {} . The modules to calculate the scores. Keys are the names of the expression programs and values are the dicts inherited from env.defaults . Here are some examples - { \"CellCycle\" : { \"features\" : \"cc.genes.updated.2019\" }, \"Exhaustion\" : { \"features\" : \"HAVCR2,ENTPD1,LAYN,LAG3\" }, \"Activation\" : { \"features\" : \"IFNG\" }, \"Proliferation\" : { \"features\" : \"STMN1,TUBB\" } } For CellCycle , the columns S.Score , G2M.Score and Phase will be added to the metadata. S.Score and G2M.Score are the cell cycle scores for each cell, and Phase is the cell cycle phase for each cell. You can also add Diffusion Components (DC) to the modules { \"DC\" : { \"features\" : 2 , \"kind\" : \"diffmap\" }} will perform diffusion map as a reduction and add the first 2 components as DC_1 and DC_2 to the metadata. diffmap is a shortcut for diffusion_map . Other key-value pairs will pass to destiny::DiffusionMap() . You can later plot the diffusion map by using reduction = \"DC\" in env.dimplots in SeuratClusterStats . This requires SingleCellExperiment and destiny R packages.","title":"Environment Variables"},{"location":"processes/ModuleScoreCalculator/#metadata","text":"The metadata of the Seurat object will be updated with the module scores:","title":"Metadata"},{"location":"processes/RadarPlots/","text":"RadarPlots \u00b6 Radar plots for cell proportion in different clusters. This process generates the radar plots for the clusters of T cells. It explores the proportion of cells in different groups (e.g. Tumor vs Blood) in different T-cell clusters. Input \u00b6 srtobj : The seurat object in RDS format Output \u00b6 outdir : Default: {{in.srtobj | stem}}.radar_plots . The output directory for the plots Environment Variables \u00b6 mutaters ( type=json ) : Default: {} . Mutaters to mutate the metadata of the seurat object. Keys are the column names and values are the expressions to mutate the columns. These new columns will be used to define your cases.. See also mutating the metadata . by : Which column to use to separate the cells in different groups. NA s will be ignored. For example, If you have a column named Source that marks the source of the cells, and you want to separate the cells into Tumor and Blood groups, you can set by to Source . The there will be two curves in the radar plot, one for Tumor and one for Blood . each : A column with values to separate all cells in different cases When specified, the case will be expanded to multiple cases for each value in the column. If specified, section will be ignored, and the case name will be used as the section name. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the values as the case/section name. breakdown : An additional column with groups to break down the cells distribution in each cluster. For example, if you want to see the distribution of the cells in each cluster in different samples. In this case, you should have multiple values in each by . These values won't be plotted in the radar plot, but a barplot will be generated with the mean value of each group and the error bar. test ( choice ) : Default: wilcox . The test to use to calculate the p values. If there are more than 2 groups in by , the p values will be calculated pairwise group by group. Only works when breakdown is specified and by has 2 groups or more. wilcox : Wilcoxon rank sum test t : T test none : No test will be performed order ( list ) : The order of the values in by . You can also limit (filter) the values we have in by . For example, if column Source has values Tumor , Blood , Spleen , and you only want to plot Tumor and Blood , you can set order to [\"Tumor\", \"Blood\"] . This will also have Tumor as the first item in the legend and Blood as the second item. colors : The colors for the groups in by . If not specified, the default colors will be used. Multiple colors can be separated by comma ( , ). You can specify biopipen to use the biopipen palette. ident : Default: seurat_clusters . The column name of the cluster information. cluster_order ( list ) : Default: [] . The order of the clusters. You may also use it to filter the clusters. If not given, all clusters will be used. If the cluster names are integers, use them directly for the order, even though a prefix Cluster is added on the plot. breaks ( list;itype=int ) : Default: [] . breaks of the radar plots, from 0 to 100. If not given, the breaks will be calculated automatically. direction ( choice ) : Default: intra-cluster . Direction to calculate the percentages. inter-cluster : the percentage of the cells in all groups in each cluster (percentage adds up to 1 for each cluster). intra-cluster : the percentage of the cells in all clusters. (percentage adds up to 1 for each group). section : Default: DEFAULT . If you want to put multiple cases into a same section in the report, you can set this option to the name of the section. Only used in the report. subset : The subset of the cells to do the analysis. bar_devpars ( ns ) : The parameters for png() for the barplot res ( type=int ) : Default: 100 . The resolution of the plot height ( type=int ) : Default: 800 . The height of the plot width ( type=int ) : Default: 1200 . The width of the plot devpars ( ns ) : The parameters for png() res ( type=int ) : Default: 100 . The resolution of the plot height ( type=int ) : Default: 1000 . The height of the plot width ( type=int ) : Default: 1200 . The width of the plot cases ( type=json ) : Default: {} . The cases for the multiple radar plots. Keys are the names of the cases and values are the arguments for the plots ( each , by , order , breaks , direction , ident , cluster_order and devpars ). If not cases are given, a default case will be used, with the key DEFAULT . The keys must be valid string as part of the file name. Examples \u00b6 Let's say we have a metadata like this: Cell Source Timepoint seurat_clusters A Blood Pre 0 B Blood Pre 0 C Blood Post 1 D Blood Post 1 E Tumor Pre 2 F Tumor Pre 2 G Tumor Post 3 H Tumor Post 3 With configurations: [RadarPlots.envs] by = \"Source\" Then we will have a radar plots like this: We can use each to separate the cells into different cases: [RadarPlots.envs] by = \"Source\" each = \"Timepoint\" Then we will have two radar plots, one for Pre and one for Post : Using cluster_order to change the order of the clusters and show only the first 3 clusters: [RadarPlots.envs] by = \"Source\" cluster_order = [ \"2\" , \"0\" , \"1\" ] breaks = [ 0 , 50 , 100 ] # also change the breaks Attention All the plots used in the examples are just for demonstration purpose. The real plots will have different appearance.","title":"RadarPlots"},{"location":"processes/RadarPlots/#radarplots","text":"Radar plots for cell proportion in different clusters. This process generates the radar plots for the clusters of T cells. It explores the proportion of cells in different groups (e.g. Tumor vs Blood) in different T-cell clusters.","title":"RadarPlots"},{"location":"processes/RadarPlots/#input","text":"srtobj : The seurat object in RDS format","title":"Input"},{"location":"processes/RadarPlots/#output","text":"outdir : Default: {{in.srtobj | stem}}.radar_plots . The output directory for the plots","title":"Output"},{"location":"processes/RadarPlots/#environment-variables","text":"mutaters ( type=json ) : Default: {} . Mutaters to mutate the metadata of the seurat object. Keys are the column names and values are the expressions to mutate the columns. These new columns will be used to define your cases.. See also mutating the metadata . by : Which column to use to separate the cells in different groups. NA s will be ignored. For example, If you have a column named Source that marks the source of the cells, and you want to separate the cells into Tumor and Blood groups, you can set by to Source . The there will be two curves in the radar plot, one for Tumor and one for Blood . each : A column with values to separate all cells in different cases When specified, the case will be expanded to multiple cases for each value in the column. If specified, section will be ignored, and the case name will be used as the section name. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the values as the case/section name. breakdown : An additional column with groups to break down the cells distribution in each cluster. For example, if you want to see the distribution of the cells in each cluster in different samples. In this case, you should have multiple values in each by . These values won't be plotted in the radar plot, but a barplot will be generated with the mean value of each group and the error bar. test ( choice ) : Default: wilcox . The test to use to calculate the p values. If there are more than 2 groups in by , the p values will be calculated pairwise group by group. Only works when breakdown is specified and by has 2 groups or more. wilcox : Wilcoxon rank sum test t : T test none : No test will be performed order ( list ) : The order of the values in by . You can also limit (filter) the values we have in by . For example, if column Source has values Tumor , Blood , Spleen , and you only want to plot Tumor and Blood , you can set order to [\"Tumor\", \"Blood\"] . This will also have Tumor as the first item in the legend and Blood as the second item. colors : The colors for the groups in by . If not specified, the default colors will be used. Multiple colors can be separated by comma ( , ). You can specify biopipen to use the biopipen palette. ident : Default: seurat_clusters . The column name of the cluster information. cluster_order ( list ) : Default: [] . The order of the clusters. You may also use it to filter the clusters. If not given, all clusters will be used. If the cluster names are integers, use them directly for the order, even though a prefix Cluster is added on the plot. breaks ( list;itype=int ) : Default: [] . breaks of the radar plots, from 0 to 100. If not given, the breaks will be calculated automatically. direction ( choice ) : Default: intra-cluster . Direction to calculate the percentages. inter-cluster : the percentage of the cells in all groups in each cluster (percentage adds up to 1 for each cluster). intra-cluster : the percentage of the cells in all clusters. (percentage adds up to 1 for each group). section : Default: DEFAULT . If you want to put multiple cases into a same section in the report, you can set this option to the name of the section. Only used in the report. subset : The subset of the cells to do the analysis. bar_devpars ( ns ) : The parameters for png() for the barplot res ( type=int ) : Default: 100 . The resolution of the plot height ( type=int ) : Default: 800 . The height of the plot width ( type=int ) : Default: 1200 . The width of the plot devpars ( ns ) : The parameters for png() res ( type=int ) : Default: 100 . The resolution of the plot height ( type=int ) : Default: 1000 . The height of the plot width ( type=int ) : Default: 1200 . The width of the plot cases ( type=json ) : Default: {} . The cases for the multiple radar plots. Keys are the names of the cases and values are the arguments for the plots ( each , by , order , breaks , direction , ident , cluster_order and devpars ). If not cases are given, a default case will be used, with the key DEFAULT . The keys must be valid string as part of the file name.","title":"Environment Variables"},{"location":"processes/RadarPlots/#examples","text":"Let's say we have a metadata like this: Cell Source Timepoint seurat_clusters A Blood Pre 0 B Blood Pre 0 C Blood Post 1 D Blood Post 1 E Tumor Pre 2 F Tumor Pre 2 G Tumor Post 3 H Tumor Post 3 With configurations: [RadarPlots.envs] by = \"Source\" Then we will have a radar plots like this: We can use each to separate the cells into different cases: [RadarPlots.envs] by = \"Source\" each = \"Timepoint\" Then we will have two radar plots, one for Pre and one for Post : Using cluster_order to change the order of the clusters and show only the first 3 clusters: [RadarPlots.envs] by = \"Source\" cluster_order = [ \"2\" , \"0\" , \"1\" ] breaks = [ 0 , 50 , 100 ] # also change the breaks Attention All the plots used in the examples are just for demonstration purpose. The real plots will have different appearance.","title":"Examples"},{"location":"processes/SampleInfo/","text":"SampleInfo \u00b6 List sample information and perform statistics This process is the entrance of the pipeline. It just pass by input file and list the sample information in the report. To specify the input file in the configuration file, use the following [SampleInfo.in] infile = [ \"path/to/sample_info.txt\" ] Or with pipen-board , find the SampleInfo process and click the Edit button. Then you can specify the input file here Theroetically, we can have multiple input files. However, it is not tested yet. If you have multiple input files to run, please run it with a different pipeline instance (configuration file). For the content of the input file, please see details here . Once the pipeline is finished, you can see the sample information in the report Note that the required RNAData and TCRData columns are not shown in the report. They are used to specify the paths of the scRNA-seq and scTCR-seq data, respectively. You may also perform some statistics on the sample information, for example, number of samples per group. See next section for details. Tip This is the start process of the pipeline. Once you change the parameters for this process, the whole pipeline will be re-run. If you just want to change the parameters for the statistics, and use the cached (previous) results for other processes, you can set cache at pipeline level to \"force\" to force the pipeline to use the cached results and cache of SampleInfo to false to force the pipeline to re-run the SampleInfo process only. cache = \"force\" [SampleInfo] cache = false Input \u00b6 infile ( required ) : The input file to list sample information The input file should be a csv/tsv file with header. The input file should have the following columns. Sample: A unique id for each sample. TCRData: The directory for single-cell TCR data for this sample. Specifically, it should contain filtered_contig_annotations.csv or all_contig_annotations.csv from cellranger. RNAData: The directory for single-cell RNA data for this sample. Specifically, it should be able to be read by Seurat::Read10X() . See also https://satijalab.org/seurat/reference/read10x. Other columns are optional and will be treated as metadata for each sample. Output \u00b6 outfile : Default: {{in.infile | basename}} . The output file with sample information, with mutated columns if envs.save_mutated is True. Environment Variables \u00b6 sep : Default: . The separator of the input file. mutaters ( type=json ) : Default: {} . A dict of mutaters to mutate the data frame. The key is the column name and the value is the R expression to mutate the column. The dict will be transformed to a list in R and passed to dplyr::mutate . You may also use paired() to identify paired samples. The function takes following arguments: df : The data frame. Use . if the function is called in a dplyr pipe. id_col : The column name in df for the ids to be returned in the final output. compare_col : The column name in df to compare the values for each id in id_col . idents : The values in compare_col to compare. It could be either an an integer or a vector. If it is an integer, the number of values in compare_col must be the same as the integer for the id to be regarded as paired. If it is a vector, the values in compare_col must be the same as the values in idents for the id to be regarded as paired. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. Non-paired ids will be NA . save_mutated ( flag ) : Default: False . Whether to save the mutated columns. exclude_cols : Default: TCRData,RNAData . The columns to exclude in the table in the report. Could be a list or a string separated by comma. defaults ( ns ) : The default parameters for envs.stats . on : Default: Sample . The column name in the data for the stats. Default is Sample . The column could be either continuous or not. subset : An R expression to subset the data. If you want to keep the distinct records, you can use !duplicated(<col>) . group : The column name in the data for the group ids. If not provided, all records will be regarded as one group. na_group ( flag ) : Default: False . Whether to include NA s in the group. each : The column in the data to split the analysis in different plots. ncol ( type=int ) : Default: 2 . The number of columns in the plot when each is not NULL . Default is 2. na_each ( flag ) : Default: False . Whether to include NA s in the each column. plot : Type of plot. If on is continuous, it could be boxplot (default), violin , violin+boxplot or histogram . If on is not continuous, it could be barplot or pie (default). devpars ( ns ) : The device parameters for the plot. width ( type=int ) : Default: 800 . The width of the plot. height ( type=int ) : Default: 600 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. stats ( type=json ) : Default: {} . The statistics to perform. The keys are the case names and the values are the parameters inheirted from envs.defaults . Examples \u00b6 Example data \u00b6 Sample Age Sex Diagnosis C1 62 F Colitis C2 71.2 F Colitis C3 56.2 M Colitis C4 61.5 M Colitis C5 72.8 M Colitis C6 78.4 M Colitis C7 61.6 F Colitis C8 49.5 F Colitis NC1 43.6 M NoColitis NC2 68.1 M NoColitis NC3 70.5 F NoColitis NC4 63.7 M NoColitis NC5 58.5 M NoColitis NC6 49.3 F NoColitis CT1 21.4 F Control CT2 61.7 M Control CT3 50.5 M Control CT4 43.4 M Control CT5 70.6 F Control CT6 44.3 M Control CT7 50.2 M Control CT8 61.5 F Control Count the number of samples per Diagnosis \u00b6 [SampleInfo.envs.stats. \"N_Samples_per_Diagnosis (pie)\" ] on = \"sample\" group = \"Diagnosis\" What if we want a bar plot instead of a pie chart? [SampleInfo.envs.stats. \"N_Samples_per_Diagnosis (bar)\" ] on = \"sample\" group = \"Diagnosis\" plot = \"barplot\" Explore Age distribution \u00b6 The distribution of Age of all samples [SampleInfo.envs.stats. \"Age_distribution (boxplot)\" ] on = \"Age\" How about the distribution of Age in each Diagnosis, and make it violin + boxplot? [SampleInfo.envs.stats. \"Age_distribution_per_Diagnosis (violin + boxplot)\" ] on = \"Age\" group = \"Diagnosis\" plot = \"violin+boxplot\" How about Age distribution per Sex in each Diagnosis? [SampleInfo.envs.stats. \"Age_distribution_per_Sex_in_each_Diagnosis (boxplot)\" ] on = \"Age\" group = \"Sex\" each = \"Diagnosis\" plot = \"boxplot\" ncol = 3 devpars = { height = 450 }","title":"SampleInfo"},{"location":"processes/SampleInfo/#sampleinfo","text":"List sample information and perform statistics This process is the entrance of the pipeline. It just pass by input file and list the sample information in the report. To specify the input file in the configuration file, use the following [SampleInfo.in] infile = [ \"path/to/sample_info.txt\" ] Or with pipen-board , find the SampleInfo process and click the Edit button. Then you can specify the input file here Theroetically, we can have multiple input files. However, it is not tested yet. If you have multiple input files to run, please run it with a different pipeline instance (configuration file). For the content of the input file, please see details here . Once the pipeline is finished, you can see the sample information in the report Note that the required RNAData and TCRData columns are not shown in the report. They are used to specify the paths of the scRNA-seq and scTCR-seq data, respectively. You may also perform some statistics on the sample information, for example, number of samples per group. See next section for details. Tip This is the start process of the pipeline. Once you change the parameters for this process, the whole pipeline will be re-run. If you just want to change the parameters for the statistics, and use the cached (previous) results for other processes, you can set cache at pipeline level to \"force\" to force the pipeline to use the cached results and cache of SampleInfo to false to force the pipeline to re-run the SampleInfo process only. cache = \"force\" [SampleInfo] cache = false","title":"SampleInfo"},{"location":"processes/SampleInfo/#input","text":"infile ( required ) : The input file to list sample information The input file should be a csv/tsv file with header. The input file should have the following columns. Sample: A unique id for each sample. TCRData: The directory for single-cell TCR data for this sample. Specifically, it should contain filtered_contig_annotations.csv or all_contig_annotations.csv from cellranger. RNAData: The directory for single-cell RNA data for this sample. Specifically, it should be able to be read by Seurat::Read10X() . See also https://satijalab.org/seurat/reference/read10x. Other columns are optional and will be treated as metadata for each sample.","title":"Input"},{"location":"processes/SampleInfo/#output","text":"outfile : Default: {{in.infile | basename}} . The output file with sample information, with mutated columns if envs.save_mutated is True.","title":"Output"},{"location":"processes/SampleInfo/#environment-variables","text":"sep : Default: . The separator of the input file. mutaters ( type=json ) : Default: {} . A dict of mutaters to mutate the data frame. The key is the column name and the value is the R expression to mutate the column. The dict will be transformed to a list in R and passed to dplyr::mutate . You may also use paired() to identify paired samples. The function takes following arguments: df : The data frame. Use . if the function is called in a dplyr pipe. id_col : The column name in df for the ids to be returned in the final output. compare_col : The column name in df to compare the values for each id in id_col . idents : The values in compare_col to compare. It could be either an an integer or a vector. If it is an integer, the number of values in compare_col must be the same as the integer for the id to be regarded as paired. If it is a vector, the values in compare_col must be the same as the values in idents for the id to be regarded as paired. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. Non-paired ids will be NA . save_mutated ( flag ) : Default: False . Whether to save the mutated columns. exclude_cols : Default: TCRData,RNAData . The columns to exclude in the table in the report. Could be a list or a string separated by comma. defaults ( ns ) : The default parameters for envs.stats . on : Default: Sample . The column name in the data for the stats. Default is Sample . The column could be either continuous or not. subset : An R expression to subset the data. If you want to keep the distinct records, you can use !duplicated(<col>) . group : The column name in the data for the group ids. If not provided, all records will be regarded as one group. na_group ( flag ) : Default: False . Whether to include NA s in the group. each : The column in the data to split the analysis in different plots. ncol ( type=int ) : Default: 2 . The number of columns in the plot when each is not NULL . Default is 2. na_each ( flag ) : Default: False . Whether to include NA s in the each column. plot : Type of plot. If on is continuous, it could be boxplot (default), violin , violin+boxplot or histogram . If on is not continuous, it could be barplot or pie (default). devpars ( ns ) : The device parameters for the plot. width ( type=int ) : Default: 800 . The width of the plot. height ( type=int ) : Default: 600 . The height of the plot. res ( type=int ) : Default: 100 . The resolution of the plot. stats ( type=json ) : Default: {} . The statistics to perform. The keys are the case names and the values are the parameters inheirted from envs.defaults .","title":"Environment Variables"},{"location":"processes/SampleInfo/#examples","text":"","title":"Examples"},{"location":"processes/SampleInfo/#example-data","text":"Sample Age Sex Diagnosis C1 62 F Colitis C2 71.2 F Colitis C3 56.2 M Colitis C4 61.5 M Colitis C5 72.8 M Colitis C6 78.4 M Colitis C7 61.6 F Colitis C8 49.5 F Colitis NC1 43.6 M NoColitis NC2 68.1 M NoColitis NC3 70.5 F NoColitis NC4 63.7 M NoColitis NC5 58.5 M NoColitis NC6 49.3 F NoColitis CT1 21.4 F Control CT2 61.7 M Control CT3 50.5 M Control CT4 43.4 M Control CT5 70.6 F Control CT6 44.3 M Control CT7 50.2 M Control CT8 61.5 F Control","title":"Example data"},{"location":"processes/SampleInfo/#count-the-number-of-samples-per-diagnosis","text":"[SampleInfo.envs.stats. \"N_Samples_per_Diagnosis (pie)\" ] on = \"sample\" group = \"Diagnosis\" What if we want a bar plot instead of a pie chart? [SampleInfo.envs.stats. \"N_Samples_per_Diagnosis (bar)\" ] on = \"sample\" group = \"Diagnosis\" plot = \"barplot\"","title":"Count the number of samples per Diagnosis"},{"location":"processes/SampleInfo/#explore-age-distribution","text":"The distribution of Age of all samples [SampleInfo.envs.stats. \"Age_distribution (boxplot)\" ] on = \"Age\" How about the distribution of Age in each Diagnosis, and make it violin + boxplot? [SampleInfo.envs.stats. \"Age_distribution_per_Diagnosis (violin + boxplot)\" ] on = \"Age\" group = \"Diagnosis\" plot = \"violin+boxplot\" How about Age distribution per Sex in each Diagnosis? [SampleInfo.envs.stats. \"Age_distribution_per_Sex_in_each_Diagnosis (boxplot)\" ] on = \"Age\" group = \"Sex\" each = \"Diagnosis\" plot = \"boxplot\" ncol = 3 devpars = { height = 450 }","title":"Explore Age distribution"},{"location":"processes/ScFGSEA/","text":"ScFGSEA \u00b6 Gene set enrichment analysis for cells in different groups using fgsea This process allows us to do Gene Set Enrichment Analysis (GSEA) on the expression data, but based on variaties of grouping, including the from the meta data and the scTCR-seq data as well. The GSEA is done using the fgsea package, which allows to quickly and accurately calculate arbitrarily low GSEA P-values for a collection of gene sets. The fgsea package is based on the fast algorithm for preranked GSEA described in Subramanian et al. 2005 . For each case, the process will generate a table with the enrichment scores for each gene set, and GSEA plots for the top gene sets. Input \u00b6 srtobj : The seurat object in RDS format Output \u00b6 outdir : Default: {{(in.casefile or in.srtobj) | stem0}}.fgsea . The output directory for the results Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores for parallelization Passed to nproc of fgseaMultilevel() . mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata. The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . group-by : The column name in metadata to group the cells. ident-1 : The first group of cells to compare ident-2 : The second group of cells to compare, if not provided, the rest of the cells that are not NA s in group-by column are used for ident-2 . each : The column name in metadata to separate the cells into different subsets to do the analysis. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the values as the case/section name. subset : An expression to subset the cells. section : Default: DEFAULT . The section name for the report. Worked only when each is not specified. Otherwise, the section name will be constructed from each and its value. This allows different cases to be put into the same section in the report. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. gmtfile : Default: \"\" . The pathways in GMT format, with the gene names/ids in the same format as the seurat object. One could also use a URL to a GMT file. For example, from https://download.baderlab.org/EM_Genesets/current_release/Human/symbol/Pathways/ . method ( choice ) : Default: s2n . The method to do the preranking. signal_to_noise : Signal to noise. The larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \"class marker\". s2n : Alias of signal_to_noise. abs_signal_to_noise : The absolute value of signal_to_noise. abs_s2n : Alias of abs_signal_to_noise. t_test : T test. Uses the difference of means scaled by the standard deviation and number of samples. ratio_of_classes : Also referred to as fold change. Uses the ratio of class means to calculate fold change for natural scale data. diff_of_classes : Difference of class means. Uses the difference of class means to calculate fold change for nature scale data log2_ratio_of_classes : Log2 ratio of class means. Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. top ( type=auto ) : Default: 20 . Do gsea table and enrich plot for top N pathways. If it is < 1, will apply it to padj , selecting pathways with padj < top . eps ( type=float ) : Default: 0 . This parameter sets the boundary for calculating the p value. See https://rdrr.io/bioc/fgsea/man/fgseaMultilevel.html minsize ( type=int ) : Default: 10 . Minimal size of a gene set to test. All pathways below the threshold are excluded. maxsize ( type=int ) : Default: 100 . Maximal size of a gene set to test. All pathways above the threshold are excluded. rest ( type=json;order=98 ) : Default: {} . Rest arguments for fgsea() See also https://rdrr.io/bioc/fgsea/man/fgseaMultilevel.html cases ( type=json;order=99 ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the name DEFAULT .","title":"ScFGSEA"},{"location":"processes/ScFGSEA/#scfgsea","text":"Gene set enrichment analysis for cells in different groups using fgsea This process allows us to do Gene Set Enrichment Analysis (GSEA) on the expression data, but based on variaties of grouping, including the from the meta data and the scTCR-seq data as well. The GSEA is done using the fgsea package, which allows to quickly and accurately calculate arbitrarily low GSEA P-values for a collection of gene sets. The fgsea package is based on the fast algorithm for preranked GSEA described in Subramanian et al. 2005 . For each case, the process will generate a table with the enrichment scores for each gene set, and GSEA plots for the top gene sets.","title":"ScFGSEA"},{"location":"processes/ScFGSEA/#input","text":"srtobj : The seurat object in RDS format","title":"Input"},{"location":"processes/ScFGSEA/#output","text":"outdir : Default: {{(in.casefile or in.srtobj) | stem0}}.fgsea . The output directory for the results","title":"Output"},{"location":"processes/ScFGSEA/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores for parallelization Passed to nproc of fgseaMultilevel() . mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata. The key-value pairs will be passed the dplyr::mutate() to mutate the metadata. There are also also 4 helper functions, expanded , collapsed , emerged and vanished , which can be used to identify the expanded/collpased/emerged/vanished groups (i.e. TCR clones). See also https://pwwang.github.io/immunopipe/configurations/#mutater-helpers . For example, you can use {\"Patient1_Tumor_Collapsed_Clones\": \"expanded(., Source, 'Tumor', subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Tumor_Collapsed_Clones with the collapsed clones in the tumor sample (compared to the normal sample) of patient 1. The values in this columns for other clones will be NA . Those functions take following arguments: df : The metadata data frame. You can use the . to refer to it. group.by : The column name in metadata to group the cells. idents : The first group or both groups of cells to compare (value in group.by column). If only the first group is given, the rest of the cells (with non-NA in group.by column) will be used as the second group. subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). id : The column name in metadata for the group ids (i.e. CDR3.aa ). compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . order : The expression passed to dplyr::arrange() to order intermediate dataframe and get the ids in order accordingly. The intermediate dataframe includes the following columns: <id> : The ids of clones (i.e. CDR3.aa ). <each> : The values in each column. ident_1 : The size of clones in the first group. ident_2 : The size of clones in the second group. .diff : The difference between the sizes of clones in the first and second groups. .sum : The sum of the sizes of clones in the first and second groups. .predicate : Showing whether the clone is expanded/collapsed/emerged/vanished. include_emerged : Whether to include the emerged group for expanded (only works for expanded ). Default is FALSE . include_vanished : Whether to include the vanished group for collapsed (only works for collapsed ). Default is FALSE . You can also use top() to get the top clones (i.e. the clones with the largest size) in each group. For example, you can use {\"Patient1_Top10_Clones\": \"top(subset = Patent == 'Patient1', uniq = FALSE)\"} to create a new column in metadata named Patient1_Top10_Clones . The values in this columns for other clones will be NA . This function takes following arguments: * df : The metadata data frame. You can use the . to refer to it. * id : The column name in metadata for the group ids (i.e. CDR3.aa ). * n : The number of top clones to return. Default is 10 . If n < 1, it will be treated as the percentage of the size of the group. Specify 0 to get all clones. * compare : Either a (numeric) column name (i.e. Clones ) in metadata to compare between groups, or .n to compare the number of cells in each group. If numeric column is given, the values should be the same for all cells in the same group. This will not be checked (only the first value is used). It is helpful to use Clones to use the raw clone size from TCR data, in case the cells are not completely mapped to RNA data. Also if you have subset set or NA s in group.by column, you should use .n to compare the number of cells in each group. * subset : An expression to subset the cells, will be passed to dplyr::filter() . Default is TRUE (no filtering). * each : A column name (without quotes) in metadata to split the cells. Each comparison will be done for each value in this column (typically each patient or subject). * uniq : Whether to return unique ids or not. Default is TRUE . If FALSE , you can mutate the meta data frame with the returned ids. For example, df |> mutate(expanded = expanded(...)) . * debug : Return the data frame with intermediate columns instead of the ids. Default is FALSE . * with_ties : Whether to include ties (i.e. clones with the same size as the last clone) or not. Default is FALSE . group-by : The column name in metadata to group the cells. ident-1 : The first group of cells to compare ident-2 : The second group of cells to compare, if not provided, the rest of the cells that are not NA s in group-by column are used for ident-2 . each : The column name in metadata to separate the cells into different subsets to do the analysis. prefix_each ( flag ) : Default: True . Whether to prefix the each column name to the values as the case/section name. subset : An expression to subset the cells. section : Default: DEFAULT . The section name for the report. Worked only when each is not specified. Otherwise, the section name will be constructed from each and its value. This allows different cases to be put into the same section in the report. The section is used to collect cases and put the results under the same directory and the same section in report. When each for a case is specified, the section will be ignored and case name will be used as section . The cases will be the expanded values in each column. When prefix_each is True, the column name specified by each will be prefixed to each value as directory name and expanded case name. gmtfile : Default: \"\" . The pathways in GMT format, with the gene names/ids in the same format as the seurat object. One could also use a URL to a GMT file. For example, from https://download.baderlab.org/EM_Genesets/current_release/Human/symbol/Pathways/ . method ( choice ) : Default: s2n . The method to do the preranking. signal_to_noise : Signal to noise. The larger the differences of the means (scaled by the standard deviations); that is, the more distinct the gene expression is in each phenotype and the more the gene acts as a \"class marker\". s2n : Alias of signal_to_noise. abs_signal_to_noise : The absolute value of signal_to_noise. abs_s2n : Alias of abs_signal_to_noise. t_test : T test. Uses the difference of means scaled by the standard deviation and number of samples. ratio_of_classes : Also referred to as fold change. Uses the ratio of class means to calculate fold change for natural scale data. diff_of_classes : Difference of class means. Uses the difference of class means to calculate fold change for nature scale data log2_ratio_of_classes : Log2 ratio of class means. Uses the log2 ratio of class means to calculate fold change for natural scale data. This is the recommended statistic for calculating fold change for log scale data. top ( type=auto ) : Default: 20 . Do gsea table and enrich plot for top N pathways. If it is < 1, will apply it to padj , selecting pathways with padj < top . eps ( type=float ) : Default: 0 . This parameter sets the boundary for calculating the p value. See https://rdrr.io/bioc/fgsea/man/fgseaMultilevel.html minsize ( type=int ) : Default: 10 . Minimal size of a gene set to test. All pathways below the threshold are excluded. maxsize ( type=int ) : Default: 100 . Maximal size of a gene set to test. All pathways above the threshold are excluded. rest ( type=json;order=98 ) : Default: {} . Rest arguments for fgsea() See also https://rdrr.io/bioc/fgsea/man/fgseaMultilevel.html cases ( type=json;order=99 ) : Default: {} . If you have multiple cases, you can specify them here. The keys are the names of the cases and the values are the above options except mutaters . If some options are not specified, the default values specified above will be used. If no cases are specified, the default case will be added with the name DEFAULT .","title":"Environment Variables"},{"location":"processes/ScrnaMetabolicLandscape/","text":"ScrnaMetabolicLandscape \u00b6 Metabolic landscape analysis for scRNA-seq data An abstract from https://github.com/LocasaleLab/Single-Cell-Metabolic-Landscape . See also https://pwwang.github.io/biopipen/pipelines/scrna_metabolic/ . This is a group of processes to analyze the metabolic landscape of single cell RNA-seq data. It collects a set of processes and owns a set of arguments. These arguments could either preset the default values for the processes or define the relationships between the processes. Processes \u00b6 The processes in this group implement part of the pipeline below from the original paper. The data preparation, preprocessing and clustering already done by other processes of this pipeline. The processes in this group are used to analyze the metabolic landscape of the data. MetabolicInput : Input for the metabolic pathway analysis pipeline for scRNA-seq data MetabolicExprImpution : Impute the missing values in the expression data MetabolicPathwayActivity : Calculate the pathway activities for each group MetabolicPathwayHeterogeneity : Calculate the pathway heterogeneity MetabolicFeatures : Inter-subset metabolic features - Enrichment analysis in details MetabolicFeaturesIntraSubset : Intra-subset metabolic features Group arguments \u00b6 noimpute ( flag ): Whether to do imputation for the dropouts. If False , the values will be left as is. gmtfile : The GMT file with the metabolic pathways. The gene names should match the gene names in the gene list in RNAData or the Seurat object grouping : It defines the basic groups to investigate the metabolic activity Typically the clusters. grouping_prefix : Working as a prefix to group names For example, if we have grouping_prefix = \"cluster\" and we have 1 and 2 in the grouping column, the groups will be named as cluster_1 and cluster_2 subsetting ( type=auto ): How do we subset the data. Other columns in the metadata to do comparisons. For example, \"TimePoint\" or [\"TimePoint\", \"Response\"] subsetting_prefix (type=auto): Working as a prefix to subset names For example, if we have subsetting_prefix = \"timepoint\" and we have pre and post in the subsetting column, the subsets will be named as timepoint_pre and timepoint_post If subsetting is a list, this should also be a same-length list. If a single string is given, it will be repeated to a list with the same length as subsetting subsetting_comparison (type=json): What kind of comparisons are we doing to compare cells from different subsets. It should be dict with keys as the names of the comparisons and values as the 2 comparison groups from the subsetting column. For example, if we have pre and post in the subsetting column, we could have subsetting_comparison = {\"pre_vs_post\": [\"post\", \"pre\"]} The second group will be the control group in the comparison. If we also have 1 , 2 and 3 in the grouping column, by default, the comparisons are done within each subset for each group. For example, for group 1 , groups 2 and 3 will be used as control, and for group 2 , groups 1 and 3 will be used as control, and for group 3 , groups 1 and 2 will be used as control. It is similar to Seurat::FindMarkers procedure. With this option, the comparisons are also done to compare cells from different subsets within each group. With the example above, we will have pre_vs_post comparisons within each group. If subsetting is a list, this must be a list of dicts with the same length. mutaters (type=json): Add new columns to the metadata for grouping/subsetting. They are passed to sobj@meta.data |> mutate(...) . For example, {\"timepoint\": \"if_else(treatment == 'control', 'pre', 'post')\"} will add a new column timepoint to the metadata with values of pre and post based on the treatment column. ncores (type=int): Number of cores to use for parallelization for each process Reference \u00b6 Xiao, Zhengtao, Ziwei Dai, and Jason W. Locasale. \"Metabolic landscape of the tumor microenvironment at single cell resolution.\" Nature communications 10.1 (2019): 1-12.","title":"Introduction & Group Arguments"},{"location":"processes/ScrnaMetabolicLandscape/#scrnametaboliclandscape","text":"Metabolic landscape analysis for scRNA-seq data An abstract from https://github.com/LocasaleLab/Single-Cell-Metabolic-Landscape . See also https://pwwang.github.io/biopipen/pipelines/scrna_metabolic/ . This is a group of processes to analyze the metabolic landscape of single cell RNA-seq data. It collects a set of processes and owns a set of arguments. These arguments could either preset the default values for the processes or define the relationships between the processes.","title":"ScrnaMetabolicLandscape"},{"location":"processes/ScrnaMetabolicLandscape/#processes","text":"The processes in this group implement part of the pipeline below from the original paper. The data preparation, preprocessing and clustering already done by other processes of this pipeline. The processes in this group are used to analyze the metabolic landscape of the data. MetabolicInput : Input for the metabolic pathway analysis pipeline for scRNA-seq data MetabolicExprImpution : Impute the missing values in the expression data MetabolicPathwayActivity : Calculate the pathway activities for each group MetabolicPathwayHeterogeneity : Calculate the pathway heterogeneity MetabolicFeatures : Inter-subset metabolic features - Enrichment analysis in details MetabolicFeaturesIntraSubset : Intra-subset metabolic features","title":"Processes"},{"location":"processes/ScrnaMetabolicLandscape/#group-arguments","text":"noimpute ( flag ): Whether to do imputation for the dropouts. If False , the values will be left as is. gmtfile : The GMT file with the metabolic pathways. The gene names should match the gene names in the gene list in RNAData or the Seurat object grouping : It defines the basic groups to investigate the metabolic activity Typically the clusters. grouping_prefix : Working as a prefix to group names For example, if we have grouping_prefix = \"cluster\" and we have 1 and 2 in the grouping column, the groups will be named as cluster_1 and cluster_2 subsetting ( type=auto ): How do we subset the data. Other columns in the metadata to do comparisons. For example, \"TimePoint\" or [\"TimePoint\", \"Response\"] subsetting_prefix (type=auto): Working as a prefix to subset names For example, if we have subsetting_prefix = \"timepoint\" and we have pre and post in the subsetting column, the subsets will be named as timepoint_pre and timepoint_post If subsetting is a list, this should also be a same-length list. If a single string is given, it will be repeated to a list with the same length as subsetting subsetting_comparison (type=json): What kind of comparisons are we doing to compare cells from different subsets. It should be dict with keys as the names of the comparisons and values as the 2 comparison groups from the subsetting column. For example, if we have pre and post in the subsetting column, we could have subsetting_comparison = {\"pre_vs_post\": [\"post\", \"pre\"]} The second group will be the control group in the comparison. If we also have 1 , 2 and 3 in the grouping column, by default, the comparisons are done within each subset for each group. For example, for group 1 , groups 2 and 3 will be used as control, and for group 2 , groups 1 and 3 will be used as control, and for group 3 , groups 1 and 2 will be used as control. It is similar to Seurat::FindMarkers procedure. With this option, the comparisons are also done to compare cells from different subsets within each group. With the example above, we will have pre_vs_post comparisons within each group. If subsetting is a list, this must be a list of dicts with the same length. mutaters (type=json): Add new columns to the metadata for grouping/subsetting. They are passed to sobj@meta.data |> mutate(...) . For example, {\"timepoint\": \"if_else(treatment == 'control', 'pre', 'post')\"} will add a new column timepoint to the metadata with values of pre and post based on the treatment column. ncores (type=int): Number of cores to use for parallelization for each process","title":"Group arguments"},{"location":"processes/ScrnaMetabolicLandscape/#reference","text":"Xiao, Zhengtao, Ziwei Dai, and Jason W. Locasale. \"Metabolic landscape of the tumor microenvironment at single cell resolution.\" Nature communications 10.1 (2019): 1-12.","title":"Reference"},{"location":"processes/SeuratClusterStats/","text":"SeuratClusterStats \u00b6 Statistics of the clustering. Including the number/fraction of cells in each cluster, the gene expression values and dimension reduction plots. It's also possible to perform stats on TCR clones/clusters or other metadata for each T-cell cluster. Input \u00b6 srtobj : The seurat object loaded by SeuratClustering Output \u00b6 outdir : Default: {{in.srtobj | stem}}.cluster_stats . The output directory Environment Variables \u00b6 mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata to subset the cells. The mutaters will be applied in the order specified. clustrees_defaults ( ns ) : The parameters for the clustree plots. devpars ( ns ) : The device parameters for the clustree plot. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 1000 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. prefix : Default: _auto . string indicating columns containing clustering information. The trailing dot is not necessary and will be added automatically. When _auto , clustrees will be plotted when there is FindClusters or FindClusters.* in the obj@commands . The latter is generated by SeuratSubClustering . This will be ignored when envs.clustrees is specified. <more> : Other arguments passed to clustree::clustree() . See https://rdrr.io/cran/clustree/man/clustree.html clustrees ( type=json ) : Default: {} . The cases for clustree plots. Keys are the names of the plots and values are the dicts inherited from env.clustrees_defaults except prefix . There is no default case for clustrees . hists_defaults ( ns ) : The default parameters for histograms. This will plot histograms for the number of cells along x . For example, you can plot the number of cells along cell activity score. x : The column name in metadata to plot as the x-axis. The NA values will be removed. It could be either numeric or factor/character. x_order ( list ) : Default: [] . The order of the x-axis, only works for factor/character x . You can also use it to subset x (showing only a subset values of x ). cells_by : A column name in metadata to group the cells. The NA values will be removed. It should be a factor/character. if not specified, all cells will be used. cells_order ( list ) : Default: [] . The order of the cell groups for the plots. It should be a list of strings. You can also use cells_orderby and cells_n to determine the order. cells_orderby : An expression passed to dplyr::arrange() to order the cell groups. cells_n : Default: 10 . The number of cell groups to show. Ignored if cells_order is specified. ncol ( type=int ) : Default: 2 . The number of columns for the plots, split by cells_by . subset : An expression to subset the cells, will be passed to dplyr::filter() . each : Whether to plot each group separately. bins : Default: 30 . The number of bins to use, only works for numeric x . plus ( list ) : Default: [] . The extra elements to add to the ggplot object. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. hists ( type=json ) : Default: {} . The cases for histograms. Keys are the names of the plots and values are the dicts inherited from env.hists_defaults . There is no default case. stats_defaults ( ns ) : The default parameters for stats . This is to do some basic statistics on the clusters. For more comprehensive analysis, see RadarPlots and CellsDistribution . The parameters from the cases can overwrite the default parameters. frac ( choice ) : Default: none . How to calculate the fraction of cells. group : calculate the fraction in each group. The total fraction of the cells of idents in each group will be 1. When group-by is not specified, it will be the same as all . ident : calculate the fraction in each ident. The total fraction of the cells of groups in each ident will be 1. Only works when group-by is specified. cluster : alias of ident . all : calculate the fraction against all cells. none : do not calculate the fraction, use the number of cells instead. pie ( flag ) : Default: False . Also output a pie chart? circos ( flag ) : Default: False . Also output a circos plot? table ( flag ) : Default: False . Whether to output a table (in tab-delimited format) and in the report. transpose ( flag ) : Default: False . Whether to transpose the cluster and group, that is, using group as the x-axis and cluster to fill the plot. For circos plot, when transposed, the arrows will be drawn from the idents (by ident ) to the the groups (by group-by ). Only works when group-by is specified. position ( choice ) : Default: auto . The position of the bars. Does not work for pie and circos plots. stack : Use position_stack() . fill : Use position_fill() . dodge : Use position_dodge() . auto : Use stack when there are more than 5 groups, otherwise use dodge . ident : Default: seurat_clusters . The column name in metadata to use as the identity. group-by : The column name in metadata to group the cells. Does NOT support for pie charts. split-by : The column name in metadata to split the cells into different plots. Does NOT support for circos plots. subset : An expression to subset the cells, will be passed to dplyr::filter() on metadata. circos_labels_rot ( flag ) : Default: False . Whether to rotate the labels in the circos plot. In case the labels are too long. circos_devpars ( ns ) : The device parameters for the circos plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 600 . The width of the plots. pie_devpars ( ns ) : The device parameters for the pie charts. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. stats ( type=json ) : Default: {'Number of cells in each cluster': Diot({'pie': True}), 'Number of cells in each cluster by Sample': Diot({'group-by': 'Sample', 'table': True, 'frac': 'group'})} . The number/fraction of cells to plot. Keys are the names of the plots and values are the dicts inherited from env.stats_defaults . Here are some examples - { \"nCells_All\" : {}, \"nCells_Sample\" : { \"group-by\" : \"Sample\" }, \"fracCells_Sample\" : { \"frac\" : True , \"group-by\" : \"Sample\" }, } ngenes_defaults ( ns ) : The default parameters for ngenes . The default parameters to plot the number of genes expressed in each cell. ident : Default: seurat_clusters . The column name in metadata to use as the identity. group-by : The column name in metadata to group the cells. Dodge position will be used to separate the groups. split-by : The column name in metadata to split the cells into different plots. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 800 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. ngenes ( type=json ) : Default: {'Number of genes expressed in each cluster': Diot({})} . The number of genes expressed in each cell. Keys are the names of the plots and values are the dicts inherited from env.ngenes_defaults . features_defaults ( ns ) : The default parameters for features . features : The features to plot. It can be either a string with comma separated features, a list of features, a file path with file:// prefix with features (one per line), or an integer to use the top N features from VariantFeatures(srtobj) . ident : Default: seurat_clusters . The column name in metadata to use as the identity. If it is from subclustering (reduction sub_umap_<ident> exists), the reduction will be used. cluster_orderby ( type=auto ) : The order of the clusters to show on the plot. An expression passed to dplyr::summarise() on the grouped data frame (by seurat_clusters ). The summary stat will be passed to dplyr::arrange() to order the clusters. It's applied on the whole meta.data before grouping and subsetting. For example, you can order the clusters by the activation score of the cluster: desc(mean(ActivationScore, na.rm = TRUE)) , suppose you have a column ActivationScore in the metadata. You may also specify the literal order of the clusters by a list of strings. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. Does not work for table . res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. plus : The extra elements to add to the ggplot object. Does not work for table . group-by : Group cells in different ways (for example, orig.ident). Works for ridge , vln , and dot . It also works for feature as shape.by being passed to Seurat::FeaturePlot . split-by : The column name in metadata to split the cells into different plots. It works for vln , feature , and dot . assay : The assay to use. layer : The layer to use. reduction : The reduction to use. Only works for feature . section : The section to put the plot in the report. If not specified, the case title will be used. ncol ( type=int ) : Default: 2 . The number of columns for the plots. kind ( choice ) : The kind of the plot or table. ridge : Use Seurat::RidgePlot . ridgeplot : Same as ridge . vln : Use Seurat::VlnPlot . vlnplot : Same as vln . violin : Same as vln . violinplot : Same as vln . feature : Use Seurat::FeaturePlot . featureplot : Same as feature . dot : Use Seurat::DotPlot . dotplot : Same as dot . bar : Bar plot on an aggregated feature. The features must be a single feature, which will be either an existing feature or an expression passed to dplyr::summarise() (grouped by ident ) on the existing features to create a new feature. barplot : Same as bar . heatmap : Use Seurat::DoHeatmap . avgheatmap : Plot the average expression of the features in each cluster as a heatmap. table : The table for the features, only gene expressions are supported. (supported keys: ident, subset, and features). features ( type=json ) : Default: {} . The plots for features, include gene expressions, and columns from metadata. Keys are the titles of the cases and values are the dicts inherited from env.features_defaults . It can also have other parameters from each Seurat function used by kind . Note that for argument name with . , you should use - instead. dimplots_defaults ( ns ) : The default parameters for dimplots . ident : Default: seurat_clusters . The identity to use. If it is from subclustering (reduction sub_umap_<ident> exists), this reduction will be used if reduction is set to dim or auto . group-by : Same as ident if not specified, to define how the points are colored. na_group : The group name for NA values, use None to ignore NA values. split-by : The column name in metadata to split the cells into different plots. shape-by : The column name in metadata to use as the shape. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 800 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. reduction ( choice ) : Default: dim . Which dimensionality reduction to use. dim : Use Seurat::DimPlot . First searches for umap , then tsne , then pca . If ident is from subclustering, sub_umap_<ident> will be used. auto : Same as dim umap : Use Seurat::UMAPPlot . tsne : Use Seurat::TSNEPlot . pca : Use Seurat::PCAPlot . <more> : See https://satijalab.org/seurat/reference/dimplot dimplots ( type=json ) : Default: {'Dimensional reduction plot': Diot({'label': True, 'label-box': True, 'repel': True}), 'TCR presence': Diot({'ident': 'TCR_Presence', 'order': 'TCR_absent', 'cols': ['#FF000066', 'gray']})} . The dimensional reduction plots. Keys are the titles of the plots and values are the dicts inherited from env.dimplots_defaults . It can also have other parameters from Seurat::DimPlot . Examples \u00b6 Number of cells in each cluster \u00b6 [SeuratClusterStats.envs.stats] # suppose you have nothing set in `envs.stats_defaults` # otherwise, the settings will be inherited here nCells_All = { } Number of cells in each cluster by groups \u00b6 [SeuratClusterStats.envs.stats] nCells_Sample = { group-by = \"Sample\" } Violin plots for the gene expressions \u00b6 [SeuratClusterStats.envs.features] features = \"CD4,CD8A\" # Remove the dots in the violin plots vlnplots = { pt-size = 0 , kind = \"vln\" } # Don't use the default genes vlnplots_1 = { features = [ \"FOXP3\" , \"IL2RA\" ], pt-size = 0 , kind = \"vln\" } Dimension reduction plot with labels \u00b6 [SeuratClusterStats.envs.dimplots.Idents] label = true label-box = true repel = true","title":"SeuratClusterStats"},{"location":"processes/SeuratClusterStats/#seuratclusterstats","text":"Statistics of the clustering. Including the number/fraction of cells in each cluster, the gene expression values and dimension reduction plots. It's also possible to perform stats on TCR clones/clusters or other metadata for each T-cell cluster.","title":"SeuratClusterStats"},{"location":"processes/SeuratClusterStats/#input","text":"srtobj : The seurat object loaded by SeuratClustering","title":"Input"},{"location":"processes/SeuratClusterStats/#output","text":"outdir : Default: {{in.srtobj | stem}}.cluster_stats . The output directory","title":"Output"},{"location":"processes/SeuratClusterStats/#environment-variables","text":"mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata to subset the cells. The mutaters will be applied in the order specified. clustrees_defaults ( ns ) : The parameters for the clustree plots. devpars ( ns ) : The device parameters for the clustree plot. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 1000 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. prefix : Default: _auto . string indicating columns containing clustering information. The trailing dot is not necessary and will be added automatically. When _auto , clustrees will be plotted when there is FindClusters or FindClusters.* in the obj@commands . The latter is generated by SeuratSubClustering . This will be ignored when envs.clustrees is specified. <more> : Other arguments passed to clustree::clustree() . See https://rdrr.io/cran/clustree/man/clustree.html clustrees ( type=json ) : Default: {} . The cases for clustree plots. Keys are the names of the plots and values are the dicts inherited from env.clustrees_defaults except prefix . There is no default case for clustrees . hists_defaults ( ns ) : The default parameters for histograms. This will plot histograms for the number of cells along x . For example, you can plot the number of cells along cell activity score. x : The column name in metadata to plot as the x-axis. The NA values will be removed. It could be either numeric or factor/character. x_order ( list ) : Default: [] . The order of the x-axis, only works for factor/character x . You can also use it to subset x (showing only a subset values of x ). cells_by : A column name in metadata to group the cells. The NA values will be removed. It should be a factor/character. if not specified, all cells will be used. cells_order ( list ) : Default: [] . The order of the cell groups for the plots. It should be a list of strings. You can also use cells_orderby and cells_n to determine the order. cells_orderby : An expression passed to dplyr::arrange() to order the cell groups. cells_n : Default: 10 . The number of cell groups to show. Ignored if cells_order is specified. ncol ( type=int ) : Default: 2 . The number of columns for the plots, split by cells_by . subset : An expression to subset the cells, will be passed to dplyr::filter() . each : Whether to plot each group separately. bins : Default: 30 . The number of bins to use, only works for numeric x . plus ( list ) : Default: [] . The extra elements to add to the ggplot object. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. hists ( type=json ) : Default: {} . The cases for histograms. Keys are the names of the plots and values are the dicts inherited from env.hists_defaults . There is no default case. stats_defaults ( ns ) : The default parameters for stats . This is to do some basic statistics on the clusters. For more comprehensive analysis, see RadarPlots and CellsDistribution . The parameters from the cases can overwrite the default parameters. frac ( choice ) : Default: none . How to calculate the fraction of cells. group : calculate the fraction in each group. The total fraction of the cells of idents in each group will be 1. When group-by is not specified, it will be the same as all . ident : calculate the fraction in each ident. The total fraction of the cells of groups in each ident will be 1. Only works when group-by is specified. cluster : alias of ident . all : calculate the fraction against all cells. none : do not calculate the fraction, use the number of cells instead. pie ( flag ) : Default: False . Also output a pie chart? circos ( flag ) : Default: False . Also output a circos plot? table ( flag ) : Default: False . Whether to output a table (in tab-delimited format) and in the report. transpose ( flag ) : Default: False . Whether to transpose the cluster and group, that is, using group as the x-axis and cluster to fill the plot. For circos plot, when transposed, the arrows will be drawn from the idents (by ident ) to the the groups (by group-by ). Only works when group-by is specified. position ( choice ) : Default: auto . The position of the bars. Does not work for pie and circos plots. stack : Use position_stack() . fill : Use position_fill() . dodge : Use position_dodge() . auto : Use stack when there are more than 5 groups, otherwise use dodge . ident : Default: seurat_clusters . The column name in metadata to use as the identity. group-by : The column name in metadata to group the cells. Does NOT support for pie charts. split-by : The column name in metadata to split the cells into different plots. Does NOT support for circos plots. subset : An expression to subset the cells, will be passed to dplyr::filter() on metadata. circos_labels_rot ( flag ) : Default: False . Whether to rotate the labels in the circos plot. In case the labels are too long. circos_devpars ( ns ) : The device parameters for the circos plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 600 . The width of the plots. pie_devpars ( ns ) : The device parameters for the pie charts. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 600 . The height of the plots. width ( type=int ) : Default: 800 . The width of the plots. stats ( type=json ) : Default: {'Number of cells in each cluster': Diot({'pie': True}), 'Number of cells in each cluster by Sample': Diot({'group-by': 'Sample', 'table': True, 'frac': 'group'})} . The number/fraction of cells to plot. Keys are the names of the plots and values are the dicts inherited from env.stats_defaults . Here are some examples - { \"nCells_All\" : {}, \"nCells_Sample\" : { \"group-by\" : \"Sample\" }, \"fracCells_Sample\" : { \"frac\" : True , \"group-by\" : \"Sample\" }, } ngenes_defaults ( ns ) : The default parameters for ngenes . The default parameters to plot the number of genes expressed in each cell. ident : Default: seurat_clusters . The column name in metadata to use as the identity. group-by : The column name in metadata to group the cells. Dodge position will be used to separate the groups. split-by : The column name in metadata to split the cells into different plots. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 800 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. ngenes ( type=json ) : Default: {'Number of genes expressed in each cluster': Diot({})} . The number of genes expressed in each cell. Keys are the names of the plots and values are the dicts inherited from env.ngenes_defaults . features_defaults ( ns ) : The default parameters for features . features : The features to plot. It can be either a string with comma separated features, a list of features, a file path with file:// prefix with features (one per line), or an integer to use the top N features from VariantFeatures(srtobj) . ident : Default: seurat_clusters . The column name in metadata to use as the identity. If it is from subclustering (reduction sub_umap_<ident> exists), the reduction will be used. cluster_orderby ( type=auto ) : The order of the clusters to show on the plot. An expression passed to dplyr::summarise() on the grouped data frame (by seurat_clusters ). The summary stat will be passed to dplyr::arrange() to order the clusters. It's applied on the whole meta.data before grouping and subsetting. For example, you can order the clusters by the activation score of the cluster: desc(mean(ActivationScore, na.rm = TRUE)) , suppose you have a column ActivationScore in the metadata. You may also specify the literal order of the clusters by a list of strings. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. Does not work for table . res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : The height of the plots. width ( type=int ) : The width of the plots. plus : The extra elements to add to the ggplot object. Does not work for table . group-by : Group cells in different ways (for example, orig.ident). Works for ridge , vln , and dot . It also works for feature as shape.by being passed to Seurat::FeaturePlot . split-by : The column name in metadata to split the cells into different plots. It works for vln , feature , and dot . assay : The assay to use. layer : The layer to use. reduction : The reduction to use. Only works for feature . section : The section to put the plot in the report. If not specified, the case title will be used. ncol ( type=int ) : Default: 2 . The number of columns for the plots. kind ( choice ) : The kind of the plot or table. ridge : Use Seurat::RidgePlot . ridgeplot : Same as ridge . vln : Use Seurat::VlnPlot . vlnplot : Same as vln . violin : Same as vln . violinplot : Same as vln . feature : Use Seurat::FeaturePlot . featureplot : Same as feature . dot : Use Seurat::DotPlot . dotplot : Same as dot . bar : Bar plot on an aggregated feature. The features must be a single feature, which will be either an existing feature or an expression passed to dplyr::summarise() (grouped by ident ) on the existing features to create a new feature. barplot : Same as bar . heatmap : Use Seurat::DoHeatmap . avgheatmap : Plot the average expression of the features in each cluster as a heatmap. table : The table for the features, only gene expressions are supported. (supported keys: ident, subset, and features). features ( type=json ) : Default: {} . The plots for features, include gene expressions, and columns from metadata. Keys are the titles of the cases and values are the dicts inherited from env.features_defaults . It can also have other parameters from each Seurat function used by kind . Note that for argument name with . , you should use - instead. dimplots_defaults ( ns ) : The default parameters for dimplots . ident : Default: seurat_clusters . The identity to use. If it is from subclustering (reduction sub_umap_<ident> exists), this reduction will be used if reduction is set to dim or auto . group-by : Same as ident if not specified, to define how the points are colored. na_group : The group name for NA values, use None to ignore NA values. split-by : The column name in metadata to split the cells into different plots. shape-by : The column name in metadata to use as the shape. subset : An expression to subset the cells, will be passed to tidyrseurat::filter() . devpars ( ns ) : The device parameters for the plots. res ( type=int ) : Default: 100 . The resolution of the plots. height ( type=int ) : Default: 800 . The height of the plots. width ( type=int ) : Default: 1000 . The width of the plots. reduction ( choice ) : Default: dim . Which dimensionality reduction to use. dim : Use Seurat::DimPlot . First searches for umap , then tsne , then pca . If ident is from subclustering, sub_umap_<ident> will be used. auto : Same as dim umap : Use Seurat::UMAPPlot . tsne : Use Seurat::TSNEPlot . pca : Use Seurat::PCAPlot . <more> : See https://satijalab.org/seurat/reference/dimplot dimplots ( type=json ) : Default: {'Dimensional reduction plot': Diot({'label': True, 'label-box': True, 'repel': True}), 'TCR presence': Diot({'ident': 'TCR_Presence', 'order': 'TCR_absent', 'cols': ['#FF000066', 'gray']})} . The dimensional reduction plots. Keys are the titles of the plots and values are the dicts inherited from env.dimplots_defaults . It can also have other parameters from Seurat::DimPlot .","title":"Environment Variables"},{"location":"processes/SeuratClusterStats/#examples","text":"","title":"Examples"},{"location":"processes/SeuratClusterStats/#number-of-cells-in-each-cluster","text":"[SeuratClusterStats.envs.stats] # suppose you have nothing set in `envs.stats_defaults` # otherwise, the settings will be inherited here nCells_All = { }","title":"Number of cells in each cluster"},{"location":"processes/SeuratClusterStats/#number-of-cells-in-each-cluster-by-groups","text":"[SeuratClusterStats.envs.stats] nCells_Sample = { group-by = \"Sample\" }","title":"Number of cells in each cluster by groups"},{"location":"processes/SeuratClusterStats/#violin-plots-for-the-gene-expressions","text":"[SeuratClusterStats.envs.features] features = \"CD4,CD8A\" # Remove the dots in the violin plots vlnplots = { pt-size = 0 , kind = \"vln\" } # Don't use the default genes vlnplots_1 = { features = [ \"FOXP3\" , \"IL2RA\" ], pt-size = 0 , kind = \"vln\" }","title":"Violin plots for the gene expressions"},{"location":"processes/SeuratClusterStats/#dimension-reduction-plot-with-labels","text":"[SeuratClusterStats.envs.dimplots.Idents] label = true label-box = true repel = true","title":"Dimension reduction plot with labels"},{"location":"processes/SeuratClustering/","text":"SeuratClustering \u00b6 Cluster all T cells or selected T cells selected by TCellSelection . If [TCellSelection] is not set in the configuration, meaning all cells are T cells, this process will be run on all T cells. Otherwise, this process will be run on the selected T cells by TCellSelection . See also: SeuratClusteringOfAllCells . Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with cluster information at seurat_clusters If SCTransform was used, the default Assay will be reset to RNA . Environment Variables \u00b6 ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html ScaleData ( ns ) : Arguments for ScaleData() . If you want to re-scale the data by regressing to some variables, Seurat::ScaleData will be called. If nothing is specified, Seurat::ScaleData will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/scaledata SCTransform ( ns ) : Arguments for SCTransform() . If you want to re-scale the data by regressing to some variables, Seurat::SCTransform will be called. If nothing is specified, Seurat::SCTransform will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/sctransform RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be saved in seurat_clusters and prefixed with \"c\". The first cluster will be \"c1\", instead of \"c0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in seurat_clusters_<resolution> . The final resolution will be used to define the clusters at seurat_clusters . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory. Metadata \u00b6 The metadata of the Seurat object will be updated with the cluster assignments:","title":"SeuratClustering"},{"location":"processes/SeuratClustering/#seuratclustering","text":"Cluster all T cells or selected T cells selected by TCellSelection . If [TCellSelection] is not set in the configuration, meaning all cells are T cells, this process will be run on all T cells. Otherwise, this process will be run on the selected T cells by TCellSelection . See also: SeuratClusteringOfAllCells .","title":"SeuratClustering"},{"location":"processes/SeuratClustering/#input","text":"srtobj : The seurat object loaded by SeuratPreparing","title":"Input"},{"location":"processes/SeuratClustering/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with cluster information at seurat_clusters If SCTransform was used, the default Assay will be reset to RNA .","title":"Output"},{"location":"processes/SeuratClustering/#environment-variables","text":"ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html ScaleData ( ns ) : Arguments for ScaleData() . If you want to re-scale the data by regressing to some variables, Seurat::ScaleData will be called. If nothing is specified, Seurat::ScaleData will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/scaledata SCTransform ( ns ) : Arguments for SCTransform() . If you want to re-scale the data by regressing to some variables, Seurat::SCTransform will be called. If nothing is specified, Seurat::SCTransform will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/sctransform RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be saved in seurat_clusters and prefixed with \"c\". The first cluster will be \"c1\", instead of \"c0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in seurat_clusters_<resolution> . The final resolution will be used to define the clusters at seurat_clusters . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory.","title":"Environment Variables"},{"location":"processes/SeuratClustering/#metadata","text":"The metadata of the Seurat object will be updated with the cluster assignments:","title":"Metadata"},{"location":"processes/SeuratClusteringOfAllCells/","text":"SeuratClusteringOfAllCells \u00b6 Cluster all cells, including T cells and non-T cells using Seurat This process will perform clustering on all cells using Seurat package. The clusters will then be used to select T cells by TCellSelection process. Note If all your cells are all T cells ( TCellSelection is not set in configuration), you should not use this process. Instead, you should use SeuratClustering process for unsupervised clustering, or SeuratMap2Ref process for supervised clustering. Input \u00b6 srtobj : The seurat object loaded by SeuratPreparing Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with cluster information at seurat_clusters If SCTransform was used, the default Assay will be reset to RNA . Environment Variables \u00b6 ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html ScaleData ( ns ) : Arguments for ScaleData() . If you want to re-scale the data by regressing to some variables, Seurat::ScaleData will be called. If nothing is specified, Seurat::ScaleData will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/scaledata SCTransform ( ns ) : Arguments for SCTransform() . If you want to re-scale the data by regressing to some variables, Seurat::SCTransform will be called. If nothing is specified, Seurat::SCTransform will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/sctransform RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be saved in seurat_clusters and prefixed with \"c\". The first cluster will be \"c1\", instead of \"c0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in seurat_clusters_<resolution> . The final resolution will be used to define the clusters at seurat_clusters . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory.","title":"SeuratClusteringOfAllCells"},{"location":"processes/SeuratClusteringOfAllCells/#seuratclusteringofallcells","text":"Cluster all cells, including T cells and non-T cells using Seurat This process will perform clustering on all cells using Seurat package. The clusters will then be used to select T cells by TCellSelection process. Note If all your cells are all T cells ( TCellSelection is not set in configuration), you should not use this process. Instead, you should use SeuratClustering process for unsupervised clustering, or SeuratMap2Ref process for supervised clustering.","title":"SeuratClusteringOfAllCells"},{"location":"processes/SeuratClusteringOfAllCells/#input","text":"srtobj : The seurat object loaded by SeuratPreparing","title":"Input"},{"location":"processes/SeuratClusteringOfAllCells/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with cluster information at seurat_clusters If SCTransform was used, the default Assay will be reset to RNA .","title":"Output"},{"location":"processes/SeuratClusteringOfAllCells/#environment-variables","text":"ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/articles/future_vignette.html ScaleData ( ns ) : Arguments for ScaleData() . If you want to re-scale the data by regressing to some variables, Seurat::ScaleData will be called. If nothing is specified, Seurat::ScaleData will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/scaledata SCTransform ( ns ) : Arguments for SCTransform() . If you want to re-scale the data by regressing to some variables, Seurat::SCTransform will be called. If nothing is specified, Seurat::SCTransform will not be called. vars-to-regress : The variables to regress on. <more> : See https://satijalab.org/seurat/reference/sctransform RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be saved in seurat_clusters and prefixed with \"c\". The first cluster will be \"c1\", instead of \"c0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in seurat_clusters_<resolution> . The final resolution will be used to define the clusters at seurat_clusters . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory.","title":"Environment Variables"},{"location":"processes/SeuratMap2Ref/","text":"SeuratMap2Ref \u00b6 Map the seurat object to reference See: https://satijalab.org/seurat/articles/integration_mapping.html and https://satijalab.org/seurat/articles/multimodal_reference_mapping.html Input \u00b6 sobjfile : The seurat object Output \u00b6 outfile : Default: {{in.sobjfile | stem}}.RDS . The rds file of seurat object with cell type annotated. Note that the reduction name will be ref.umap for the mapping. To visualize the mapping, you should use ref.umap as the reduction name. Environment Variables \u00b6 ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. When split_by is used, this will be the number of cores for each object to map to the reference. When split_by is not used, this is used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/archive/v3.0/future_vignette.html mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata. This is helpful when we want to create new columns for split_by . use : A column name of metadata from the reference (e.g. celltype.l1 , celltype.l2 ) to transfer to the query as the cell types (ident) for downstream analysis. This field is required. If you want to transfer multiple columns, you can use envs.MapQuery.refdata . ident : Default: seurat_clusters . The name of the ident for query transferred from envs.use of the reference. ref : The reference seurat object file. Either an RDS file or a h5seurat file that can be loaded by Seurat::LoadH5Seurat() . The file type is determined by the extension. .rds or .RDS for RDS file, .h5seurat or .h5 for h5seurat file. refnorm ( choice ) : Default: auto . Normalization method the reference used. The same method will be used for the query. NormalizeData : Using NormalizeData . SCTransform : Using SCTransform . auto : Automatically detect the normalization method. If the default assay of reference is SCT , then SCTransform will be used. split_by : The column name in metadata to split the query into multiple objects. This helps when the original query is too large to process. skip_if_normalized : Default: True . Skip normalization if the query is already normalized. Since the object is supposed to be generated by SeuratPreparing , it is already normalized. However, a different normalization method may be used. If the reference is normalized by the same method as the query, the normalization can be skipped. Otherwise, the normalization cannot be skipped. The normalization method used for the query set is determined by the default assay. If SCT , then SCTransform is used; otherwise, NormalizeData is used. You can set this to False to force re-normalization (with or without the arguments previously used). SCTransform ( ns ) : Arguments for SCTransform() do-correct-umi ( flag ) : Default: False . Place corrected UMI matrix in assay counts layer? do-scale ( flag ) : Default: False . Whether to scale residuals to have unit variance? do-center ( flag ) : Default: True . Whether to center residuals to have mean zero? <more> : See https://satijalab.org/seurat/reference/sctransform . Note that the hyphen ( - ) will be transformed into . for the keys. NormalizeData ( ns ) : Arguments for NormalizeData() normalization-method : Default: LogNormalize . Normalization method. <more> : See https://satijalab.org/seurat/reference/normalizedata . Note that the hyphen ( - ) will be transformed into . for the keys. FindTransferAnchors ( ns ) : Arguments for FindTransferAnchors() normalization-method ( choice ) : Name of normalization method used. LogNormalize : Log-normalize the data matrix SCT : Scale data using the SCTransform method auto : Automatically detect the normalization method. See envs.refnorm . reference-reduction : Default: spca . Name of dimensional reduction to use from the reference if running the pcaproject workflow. Optionally enables reuse of precomputed reference dimensional reduction. <more> : See https://satijalab.org/seurat/reference/findtransferanchors . Note that the hyphen ( - ) will be transformed into . for the keys. MapQuery ( ns ) : Arguments for MapQuery() reference-reduction : Default: spca . Name of reduction to use from the reference for neighbor finding reduction-model : Default: wnn.umap . DimReduc object that contains the umap model. refdata ( type=json ) : Default: {} . Extra data to transfer from the reference to the query. <more> : See https://satijalab.org/seurat/reference/mapquery . Note that the hyphen ( - ) will be transformed into . for the keys. MappingScore ( ns ) : Arguments for MappingScore() <more> : See https://satijalab.org/seurat/reference/mappingscore . Note that the hyphen ( - ) will be transformed into . for the keys. ndim : Default: 30 . Metadata \u00b6 The metadata of the Seurat object will be updated with the cluster assignments (column name determined by envs.name ):","title":"SeuratMap2Ref"},{"location":"processes/SeuratMap2Ref/#seuratmap2ref","text":"Map the seurat object to reference See: https://satijalab.org/seurat/articles/integration_mapping.html and https://satijalab.org/seurat/articles/multimodal_reference_mapping.html","title":"SeuratMap2Ref"},{"location":"processes/SeuratMap2Ref/#input","text":"sobjfile : The seurat object","title":"Input"},{"location":"processes/SeuratMap2Ref/#output","text":"outfile : Default: {{in.sobjfile | stem}}.RDS . The rds file of seurat object with cell type annotated. Note that the reduction name will be ref.umap for the mapping. To visualize the mapping, you should use ref.umap as the reduction name.","title":"Output"},{"location":"processes/SeuratMap2Ref/#environment-variables","text":"ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. When split_by is used, this will be the number of cores for each object to map to the reference. When split_by is not used, this is used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. See also: https://satijalab.org/seurat/archive/v3.0/future_vignette.html mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata. This is helpful when we want to create new columns for split_by . use : A column name of metadata from the reference (e.g. celltype.l1 , celltype.l2 ) to transfer to the query as the cell types (ident) for downstream analysis. This field is required. If you want to transfer multiple columns, you can use envs.MapQuery.refdata . ident : Default: seurat_clusters . The name of the ident for query transferred from envs.use of the reference. ref : The reference seurat object file. Either an RDS file or a h5seurat file that can be loaded by Seurat::LoadH5Seurat() . The file type is determined by the extension. .rds or .RDS for RDS file, .h5seurat or .h5 for h5seurat file. refnorm ( choice ) : Default: auto . Normalization method the reference used. The same method will be used for the query. NormalizeData : Using NormalizeData . SCTransform : Using SCTransform . auto : Automatically detect the normalization method. If the default assay of reference is SCT , then SCTransform will be used. split_by : The column name in metadata to split the query into multiple objects. This helps when the original query is too large to process. skip_if_normalized : Default: True . Skip normalization if the query is already normalized. Since the object is supposed to be generated by SeuratPreparing , it is already normalized. However, a different normalization method may be used. If the reference is normalized by the same method as the query, the normalization can be skipped. Otherwise, the normalization cannot be skipped. The normalization method used for the query set is determined by the default assay. If SCT , then SCTransform is used; otherwise, NormalizeData is used. You can set this to False to force re-normalization (with or without the arguments previously used). SCTransform ( ns ) : Arguments for SCTransform() do-correct-umi ( flag ) : Default: False . Place corrected UMI matrix in assay counts layer? do-scale ( flag ) : Default: False . Whether to scale residuals to have unit variance? do-center ( flag ) : Default: True . Whether to center residuals to have mean zero? <more> : See https://satijalab.org/seurat/reference/sctransform . Note that the hyphen ( - ) will be transformed into . for the keys. NormalizeData ( ns ) : Arguments for NormalizeData() normalization-method : Default: LogNormalize . Normalization method. <more> : See https://satijalab.org/seurat/reference/normalizedata . Note that the hyphen ( - ) will be transformed into . for the keys. FindTransferAnchors ( ns ) : Arguments for FindTransferAnchors() normalization-method ( choice ) : Name of normalization method used. LogNormalize : Log-normalize the data matrix SCT : Scale data using the SCTransform method auto : Automatically detect the normalization method. See envs.refnorm . reference-reduction : Default: spca . Name of dimensional reduction to use from the reference if running the pcaproject workflow. Optionally enables reuse of precomputed reference dimensional reduction. <more> : See https://satijalab.org/seurat/reference/findtransferanchors . Note that the hyphen ( - ) will be transformed into . for the keys. MapQuery ( ns ) : Arguments for MapQuery() reference-reduction : Default: spca . Name of reduction to use from the reference for neighbor finding reduction-model : Default: wnn.umap . DimReduc object that contains the umap model. refdata ( type=json ) : Default: {} . Extra data to transfer from the reference to the query. <more> : See https://satijalab.org/seurat/reference/mapquery . Note that the hyphen ( - ) will be transformed into . for the keys. MappingScore ( ns ) : Arguments for MappingScore() <more> : See https://satijalab.org/seurat/reference/mappingscore . Note that the hyphen ( - ) will be transformed into . for the keys. ndim : Default: 30 .","title":"Environment Variables"},{"location":"processes/SeuratMap2Ref/#metadata","text":"The metadata of the Seurat object will be updated with the cluster assignments (column name determined by envs.name ):","title":"Metadata"},{"location":"processes/SeuratPreparing/","text":"SeuratPreparing \u00b6 Load, prepare and apply QC to data, using Seurat This process will - - Prepare the seurat object - Apply QC to the data - Integrate the data from different samples See also - https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#standard-pre-processing-workflow-1) - https://satijalab.org/seurat/articles/integration_introduction This process will read the scRNA-seq data, based on the information provided by SampleInfo , specifically, the paths specified by the RNAData column. Those paths should be either paths to directoies containing matrix.mtx , barcodes.tsv and features.tsv files that can be loaded by Seurat::Read10X() , or paths to h5 files that can be loaded by Seurat::Read10X_h5() . Each sample will be loaded individually and then merged into one Seurat object, and then perform QC. In order to perform QC, some additional columns are added to the meta data of the Seurat object. They are: precent.mt : The percentage of mitochondrial genes. percent.ribo : The percentage of ribosomal genes. precent.hb : The percentage of hemoglobin genes. percent.plat : The percentage of platelet genes. For integration, two routes are available: Performing integration on datasets normalized with SCTransform Using NormalizeData and FindIntegrationAnchors Note When using SCTransform , the default Assay will be set to SCT in output, rather than RNA . If you are using cca or rpca interation, the default assay will be integrated . Note From biopipen v0.23.0, this requires Seurat v5.0.0 or higher. See also Preparing the input . Input \u00b6 metafile : The metadata of the samples A tab-delimited file Two columns are required: Sample to specify the sample names. RNAData to assign the path of the data to the samples The path will be read by Read10X() from Seurat , or the path to the h5 file that can be read by Read10X_h5() from Seurat . Output \u00b6 rdsfile : Default: {{in.metafile | stem}}.seurat.RDS . The RDS file with the Seurat object with all samples integrated. Note that the cell ids are preficed with sample names QC plots will be saved in <job.outdir>/before-qc and <job.outdir>/after-qc . Environment Variables \u00b6 ncores ( type=int ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. cell_qc : Filter expression to filter cells, using tidyrseurat::filter() . Available QC keys include nFeature_RNA , nCount_RNA , percent.mt , percent.ribo , percent.hb , and percent.plat . Example Including the columns added above, all available QC keys include nFeature_RNA , nCount_RNA , percent.mt , percent.ribo , percent.hb , and percent.plat . For example: [SeuratPreparing.envs] cell_qc = \"nFeature_RNA > 200 & percent.mt < 5\" will keep cells with more than 200 genes and less than 5%% mitochondrial genes. cell_qc_per_sample ( flag ) : Default: False . Whether to perform cell QC per sample or not. If True , the cell QC will be performed per sample, and the QC will be applied to each sample before merging. gene_qc ( ns ) : Filter genes. gene_qc is applied after cell_qc . min_cells : Default: 0 . The minimum number of cells that a gene must be expressed in to be kept. excludes : Default: [] . The genes to exclude. Multiple genes can be specified by comma separated values, or as a list. Example [SeuratPreparing.envs] gene_qc = { min_cells = 3 } will keep genes that are expressed in at least 3 cells. use_sct ( flag ) : Default: False . Whether use SCTransform routine to integrate samples or not. Before the following procedures, the RNA layer will be split by samples. If False , following procedures will be performed in the order: * NormalizeData . * FindVariableFeatures . * ScaleData . See https://satijalab.org/seurat/articles/seurat5_integration#layers-in-the-seurat-v5-object and https://satijalab.org/seurat/articles/pbmc3k_tutorial.html If True , following procedures will be performed in the order: * SCTransform . See https://satijalab.org/seurat/articles/seurat5_integration#perform-streamlined-one-line-integrative-analysis no_integration ( flag ) : Default: False . Whether to skip integration or not. NormalizeData ( ns ) : Arguments for NormalizeData() . object is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/normalizedata FindVariableFeatures ( ns ) : Arguments for FindVariableFeatures() . object is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/findvariablefeatures ScaleData ( ns ) : Arguments for ScaleData() . object and features is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/scaledata RunPCA ( ns ) : Arguments for RunPCA() . object and features is specified internally, and - in the key will be replaced with . . npcs ( type=int ) : The number of PCs to compute. For each sample, npcs will be no larger than the number of columns - 1. <more> : See https://satijalab.org/seurat/reference/runpca SCTransform ( ns ) : Arguments for SCTransform() . object is specified internally, and - in the key will be replaced with . . return-only-var-genes : Whether to return only variable genes. min_cells : The minimum number of cells that a gene must be expressed in to be kept. A hidden argument of SCTransform to filter genes. If you try to keep all genes in the RNA assay, you can set min_cells to 0 and return-only-var-genes to False . See https://github.com/satijalab/seurat/issues/3598#issuecomment-715505537 <more> : See https://satijalab.org/seurat/reference/sctransform return-only-var-genes : Default: True . min_cells : Default: 5 . IntegrateLayers ( ns ) : Arguments for IntegrateLayers() . object is specified internally, and - in the key will be replaced with . . When use_sct is True , normalization-method defaults to SCT . method ( choice ) : Default: harmony . The method to use for integration. CCAIntegration : Use Seurat::CCAIntegration . CCA : Same as CCAIntegration . cca : Same as CCAIntegration . RPCAIntegration : Use Seurat::RPCAIntegration . RPCA : Same as RPCAIntegration . rpca : Same as RPCAIntegration . HarmonyIntegration : Use Seurat::HarmonyIntegration . Harmony : Same as HarmonyIntegration . harmony : Same as HarmonyIntegration . FastMNNIntegration : Use Seurat::FastMNNIntegration . FastMNN : Same as FastMNNIntegration . fastmnn : Same as FastMNNIntegration . scVIIntegration : Use Seurat::scVIIntegration . scVI : Same as scVIIntegration . scvi : Same as scVIIntegration . <more> : See https://satijalab.org/seurat/reference/integratelayers doublet_detector ( choice ) : Default: none . The doublet detector to use. none : Do not use any doublet detector. DoubletFinder : Use DoubletFinder to detect doublets. doubletfinder : Same as DoubletFinder . scDblFinder : Use scDblFinder to detect doublets. scdblfinder : Same as scDblFinder . DoubletFinder ( ns ) : Arguments to run DoubletFinder . See also https://demultiplexing-doublet-detecting-docs.readthedocs.io/en/latest/DoubletFinder.html . PCs ( type=int ) : Default: 10 . Number of PCs to use for 'doubletFinder' function. doublets ( type=float ) : Default: 0.075 . Number of expected doublets as a proportion of the pool size. pN ( type=float ) : Default: 0.25 . Number of doublets to simulate as a proportion of the pool size. ncores ( type=int ) : Default: 1 . Number of cores to use for DoubletFinder::paramSweep . Set to None to use envs.ncores . Since parallelization of the function usually exhausts memory, if big envs.ncores does not work for DoubletFinder , set this to a smaller number. scDblFinder ( ns ) : Arguments to run scDblFinder . dbr ( type=float ) : Default: 0.075 . The expected doublet rate. ncores ( type=int ) : Default: 1 . Number of cores to use for scDblFinder . Set to None to use envs.ncores . <more> : See https://rdrr.io/bioc/scDblFinder/man/scDblFinder.html . cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory. Metadata \u00b6 Here is the demonstration of basic metadata for the Seurat object. Future processes will use it and/or add more metadata to the Seurat object.","title":"SeuratPreparing"},{"location":"processes/SeuratPreparing/#seuratpreparing","text":"Load, prepare and apply QC to data, using Seurat This process will - - Prepare the seurat object - Apply QC to the data - Integrate the data from different samples See also - https://satijalab.org/seurat/articles/pbmc3k_tutorial.html#standard-pre-processing-workflow-1) - https://satijalab.org/seurat/articles/integration_introduction This process will read the scRNA-seq data, based on the information provided by SampleInfo , specifically, the paths specified by the RNAData column. Those paths should be either paths to directoies containing matrix.mtx , barcodes.tsv and features.tsv files that can be loaded by Seurat::Read10X() , or paths to h5 files that can be loaded by Seurat::Read10X_h5() . Each sample will be loaded individually and then merged into one Seurat object, and then perform QC. In order to perform QC, some additional columns are added to the meta data of the Seurat object. They are: precent.mt : The percentage of mitochondrial genes. percent.ribo : The percentage of ribosomal genes. precent.hb : The percentage of hemoglobin genes. percent.plat : The percentage of platelet genes. For integration, two routes are available: Performing integration on datasets normalized with SCTransform Using NormalizeData and FindIntegrationAnchors Note When using SCTransform , the default Assay will be set to SCT in output, rather than RNA . If you are using cca or rpca interation, the default assay will be integrated . Note From biopipen v0.23.0, this requires Seurat v5.0.0 or higher. See also Preparing the input .","title":"SeuratPreparing"},{"location":"processes/SeuratPreparing/#input","text":"metafile : The metadata of the samples A tab-delimited file Two columns are required: Sample to specify the sample names. RNAData to assign the path of the data to the samples The path will be read by Read10X() from Seurat , or the path to the h5 file that can be read by Read10X_h5() from Seurat .","title":"Input"},{"location":"processes/SeuratPreparing/#output","text":"rdsfile : Default: {{in.metafile | stem}}.seurat.RDS . The RDS file with the Seurat object with all samples integrated. Note that the cell ids are preficed with sample names QC plots will be saved in <job.outdir>/before-qc and <job.outdir>/after-qc .","title":"Output"},{"location":"processes/SeuratPreparing/#environment-variables","text":"ncores ( type=int ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. cell_qc : Filter expression to filter cells, using tidyrseurat::filter() . Available QC keys include nFeature_RNA , nCount_RNA , percent.mt , percent.ribo , percent.hb , and percent.plat . Example Including the columns added above, all available QC keys include nFeature_RNA , nCount_RNA , percent.mt , percent.ribo , percent.hb , and percent.plat . For example: [SeuratPreparing.envs] cell_qc = \"nFeature_RNA > 200 & percent.mt < 5\" will keep cells with more than 200 genes and less than 5%% mitochondrial genes. cell_qc_per_sample ( flag ) : Default: False . Whether to perform cell QC per sample or not. If True , the cell QC will be performed per sample, and the QC will be applied to each sample before merging. gene_qc ( ns ) : Filter genes. gene_qc is applied after cell_qc . min_cells : Default: 0 . The minimum number of cells that a gene must be expressed in to be kept. excludes : Default: [] . The genes to exclude. Multiple genes can be specified by comma separated values, or as a list. Example [SeuratPreparing.envs] gene_qc = { min_cells = 3 } will keep genes that are expressed in at least 3 cells. use_sct ( flag ) : Default: False . Whether use SCTransform routine to integrate samples or not. Before the following procedures, the RNA layer will be split by samples. If False , following procedures will be performed in the order: * NormalizeData . * FindVariableFeatures . * ScaleData . See https://satijalab.org/seurat/articles/seurat5_integration#layers-in-the-seurat-v5-object and https://satijalab.org/seurat/articles/pbmc3k_tutorial.html If True , following procedures will be performed in the order: * SCTransform . See https://satijalab.org/seurat/articles/seurat5_integration#perform-streamlined-one-line-integrative-analysis no_integration ( flag ) : Default: False . Whether to skip integration or not. NormalizeData ( ns ) : Arguments for NormalizeData() . object is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/normalizedata FindVariableFeatures ( ns ) : Arguments for FindVariableFeatures() . object is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/findvariablefeatures ScaleData ( ns ) : Arguments for ScaleData() . object and features is specified internally, and - in the key will be replaced with . . <more> : See https://satijalab.org/seurat/reference/scaledata RunPCA ( ns ) : Arguments for RunPCA() . object and features is specified internally, and - in the key will be replaced with . . npcs ( type=int ) : The number of PCs to compute. For each sample, npcs will be no larger than the number of columns - 1. <more> : See https://satijalab.org/seurat/reference/runpca SCTransform ( ns ) : Arguments for SCTransform() . object is specified internally, and - in the key will be replaced with . . return-only-var-genes : Whether to return only variable genes. min_cells : The minimum number of cells that a gene must be expressed in to be kept. A hidden argument of SCTransform to filter genes. If you try to keep all genes in the RNA assay, you can set min_cells to 0 and return-only-var-genes to False . See https://github.com/satijalab/seurat/issues/3598#issuecomment-715505537 <more> : See https://satijalab.org/seurat/reference/sctransform return-only-var-genes : Default: True . min_cells : Default: 5 . IntegrateLayers ( ns ) : Arguments for IntegrateLayers() . object is specified internally, and - in the key will be replaced with . . When use_sct is True , normalization-method defaults to SCT . method ( choice ) : Default: harmony . The method to use for integration. CCAIntegration : Use Seurat::CCAIntegration . CCA : Same as CCAIntegration . cca : Same as CCAIntegration . RPCAIntegration : Use Seurat::RPCAIntegration . RPCA : Same as RPCAIntegration . rpca : Same as RPCAIntegration . HarmonyIntegration : Use Seurat::HarmonyIntegration . Harmony : Same as HarmonyIntegration . harmony : Same as HarmonyIntegration . FastMNNIntegration : Use Seurat::FastMNNIntegration . FastMNN : Same as FastMNNIntegration . fastmnn : Same as FastMNNIntegration . scVIIntegration : Use Seurat::scVIIntegration . scVI : Same as scVIIntegration . scvi : Same as scVIIntegration . <more> : See https://satijalab.org/seurat/reference/integratelayers doublet_detector ( choice ) : Default: none . The doublet detector to use. none : Do not use any doublet detector. DoubletFinder : Use DoubletFinder to detect doublets. doubletfinder : Same as DoubletFinder . scDblFinder : Use scDblFinder to detect doublets. scdblfinder : Same as scDblFinder . DoubletFinder ( ns ) : Arguments to run DoubletFinder . See also https://demultiplexing-doublet-detecting-docs.readthedocs.io/en/latest/DoubletFinder.html . PCs ( type=int ) : Default: 10 . Number of PCs to use for 'doubletFinder' function. doublets ( type=float ) : Default: 0.075 . Number of expected doublets as a proportion of the pool size. pN ( type=float ) : Default: 0.25 . Number of doublets to simulate as a proportion of the pool size. ncores ( type=int ) : Default: 1 . Number of cores to use for DoubletFinder::paramSweep . Set to None to use envs.ncores . Since parallelization of the function usually exhausts memory, if big envs.ncores does not work for DoubletFinder , set this to a smaller number. scDblFinder ( ns ) : Arguments to run scDblFinder . dbr ( type=float ) : Default: 0.075 . The expected doublet rate. ncores ( type=int ) : Default: 1 . Number of cores to use for scDblFinder . Set to None to use envs.ncores . <more> : See https://rdrr.io/bioc/scDblFinder/man/scDblFinder.html . cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory.","title":"Environment Variables"},{"location":"processes/SeuratPreparing/#metadata","text":"Here is the demonstration of basic metadata for the Seurat object. Future processes will use it and/or add more metadata to the Seurat object.","title":"Metadata"},{"location":"processes/SeuratSubClustering/","text":"SeuratSubClustering \u00b6 Sub-cluster the selected T cells. Find clusters of a subset of cells. It's unlike [ Seurat::FindSubCluster ], which only finds subclusters of a single cluster. Instead, it will perform the whole clustering procedure on the subset of cells. One can use metadata to specify the subset of cells to perform clustering on. For the subset of cells, the reductions will be re-performed on the subset of cells, and then the clustering will be performed on the subset of cells. The reduction will be saved in sobj@reduction$sub_umap_<casename> of the original object and the clustering will be saved in the metadata of the original object using the casename as the column name. Input \u00b6 srtobj : The seurat object Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the subclustering information. Environment Variables \u00b6 ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata to subset the cells. The mutaters will be applied in the order specified. subset : An expression to subset the cells, will be passed to tidyseurat::filter() . RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally as the subset object, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be prefixed with \"s\". The first cluster will be \"s1\", instead of \"s0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in <casename>_<resolution> . The final resolution will be used to define the clusters at <casename> . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory. cases ( type=json ) : Default: {'subcluster': Diot({})} . The cases to perform subclustering. Keys are the names of the cases and values are the dicts inherited from envs except mutaters and cache . If empty, a case with name subcluster will be created with default parameters. Metadata \u00b6 The metadata of the Seurat object will be updated with the sub-clusters specified by names (keys) of envs.cases :","title":"SeuratSubClustering"},{"location":"processes/SeuratSubClustering/#seuratsubclustering","text":"Sub-cluster the selected T cells. Find clusters of a subset of cells. It's unlike [ Seurat::FindSubCluster ], which only finds subclusters of a single cluster. Instead, it will perform the whole clustering procedure on the subset of cells. One can use metadata to specify the subset of cells to perform clustering on. For the subset of cells, the reductions will be re-performed on the subset of cells, and then the clustering will be performed on the subset of cells. The reduction will be saved in sobj@reduction$sub_umap_<casename> of the original object and the clustering will be saved in the metadata of the original object using the casename as the column name.","title":"SeuratSubClustering"},{"location":"processes/SeuratSubClustering/#input","text":"srtobj : The seurat object","title":"Input"},{"location":"processes/SeuratSubClustering/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . The seurat object with the subclustering information.","title":"Output"},{"location":"processes/SeuratSubClustering/#environment-variables","text":"ncores ( type=int;order=-100 ) : Default: 1 . Number of cores to use. Used in future::plan(strategy = \"multicore\", workers = <ncores>) to parallelize some Seurat procedures. mutaters ( type=json ) : Default: {} . The mutaters to mutate the metadata to subset the cells. The mutaters will be applied in the order specified. subset : An expression to subset the cells, will be passed to tidyseurat::filter() . RunUMAP ( ns ) : Arguments for RunUMAP() . object is specified internally as the subset object, and - in the key will be replaced with . . dims=N will be expanded to dims=1:N ; The maximal value of N will be the minimum of N and the number of columns - 1 for each sample. dims ( type=int ) : Default: 30 . The number of PCs to use reduction : The reduction to use for UMAP. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/runumap FindNeighbors ( ns ) : Arguments for FindNeighbors() . object is specified internally, and - in the key will be replaced with . . reduction : The reduction to use. If not provided, sobj@misc$integrated_new_reduction will be used. <more> : See https://satijalab.org/seurat/reference/findneighbors FindClusters ( ns ) : Arguments for FindClusters() . object is specified internally, and - in the key will be replaced with . . The cluster labels will be prefixed with \"s\". The first cluster will be \"s1\", instead of \"s0\". resolution ( type=auto ) : Default: 0.8 . The resolution of the clustering. You can have multiple resolutions as a list or as a string separated by comma. Ranges are also supported, for example: 0.1:0.5:0.1 will generate 0.1, 0.2, 0.3, 0.4, 0.5 . The step can be omitted, defaulting to 0.1. The results will be saved in <casename>_<resolution> . The final resolution will be used to define the clusters at <casename> . <more> : See https://satijalab.org/seurat/reference/findclusters cache ( type=auto ) : Default: /tmp . Whether to cache the information at different steps. If True , the seurat object will be cached in the job output directory, which will be not cleaned up when job is rerunning. The cached seurat object will be saved as <signature>.<kind>.RDS file, where <signature> is the signature determined by the input and envs of the process. See https://github.com/satijalab/seurat/issues/7849 , https://github.com/satijalab/seurat/issues/5358 and https://github.com/satijalab/seurat/issues/6748 for more details also about reproducibility issues. To not use the cached seurat object, you can either set cache to False or delete the cached file at <signature>.RDS in the cache directory. cases ( type=json ) : Default: {'subcluster': Diot({})} . The cases to perform subclustering. Keys are the names of the cases and values are the dicts inherited from envs except mutaters and cache . If empty, a case with name subcluster will be created with default parameters.","title":"Environment Variables"},{"location":"processes/SeuratSubClustering/#metadata","text":"The metadata of the Seurat object will be updated with the sub-clusters specified by names (keys) of envs.cases :","title":"Metadata"},{"location":"processes/TCRClusterStats/","text":"TCRClusterStats \u00b6 Statistics of TCR clusters, generated by TCRClustering . The statistics include The number of cells in each cluster (cluster size) Sample diversity using TCR clusters instead of TCR clones Shared TCR clusters between samples Input \u00b6 immfile : The immunarch object with TCR clusters attached Output \u00b6 outdir : Default: {{in.immfile | stem}}.tcrclusters_stats . The output directory containing the stats and reports Environment Variables \u00b6 cluster_size ( ns ) : The distribution of size of each cluster. by : Default: Sample . The variables (column names) used to fill the histogram. Only a single column is supported. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 900 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.cluster_size will be used. If NO cases are specified, the default case will be added, with the name DEFAULT . shared_clusters ( ns ) : Stats about shared TCR clusters numbers_on_heatmap ( flag ) : Default: True . Whether to show the numbers on the heatmap. heatmap_meta ( list ) : Default: [] . The columns of metadata to show on the heatmap. cluster_rows ( flag ) : Default: True . Whether to cluster the rows on the heatmap. sample_order : The order of the samples on the heatmap. Either a string separated by , or a list of sample names. This only works for columns if cluster_rows is True . grouping : The groups to investigate the shared clusters. If specified, venn diagrams will be drawn instead of heatmaps. In such case, numbers_on_heatmap and heatmap_meta will be ignored. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 1000 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.shared_clusters will be used. If NO cases are specified, the default case will be added, with the name DEFAULT . sample_diversity ( ns ) : Sample diversity using TCR clusters instead of clones. by : The variables (column names) to group samples. Multiple columns should be separated by , . method ( choice ) : Default: gini . The method to calculate diversity. gini : The Gini coefficient. It measures the inequality among values of a frequency distribution (for example levels of income). gini.simp : The Gini-Simpson index. It is the probability of interspecific encounter, i.e., probability that two entities represent different types. inv.simp : Inverse Simpson index. It is the effective number of types that is obtained when the weighted arithmetic mean is used to quantify average proportional abundance of types in the dataset of interest. div : true diversity, or the effective number of types. It refers to the number of equally abundant types needed for the average proportional abundance of the types to equal that observed in the dataset of interest where all types may not be equally abundant. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 1000 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.sample_diversity will be used. If NO cases are specified, the default case will be added, with the name DEFAULT . Examples \u00b6 Cluster size \u00b6 [TCRClusterStats.envs.cluster_size] by = \"Sample\" Shared clusters \u00b6 [TCRClusterStats.envs.shared_clusters] numbers_on_heatmap = true heatmap_meta = [ \"region\" ] Sample diversity \u00b6 [TCRClusterStats.envs.sample_diversity] method = \"gini\" Compared to the sample diversity using TCR clones:","title":"TCRClusterStats"},{"location":"processes/TCRClusterStats/#tcrclusterstats","text":"Statistics of TCR clusters, generated by TCRClustering . The statistics include The number of cells in each cluster (cluster size) Sample diversity using TCR clusters instead of TCR clones Shared TCR clusters between samples","title":"TCRClusterStats"},{"location":"processes/TCRClusterStats/#input","text":"immfile : The immunarch object with TCR clusters attached","title":"Input"},{"location":"processes/TCRClusterStats/#output","text":"outdir : Default: {{in.immfile | stem}}.tcrclusters_stats . The output directory containing the stats and reports","title":"Output"},{"location":"processes/TCRClusterStats/#environment-variables","text":"cluster_size ( ns ) : The distribution of size of each cluster. by : Default: Sample . The variables (column names) used to fill the histogram. Only a single column is supported. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 900 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.cluster_size will be used. If NO cases are specified, the default case will be added, with the name DEFAULT . shared_clusters ( ns ) : Stats about shared TCR clusters numbers_on_heatmap ( flag ) : Default: True . Whether to show the numbers on the heatmap. heatmap_meta ( list ) : Default: [] . The columns of metadata to show on the heatmap. cluster_rows ( flag ) : Default: True . Whether to cluster the rows on the heatmap. sample_order : The order of the samples on the heatmap. Either a string separated by , or a list of sample names. This only works for columns if cluster_rows is True . grouping : The groups to investigate the shared clusters. If specified, venn diagrams will be drawn instead of heatmaps. In such case, numbers_on_heatmap and heatmap_meta will be ignored. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 1000 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.shared_clusters will be used. If NO cases are specified, the default case will be added, with the name DEFAULT . sample_diversity ( ns ) : Sample diversity using TCR clusters instead of clones. by : The variables (column names) to group samples. Multiple columns should be separated by , . method ( choice ) : Default: gini . The method to calculate diversity. gini : The Gini coefficient. It measures the inequality among values of a frequency distribution (for example levels of income). gini.simp : The Gini-Simpson index. It is the probability of interspecific encounter, i.e., probability that two entities represent different types. inv.simp : Inverse Simpson index. It is the effective number of types that is obtained when the weighted arithmetic mean is used to quantify average proportional abundance of types in the dataset of interest. div : true diversity, or the effective number of types. It refers to the number of equally abundant types needed for the average proportional abundance of the types to equal that observed in the dataset of interest where all types may not be equally abundant. devpars ( ns ) : The parameters for the plotting device. width ( type=int ) : Default: 1000 . The width of the device height ( type=int ) : Default: 1000 . The height of the device res ( type=int ) : Default: 100 . The resolution of the device cases ( type=json ) : Default: {} . If you have multiple cases, you can use this argument to specify them. The keys will be the names of the cases. The values will be passed to the corresponding arguments above. If any of these arguments are not specified, the values in envs.sample_diversity will be used. If NO cases are specified, the default case will be added, with the name DEFAULT .","title":"Environment Variables"},{"location":"processes/TCRClusterStats/#examples","text":"","title":"Examples"},{"location":"processes/TCRClusterStats/#cluster-size","text":"[TCRClusterStats.envs.cluster_size] by = \"Sample\"","title":"Cluster size"},{"location":"processes/TCRClusterStats/#shared-clusters","text":"[TCRClusterStats.envs.shared_clusters] numbers_on_heatmap = true heatmap_meta = [ \"region\" ]","title":"Shared clusters"},{"location":"processes/TCRClusterStats/#sample-diversity","text":"[TCRClusterStats.envs.sample_diversity] method = \"gini\" Compared to the sample diversity using TCR clones:","title":"Sample diversity"},{"location":"processes/TCRClustering/","text":"TCRClustering \u00b6 Cluster the TCR clones by their CDR3 sequences You can disable this by remving the whole sections of TCRClustering and TCRClusterStats in the config file. This process is used to cluster TCR clones based on their CDR3 sequences. It uses either GIANA Zhang, Hongyi, Xiaowei Zhan, and Bo Li. \"GIANA allows computationally-efficient TCR clustering and multi-disease repertoire classification by isometric transformation.\" Nature communications 12.1 (2021): 1-11. Or ClusTCR Sebastiaan Valkiers, Max Van Houcke, Kris Laukens, Pieter Meysman, ClusTCR: a Python interface for rapid clustering of large sets of CDR3 sequences with unknown antigen specificity, Bioinformatics, 2021. Both methods are based on the Faiss Clustering Library , for efficient similarity search and clustering of dense vectors, so both methods yield similar results. A text file will be generated with the cluster assignments for each cell, together with the immunarch object (in R ) with the cluster assignments at TCR_Clsuter column. This information will then be merged to a Seurat object for further downstream analysis. The cluster assignments are prefixed with S_ or M_ to indicate whether a cluster has only one unique CDR3 sequence or multiple CDR3 sequences. Note that a cluster with S_ prefix may still have multiple cells, as the same CDR3 sequence may be shared by multiple cells. Input \u00b6 immfile : The immunarch object in RDS Output \u00b6 immfile : Default: {{in.immfile | basename}} . The immnuarch object in RDS with TCR cluster information clusterfile : Default: {{in.immfile | stem}}.clusters.txt . The cluster file. Columns are CDR3.aa, TCR_Cluster, TCR_Cluster_Size and TCR_Cluster_Size1. TCR_Cluster_Size is the number of cells in the cluster. TCR_Cluster_Size1 is the unique CDR3 sequences in the cluster. Environment Variables \u00b6 tool ( choice ) : Default: GIANA . The tool used to do the clustering, either GIANA or ClusTCR . For GIANA, using TRBV mutations is not supported GIANA : by Li lab at UT Southwestern Medical Center ClusTCR : by Sebastiaan Valkiers, etc prefix : The prefix to the barcodes. You can use placeholder like {Sample}_ The prefixed barcodes will be used to match the barcodes in in.metafile . Not used if in.metafile is not specified. If None (default), immdata$prefix will be used. python : Default: python . The path of python with GIANA 's dependencies installed or with clusTCR installed. Depending on the tool you choose. args ( type=json ) : Default: {} . The arguments for the clustering tool For GIANA, they will be passed to python GIAna.py See https://github.com/s175573/GIANA#usage . For ClusTCR, they will be passed to clustcr.Clustering(...) See https://svalkiers.github.io/clusTCR/docs/clustering/how-to-use.html#clustering .","title":"TCRClustering"},{"location":"processes/TCRClustering/#tcrclustering","text":"Cluster the TCR clones by their CDR3 sequences You can disable this by remving the whole sections of TCRClustering and TCRClusterStats in the config file. This process is used to cluster TCR clones based on their CDR3 sequences. It uses either GIANA Zhang, Hongyi, Xiaowei Zhan, and Bo Li. \"GIANA allows computationally-efficient TCR clustering and multi-disease repertoire classification by isometric transformation.\" Nature communications 12.1 (2021): 1-11. Or ClusTCR Sebastiaan Valkiers, Max Van Houcke, Kris Laukens, Pieter Meysman, ClusTCR: a Python interface for rapid clustering of large sets of CDR3 sequences with unknown antigen specificity, Bioinformatics, 2021. Both methods are based on the Faiss Clustering Library , for efficient similarity search and clustering of dense vectors, so both methods yield similar results. A text file will be generated with the cluster assignments for each cell, together with the immunarch object (in R ) with the cluster assignments at TCR_Clsuter column. This information will then be merged to a Seurat object for further downstream analysis. The cluster assignments are prefixed with S_ or M_ to indicate whether a cluster has only one unique CDR3 sequence or multiple CDR3 sequences. Note that a cluster with S_ prefix may still have multiple cells, as the same CDR3 sequence may be shared by multiple cells.","title":"TCRClustering"},{"location":"processes/TCRClustering/#input","text":"immfile : The immunarch object in RDS","title":"Input"},{"location":"processes/TCRClustering/#output","text":"immfile : Default: {{in.immfile | basename}} . The immnuarch object in RDS with TCR cluster information clusterfile : Default: {{in.immfile | stem}}.clusters.txt . The cluster file. Columns are CDR3.aa, TCR_Cluster, TCR_Cluster_Size and TCR_Cluster_Size1. TCR_Cluster_Size is the number of cells in the cluster. TCR_Cluster_Size1 is the unique CDR3 sequences in the cluster.","title":"Output"},{"location":"processes/TCRClustering/#environment-variables","text":"tool ( choice ) : Default: GIANA . The tool used to do the clustering, either GIANA or ClusTCR . For GIANA, using TRBV mutations is not supported GIANA : by Li lab at UT Southwestern Medical Center ClusTCR : by Sebastiaan Valkiers, etc prefix : The prefix to the barcodes. You can use placeholder like {Sample}_ The prefixed barcodes will be used to match the barcodes in in.metafile . Not used if in.metafile is not specified. If None (default), immdata$prefix will be used. python : Default: python . The path of python with GIANA 's dependencies installed or with clusTCR installed. Depending on the tool you choose. args ( type=json ) : Default: {} . The arguments for the clustering tool For GIANA, they will be passed to python GIAna.py See https://github.com/s175573/GIANA#usage . For ClusTCR, they will be passed to clustcr.Clustering(...) See https://svalkiers.github.io/clusTCR/docs/clustering/how-to-use.html#clustering .","title":"Environment Variables"},{"location":"processes/TCellSelection/","text":"TCellSelection \u00b6 Separate T and non-T cells and select T cells. If all of your cells are T cells, do not set any configurations for this process. In such a case, SeuratClusteringOfAllCells should not be used, and SeuratClustering will be clustering all of the cells, which are all T cells. There are two ways to separate T and non-T cells: Use the an expression indicator directly from the metadata. Use the expression values of indicator genes, and the clonotype percentage of the clusters. You can also use indicator gene expression values only to select T cells by setting envs.ignore_tcr to true. Input \u00b6 srtobj : Seurat object file in RDS immdata : Immunarch data file in RDS Output \u00b6 rdsfile : Default: {{in.srtobj | stem}}.RDS . Seurat object file in RDS outdir : Default: details . Output directory with details Environment Variables \u00b6 ignore_tcr ( flag ) : Default: False . Ignore TCR information for T cell selection. Use only the expression values of indicator genes. In this case, the Clonotype_Pct column does not exist in the metadata. If you want to use k-means to select T cells, you must have more than 1 indicator gene, and the first indicator gene in envs.indicator_genes must be a positive marker, which will be used to select the cluster with higher expression values as T cells. tcell_selector : The expression passed to tidyseurat::mutate(is_TCell = ...) to indicate whether a cell is a T cell. For example, Clonotype_Pct > 0.25 to indicate cells with clonotype percentage > 25% are T cells. If indicator_genes is provided, the expression values can also be used in the expression. For example, Clonotype_Pct > 0.25 & CD3E > 0 . If tcell_selector is not provided, a kmeans clustering will be performed on the expression values of indicator_genes and Clonotype_Pct , with K=2, and the cluster with higher clonotype percentage will be selected as T cells. indicator_genes ( list ) : Default: ['CD3E'] . A list of indicator genes whose expression values and clonotype percentage will be used to determine T cells. The markers could be either positive, such as CD3E , CD3D , CD3G , or negative, such as CD19 , CD14 , CD68 . kmeans ( type=json ) : Default: {'nstart': 25} . The parameters for kmeans clustering. Other arguments for stats::kmeans can be provided here. If there are dots in the argument names, replace them with - . Examples \u00b6 Use T cell indicator directly \u00b6 If you have a metadata like this: id Clonotype_Pct seurat_clusters 1 0.1 1 2 0.3 2 3 0.5 3 With the configuration below: [TCellSelection.envs] tcell_selector = \"Clonotype_Pct > 0.25\" The T cells will be selected as: id Clonotype_Pct seurat_clusters is_TCell 1 0.1 1 FALSE 2 0.3 2 TRUE 3 0.5 3 TRUE Use indicator genes \u00b6 Let's say we set the indicator genes to [\"CD3D\", \"CD3E\", \"CD3G\"] . The mean expression values will be calculated for each cluster: id Clonotype_Pct seurat_clusters CD3D CD3E CD3G 1 0.1 1 0.1 0.0 0.1 2 0.3 2 1.2 1.3 0.6 3 0.5 3 1.5 0.8 0.9 Then a kmeans clustering will be performed on the mean expression values of the indicator genes, together with Clonotype_Pct , with K=2. id Clonotype_Pct seurat_clusters CD3D CD3E CD3G is_TCell 1 0.1 1 0.1 0.0 0.1 FALSE 2 0.3 2 1.2 1.3 0.6 TRUE 3 0.5 3 1.5 0.8 0.9 TRUE The cluster with higher clonoype percentage will be selected as T cells ( is_TCell = TRUE ), and sent to SeuratClustering for further clustering and downstream analysis.","title":"TCellSelection"},{"location":"processes/TCellSelection/#tcellselection","text":"Separate T and non-T cells and select T cells. If all of your cells are T cells, do not set any configurations for this process. In such a case, SeuratClusteringOfAllCells should not be used, and SeuratClustering will be clustering all of the cells, which are all T cells. There are two ways to separate T and non-T cells: Use the an expression indicator directly from the metadata. Use the expression values of indicator genes, and the clonotype percentage of the clusters. You can also use indicator gene expression values only to select T cells by setting envs.ignore_tcr to true.","title":"TCellSelection"},{"location":"processes/TCellSelection/#input","text":"srtobj : Seurat object file in RDS immdata : Immunarch data file in RDS","title":"Input"},{"location":"processes/TCellSelection/#output","text":"rdsfile : Default: {{in.srtobj | stem}}.RDS . Seurat object file in RDS outdir : Default: details . Output directory with details","title":"Output"},{"location":"processes/TCellSelection/#environment-variables","text":"ignore_tcr ( flag ) : Default: False . Ignore TCR information for T cell selection. Use only the expression values of indicator genes. In this case, the Clonotype_Pct column does not exist in the metadata. If you want to use k-means to select T cells, you must have more than 1 indicator gene, and the first indicator gene in envs.indicator_genes must be a positive marker, which will be used to select the cluster with higher expression values as T cells. tcell_selector : The expression passed to tidyseurat::mutate(is_TCell = ...) to indicate whether a cell is a T cell. For example, Clonotype_Pct > 0.25 to indicate cells with clonotype percentage > 25% are T cells. If indicator_genes is provided, the expression values can also be used in the expression. For example, Clonotype_Pct > 0.25 & CD3E > 0 . If tcell_selector is not provided, a kmeans clustering will be performed on the expression values of indicator_genes and Clonotype_Pct , with K=2, and the cluster with higher clonotype percentage will be selected as T cells. indicator_genes ( list ) : Default: ['CD3E'] . A list of indicator genes whose expression values and clonotype percentage will be used to determine T cells. The markers could be either positive, such as CD3E , CD3D , CD3G , or negative, such as CD19 , CD14 , CD68 . kmeans ( type=json ) : Default: {'nstart': 25} . The parameters for kmeans clustering. Other arguments for stats::kmeans can be provided here. If there are dots in the argument names, replace them with - .","title":"Environment Variables"},{"location":"processes/TCellSelection/#examples","text":"","title":"Examples"},{"location":"processes/TCellSelection/#use-t-cell-indicator-directly","text":"If you have a metadata like this: id Clonotype_Pct seurat_clusters 1 0.1 1 2 0.3 2 3 0.5 3 With the configuration below: [TCellSelection.envs] tcell_selector = \"Clonotype_Pct > 0.25\" The T cells will be selected as: id Clonotype_Pct seurat_clusters is_TCell 1 0.1 1 FALSE 2 0.3 2 TRUE 3 0.5 3 TRUE","title":"Use T cell indicator directly"},{"location":"processes/TCellSelection/#use-indicator-genes","text":"Let's say we set the indicator genes to [\"CD3D\", \"CD3E\", \"CD3G\"] . The mean expression values will be calculated for each cluster: id Clonotype_Pct seurat_clusters CD3D CD3E CD3G 1 0.1 1 0.1 0.0 0.1 2 0.3 2 1.2 1.3 0.6 3 0.5 3 1.5 0.8 0.9 Then a kmeans clustering will be performed on the mean expression values of the indicator genes, together with Clonotype_Pct , with K=2. id Clonotype_Pct seurat_clusters CD3D CD3E CD3G is_TCell 1 0.1 1 0.1 0.0 0.1 FALSE 2 0.3 2 1.2 1.3 0.6 TRUE 3 0.5 3 1.5 0.8 0.9 TRUE The cluster with higher clonoype percentage will be selected as T cells ( is_TCell = TRUE ), and sent to SeuratClustering for further clustering and downstream analysis.","title":"Use indicator genes"},{"location":"processes/TESSA/","text":"TESSA \u00b6 Tessa is a Bayesian model to integrate T cell receptor (TCR) sequence profiling with transcriptomes of T cells. Enabled by the recently developed single cell sequencing techniques, which provide both TCR sequences and RNA sequences of each T cell concurrently, Tessa maps the functional landscape of the TCR repertoire, and generates insights into understanding human immune response to diseases. As the first part of tessa, BriseisEncoder is employed prior to the Bayesian algorithm to capture the TCR sequence features and create numerical embeddings. We showed that the reconstructed Atchley Factor matrices and CDR3 sequences, generated through the numerical embeddings, are highly similar to their original counterparts. The CDR3 peptide sequences are constructed via a RandomForest model applied on the reconstructed Atchley Factor matrices. See https://github.com/jcao89757/TESSA When finished, two columns will be added to the meta.data of the Seurat object: TESSA_Cluster : The cluster assignments from TESSA. TESSA_Cluster_Size : The number of cells in each cluster. These columns can be then used for further downstream analysis to explore the functional landscape of the TCR repertoire. Note The dependencies of TESSA are not included in the docker image of immunopipe with tag without -full suffix. If you want to use TESSA, please use the docker image with tag with -full suffix, or install the dependencies manually. Input \u00b6 immdata : The immunarch object in RDS file or text file of TCR data loaded by ImmunarchLoading srtobj : The Seurat object, saved in RDS format, with dimension reduction performed if you want to use them to represent the transcriptome of T cells. This could also be a tab delimited file (can be gzipped) with expression matrix or dimension reduction results. Output \u00b6 outfile : Default: {%- if in.srtobj.lower().endswith(\".rds\") -%} {{in.srtobj | stem}}.tessa.RDS {%- else -%} {{in.immdata | stem}}.tessa.txt {%- endif -%} . The tab-delimited file with three columns ( barcode , TESSA_Cluster and TESSA_Cluster_Size ) or an RDS file if in.srtobj is an RDS file of a Seurat object, with TESSA_Cluster and TESSA_Cluster_Size added to the meta.data Environment Variables \u00b6 python : Default: python . The path of python with TESSA 's dependencies installed prefix : The prefix of the cell barcodes in the Seurat object. Once could use a fixed prefix, or a placeholder with the column name in meta data. For example, \"{Sample}_\" will replace the placeholder with the value of the column Sample in meta data. If in.immdata is text file, the prefix will be ignored and the barcode should be already prefixed. If None and in.immdata is RDS file, immdata$prefix will be used. within_sample ( flag ) : Default: False . Whether the TCR networks are constructed only within TCRs from the same sample/patient (True) or with all the TCRs in the meta data matrix (False). assay : Which assay to use to extract the expression matrix. Only works if in.srtobj is an RDS file of a Seurat object. By default, if SCTransform is performed, SCT will be used. predefined_b ( flag ) : Default: False . Whether use the predefined b or not. Please check the paper of tessa for more details about the b vector. If True, the tessa will not update b in the MCMC iterations. max_iter ( type=int ) : Default: 1000 . The maximum number of iterations for MCMC. save_tessa ( flag ) : Default: False . Save tessa detailed results to seurat object? Only works if in.srtobj is an RDS file of a Seurat object. It will be saved to sobj@misc$tessa . Reference \u00b6 'Mapping the Functional Landscape of TCR Repertoire.', Zhang, Z., Xiong, D., Wang, X. et al. 2021. link 'Deep learning-based prediction of the T cell receptor-antigen binding specificity.', Lu, T., Zhang, Z., Zhu, J. et al. 2021. link Metadata \u00b6 The metadata of the Seurat object will be updated with the TESSA clusters and the cluster sizes:","title":"TESSA"},{"location":"processes/TESSA/#tessa","text":"Tessa is a Bayesian model to integrate T cell receptor (TCR) sequence profiling with transcriptomes of T cells. Enabled by the recently developed single cell sequencing techniques, which provide both TCR sequences and RNA sequences of each T cell concurrently, Tessa maps the functional landscape of the TCR repertoire, and generates insights into understanding human immune response to diseases. As the first part of tessa, BriseisEncoder is employed prior to the Bayesian algorithm to capture the TCR sequence features and create numerical embeddings. We showed that the reconstructed Atchley Factor matrices and CDR3 sequences, generated through the numerical embeddings, are highly similar to their original counterparts. The CDR3 peptide sequences are constructed via a RandomForest model applied on the reconstructed Atchley Factor matrices. See https://github.com/jcao89757/TESSA When finished, two columns will be added to the meta.data of the Seurat object: TESSA_Cluster : The cluster assignments from TESSA. TESSA_Cluster_Size : The number of cells in each cluster. These columns can be then used for further downstream analysis to explore the functional landscape of the TCR repertoire. Note The dependencies of TESSA are not included in the docker image of immunopipe with tag without -full suffix. If you want to use TESSA, please use the docker image with tag with -full suffix, or install the dependencies manually.","title":"TESSA"},{"location":"processes/TESSA/#input","text":"immdata : The immunarch object in RDS file or text file of TCR data loaded by ImmunarchLoading srtobj : The Seurat object, saved in RDS format, with dimension reduction performed if you want to use them to represent the transcriptome of T cells. This could also be a tab delimited file (can be gzipped) with expression matrix or dimension reduction results.","title":"Input"},{"location":"processes/TESSA/#output","text":"outfile : Default: {%- if in.srtobj.lower().endswith(\".rds\") -%} {{in.srtobj | stem}}.tessa.RDS {%- else -%} {{in.immdata | stem}}.tessa.txt {%- endif -%} . The tab-delimited file with three columns ( barcode , TESSA_Cluster and TESSA_Cluster_Size ) or an RDS file if in.srtobj is an RDS file of a Seurat object, with TESSA_Cluster and TESSA_Cluster_Size added to the meta.data","title":"Output"},{"location":"processes/TESSA/#environment-variables","text":"python : Default: python . The path of python with TESSA 's dependencies installed prefix : The prefix of the cell barcodes in the Seurat object. Once could use a fixed prefix, or a placeholder with the column name in meta data. For example, \"{Sample}_\" will replace the placeholder with the value of the column Sample in meta data. If in.immdata is text file, the prefix will be ignored and the barcode should be already prefixed. If None and in.immdata is RDS file, immdata$prefix will be used. within_sample ( flag ) : Default: False . Whether the TCR networks are constructed only within TCRs from the same sample/patient (True) or with all the TCRs in the meta data matrix (False). assay : Which assay to use to extract the expression matrix. Only works if in.srtobj is an RDS file of a Seurat object. By default, if SCTransform is performed, SCT will be used. predefined_b ( flag ) : Default: False . Whether use the predefined b or not. Please check the paper of tessa for more details about the b vector. If True, the tessa will not update b in the MCMC iterations. max_iter ( type=int ) : Default: 1000 . The maximum number of iterations for MCMC. save_tessa ( flag ) : Default: False . Save tessa detailed results to seurat object? Only works if in.srtobj is an RDS file of a Seurat object. It will be saved to sobj@misc$tessa .","title":"Environment Variables"},{"location":"processes/TESSA/#reference","text":"'Mapping the Functional Landscape of TCR Repertoire.', Zhang, Z., Xiong, D., Wang, X. et al. 2021. link 'Deep learning-based prediction of the T cell receptor-antigen binding specificity.', Lu, T., Zhang, Z., Zhu, J. et al. 2021. link","title":"Reference"},{"location":"processes/TESSA/#metadata","text":"The metadata of the Seurat object will be updated with the TESSA clusters and the cluster sizes:","title":"Metadata"},{"location":"processes/TopExpressingGenes/","text":"TopExpressingGenes \u00b6 Top expressing genes for clusters of all or selected T cells. This process finds the top expressing genes of clusters of T cells, and also performs the enrichment analysis against the genes. The enrichment analysis is done by enrichr . Note There are other environment variables also available. However, they should not be used in this process. Other environment variables are used for more complicated cases for investigating top genes (See biopipen.ns.scrna.TopExpressingGenes for more details). If you are using pipen-board to run the pipeline (see here and here ), you may see the other environment variables of this process are hidden and readonly. Input \u00b6 srtobj : The seurat object in RDS format Output \u00b6 outdir : Default: {{in.srtobj | stem}}.top_expressing_genes . The output directory for the tables and plots Environment Variables \u00b6 dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries n ( type=int ) : Default: 250 . The number of top expressing genes to find. subset : An expression to subset the cells for each case.","title":"TopExpressingGenes"},{"location":"processes/TopExpressingGenes/#topexpressinggenes","text":"Top expressing genes for clusters of all or selected T cells. This process finds the top expressing genes of clusters of T cells, and also performs the enrichment analysis against the genes. The enrichment analysis is done by enrichr . Note There are other environment variables also available. However, they should not be used in this process. Other environment variables are used for more complicated cases for investigating top genes (See biopipen.ns.scrna.TopExpressingGenes for more details). If you are using pipen-board to run the pipeline (see here and here ), you may see the other environment variables of this process are hidden and readonly.","title":"TopExpressingGenes"},{"location":"processes/TopExpressingGenes/#input","text":"srtobj : The seurat object in RDS format","title":"Input"},{"location":"processes/TopExpressingGenes/#output","text":"outdir : Default: {{in.srtobj | stem}}.top_expressing_genes . The output directory for the tables and plots","title":"Output"},{"location":"processes/TopExpressingGenes/#environment-variables","text":"dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries n ( type=int ) : Default: 250 . The number of top expressing genes to find. subset : An expression to subset the cells for each case.","title":"Environment Variables"},{"location":"processes/TopExpressingGenesOfAllCells/","text":"TopExpressingGenesOfAllCells \u00b6 Top expressing genes for clusters of all cells. See also TopExpressingGenes . Input \u00b6 srtobj : The seurat object in RDS format Output \u00b6 outdir : Default: {{in.srtobj | stem}}.top_expressing_genes . The output directory for the tables and plots Environment Variables \u00b6 dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries n ( type=int ) : Default: 250 . The number of top expressing genes to find. subset : An expression to subset the cells for each case.","title":"TopExpressingGenesOfAllCells"},{"location":"processes/TopExpressingGenesOfAllCells/#topexpressinggenesofallcells","text":"Top expressing genes for clusters of all cells. See also TopExpressingGenes .","title":"TopExpressingGenesOfAllCells"},{"location":"processes/TopExpressingGenesOfAllCells/#input","text":"srtobj : The seurat object in RDS format","title":"Input"},{"location":"processes/TopExpressingGenesOfAllCells/#output","text":"outdir : Default: {{in.srtobj | stem}}.top_expressing_genes . The output directory for the tables and plots","title":"Output"},{"location":"processes/TopExpressingGenesOfAllCells/#environment-variables","text":"dbs ( list ) : Default: ['KEGG_2021_Human', 'MSigDB_Hallmark_2020'] . The dbs to do enrichment analysis for significant markers See below for all libraries. https://maayanlab.cloud/Enrichr/#libraries n ( type=int ) : Default: 250 . The number of top expressing genes to find. subset : An expression to subset the cells for each case.","title":"Environment Variables"}]}